!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ACCEL	mock-simulator/simulator.cpp	/^#define ACCEL /;"	d	file:
ACCEL	sched/sim.cpp	/^#define ACCEL /;"	d	file:
ACCEL	sched/sim_tcp.cpp	/^#define ACCEL /;"	d	file:
ADD_ALT	db/trie.cpp	/^#define ADD_ALT(/;"	d	file:
ADD_FIELD	ui/manager.cpp	/^#define ADD_FIELD(/;"	d	file:
ADD_NEIGHBOR	mock-simulator/simulator.cpp	/^#define ADD_NEIGHBOR /;"	d	file:
ADD_NEIGHBOR	sched/sim.cpp	/^#define ADD_NEIGHBOR /;"	d	file:
ADD_NEIGHBOR	sched/sim_tcp.cpp	/^#define ADD_NEIGHBOR /;"	d	file:
ADD_NODE_FIELD	ui/manager.cpp	/^#define ADD_NODE_FIELD(/;"	d	file:
ADD_TUPLE_FIELD	ui/manager.cpp	/^#define ADD_TUPLE_FIELD(/;"	d	file:
AGG_FIRST	vm/types.hpp	/^   AGG_FIRST = 1,$/;"	e	enum:vm::aggregate_type
AGG_IMMEDIATE	vm/types.hpp	/^   AGG_IMMEDIATE = 4,$/;"	e	enum:vm::aggregate_safeness
AGG_LOCALLY_GENERATED	vm/types.hpp	/^   AGG_LOCALLY_GENERATED = 1,$/;"	e	enum:vm::aggregate_safeness
AGG_MAX_FLOAT	vm/types.hpp	/^   AGG_MAX_FLOAT = 5,$/;"	e	enum:vm::aggregate_type
AGG_MAX_INT	vm/types.hpp	/^   AGG_MAX_INT = 2,$/;"	e	enum:vm::aggregate_type
AGG_MIN_FLOAT	vm/types.hpp	/^   AGG_MIN_FLOAT = 6,$/;"	e	enum:vm::aggregate_type
AGG_MIN_INT	vm/types.hpp	/^   AGG_MIN_INT = 3,$/;"	e	enum:vm::aggregate_type
AGG_NEIGHBORHOOD	vm/types.hpp	/^   AGG_NEIGHBORHOOD = 2,$/;"	e	enum:vm::aggregate_safeness
AGG_NEIGHBORHOOD_AND_SELF	vm/types.hpp	/^   AGG_NEIGHBORHOOD_AND_SELF = 3,$/;"	e	enum:vm::aggregate_safeness
AGG_SUM_FLOAT	vm/types.hpp	/^   AGG_SUM_FLOAT = 7,$/;"	e	enum:vm::aggregate_type
AGG_SUM_INT	vm/types.hpp	/^   AGG_SUM_INT = 4,$/;"	e	enum:vm::aggregate_type
AGG_SUM_LIST_FLOAT	vm/types.hpp	/^   AGG_SUM_LIST_FLOAT = 11$/;"	e	enum:vm::aggregate_type
AGG_UNSAFE	vm/types.hpp	/^   AGG_UNSAFE = 5$/;"	e	enum:vm::aggregate_safeness
ALLOC_BASE	vm/instr.hpp	/^const size_t ALLOC_BASE          = 3;$/;"	m	namespace:vm::instr
ALLOC_INSTR	vm/instr.hpp	/^   ALLOC_INSTR		      =  0x40,$/;"	e	enum:vm::instr::instr_type
ALL_THREADS	vm/all.hpp	/^   std::vector<sched::base*> ALL_THREADS; \/* schedulers *\/$/;"	m	class:vm::all
ARCH	Makefile	/^ARCH = -march=x86-64$/;"	m
ARGUMENTS	vm/all.hpp	/^	machine_arguments ARGUMENTS;$/;"	m	class:vm::all
ARGUMENT_ANYTHING	vm/instr.hpp	/^   ARGUMENT_ANYTHING,$/;"	e	enum:vm::instr::instr_argument_type
ARGUMENT_ANYTHING_NOT_NIL	vm/instr.hpp	/^   ARGUMENT_ANYTHING_NOT_NIL,$/;"	e	enum:vm::instr::instr_argument_type
ARGUMENT_BOOL	vm/instr.hpp	/^   ARGUMENT_BOOL,$/;"	e	enum:vm::instr::instr_argument_type
ARGUMENT_INT	vm/instr.hpp	/^   ARGUMENT_INT,$/;"	e	enum:vm::instr::instr_argument_type
ARGUMENT_LIST	vm/instr.hpp	/^   ARGUMENT_LIST,$/;"	e	enum:vm::instr::instr_argument_type
ARGUMENT_NODE	vm/instr.hpp	/^   ARGUMENT_NODE$/;"	e	enum:vm::instr::instr_argument_type
ARGUMENT_NON_LIST	vm/instr.hpp	/^   ARGUMENT_NON_LIST,$/;"	e	enum:vm::instr::instr_argument_type
ARGUMENT_WRITABLE	vm/instr.hpp	/^   ARGUMENT_WRITABLE,$/;"	e	enum:vm::instr::instr_argument_type
ATOM_SIZE	mem/pool.hpp	/^   static const size_t ATOM_SIZE = 4;$/;"	m	class:mem::pool
BOTTOM	mock-simulator/simulator.cpp	/^   BOTTOM = 0,$/;"	e	enum:face_t	file:
BOTTOM	sched/nodes/sim.hpp	/^   BOTTOM = 0,$/;"	e	enum:sched::face_t
BUF_SIZE	external/others.cpp	/^#define BUF_SIZE /;"	d	file:
BUSY_LOOP_CHECK_TERMINATION_THREADS	sched/thread/threaded.hpp	/^#define BUSY_LOOP_CHECK_TERMINATION_THREADS(/;"	d
BUSY_LOOP_MAKE_INACTIVE	sched/thread/threaded.hpp	/^#define BUSY_LOOP_MAKE_INACTIVE(/;"	d
C0X	Makefile	/^C0X = -std=c++0x$/;"	m
CALL_BASE	vm/instr.hpp	/^const size_t CALL_BASE           = 4;$/;"	m	namespace:vm::instr
CALL_INSTR	vm/instr.hpp	/^   CALL_INSTR		      =  0x20,$/;"	e	enum:vm::instr::instr_type
CALL_MEMBER_FN	utils/macros.hpp	/^#define CALL_MEMBER_FN(/;"	d
CFLAGS	Makefile	/^CFLAGS = $(ARCH) $(PROFILING) $(OPTIMIZATIONS) $(WARNINGS) $(DEBUG) $(INCLUDE_DIRS) $(COX)$/;"	m
COLOCATED_BASE	vm/instr.hpp	/^const size_t COLOCATED_BASE      = 4;$/;"	m	namespace:vm::instr
COLOCATED_INSTR	vm/instr.hpp	/^   COLOCATED_INSTR      =  0x0C,$/;"	e	enum:vm::instr::instr_type
COMMAND_EXIT	server.cpp	/^	COMMAND_EXIT,$/;"	e	enum:__anon5	file:
COMMAND_HELP	server.cpp	/^	COMMAND_HELP,$/;"	e	enum:__anon5	file:
COMMAND_NONE	server.cpp	/^	COMMAND_NONE$/;"	e	enum:__anon5	file:
COMMAND_STATUS	server.cpp	/^	COMMAND_STATUS,$/;"	e	enum:__anon5	file:
COMMAND_VERSION	server.cpp	/^	COMMAND_VERSION,$/;"	e	enum:__anon5	file:
COMPILE	Makefile	/^COMPILE = $(CXX) $(CXXFLAGS) $(OBJS)$/;"	m
CONCAT_IMPL	utils/macros.hpp	/^#define CONCAT_IMPL(/;"	d
CONF_HPP	conf.hpp	/^#define CONF_HPP$/;"	d
CONS_BASE	vm/instr.hpp	/^const size_t CONS_BASE           = 5;$/;"	m	namespace:vm::instr
CONS_INSTR	vm/instr.hpp	/^   CONS_INSTR		      =  0x04,$/;"	e	enum:vm::instr::instr_type
CPUS	scripts/lib_csv.py	/^CPUS = [1, 2, 4, 6, 8, 10, 12, 14, 16]$/;"	v
CREATE_N_NODES	mock-simulator/simulator.cpp	/^#define CREATE_N_NODES /;"	d	file:
CREATE_N_NODES	sched/sim.cpp	/^#define CREATE_N_NODES /;"	d	file:
CREATE_ONE_NODE	sched/sim_tcp.cpp	/^#define CREATE_ONE_NODE /;"	d	file:
CXX	Makefile	/^CXX = g++$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS = $(CFLAGS)$/;"	m
Constants	docs/manual.tex	/^\\subsection{Constants}$/;"	b
DATABASE	vm/all.hpp	/^   db::database *DATABASE;$/;"	m	class:vm::all
DATABASE_HPP	db/database.hpp	/^#define DATABASE_HPP$/;"	d
DB_AGG_CONFIGURATION_HPP	db/agg_configuration.hpp	/^#define DB_AGG_CONFIGURATION_HPP$/;"	d
DB_EDGE_SET_HPP	db/edge_set.hpp	/^#define DB_EDGE_SET_HPP$/;"	d
DB_NEIGHBOR_AGG_CONFIGURATION_HPP	db/neighbor_agg_configuration.hpp	/^#define DB_NEIGHBOR_AGG_CONFIGURATION_HPP$/;"	d
DB_NEIGHBOR_TUPLE_AGGREGATE_HPP	db/neighbor_tuple_aggregate.hpp	/^#define DB_NEIGHBOR_TUPLE_AGGREGATE_HPP$/;"	d
DB_TRIE_HPP	db/trie.hpp	/^#define DB_TRIE_HPP$/;"	d
DB_TUPLE_AGGREGATE_HPP	db/tuple_aggregate.hpp	/^#define DB_TUPLE_AGGREGATE_HPP$/;"	d
DB_TUPLE_HPP	db/tuple.hpp	/^#define DB_TUPLE_HPP$/;"	d
DEBUG	Makefile	/^DEBUG = -g$/;"	m
DECLARE_DOUBLE_QUEUE_NODE	queue/intrusive.hpp	/^#define DECLARE_DOUBLE_QUEUE_NODE(/;"	d
DECLARE_FLOAT	vm/external.hpp	/^#define DECLARE_FLOAT(/;"	d
DECLARE_FLOAT_LIST	vm/external.hpp	/^#define DECLARE_FLOAT_LIST(/;"	d
DECLARE_INT	vm/external.hpp	/^#define DECLARE_INT(/;"	d
DECLARE_INT_LIST	vm/external.hpp	/^#define DECLARE_INT_LIST(/;"	d
DECLARE_JSON	ui/manager.cpp	/^#define DECLARE_JSON(/;"	d	file:
DECLARE_NODE	vm/external.hpp	/^#define DECLARE_NODE(/;"	d
DECLARE_NODE_LIST	vm/external.hpp	/^#define DECLARE_NODE_LIST(/;"	d
DECLARE_STRING	vm/external.hpp	/^#define DECLARE_STRING(/;"	d
DEFINE_PRIORITY_NODE	queue/intrusive.hpp	/^#define DEFINE_PRIORITY_NODE(/;"	d
DEFINE_START_FUNCTION	sched/thread/threaded.hpp	/^#define DEFINE_START_FUNCTION(/;"	d
DEFS_HPP	vm/defs.hpp	/^#define DEFS_HPP$/;"	d
DELETE_BASE	vm/instr.hpp	/^const size_t DELETE_BASE         = 3;$/;"	m	namespace:vm::instr
DELETE_INSTR	vm/instr.hpp	/^   DELETE_INSTR         =  0x0D,$/;"	e	enum:vm::instr::instr_type
DO_END_ROUND	sched/thread/threaded.hpp	/^#define DO_END_ROUND(/;"	d
Directories	docs/vm.tex	/^\\section{Directories}$/;"	s
Distribution Constraints	docs/manual.tex	/^\\subsection{Distribution Constraints}$/;"	b
EAST	mock-simulator/simulator.cpp	/^   EAST = 2,$/;"	e	enum:face_t	file:
EAST	sched/nodes/sim.hpp	/^   EAST = 2,$/;"	e	enum:sched::face_t
ELSE_INSTR	vm/instr.hpp	/^   ELSE_INSTR 		      =  0x02,$/;"	e	enum:vm::instr::instr_type
END	scripts/transform_letter_data.py	/^	END = 'J'$/;"	v
END	scripts/transform_letter_data.py	/^	END = sys.argv[2]$/;"	v
END_LINEAR_BASE	vm/instr.hpp	/^const size_t END_LINEAR_BASE     = 1;$/;"	m	namespace:vm::instr
END_LINEAR_INSTR	vm/instr.hpp	/^   END_LINEAR_INSTR     =  0x0F,$/;"	e	enum:vm::instr::instr_type
END_ROUND	sched/thread/threaded.hpp	/^#define END_ROUND(/;"	d
EVENT_PROGRAM_START	ui/manager.hpp	/^	EVENT_PROGRAM_START,$/;"	e	enum:ui::__anon6
EVENT_UNKNOWN	ui/manager.hpp	/^	EVENT_UNKNOWN$/;"	e	enum:ui::__anon6
EXECUTION_CONSUMED	vm/exec.hpp	/^   EXECUTION_CONSUMED$/;"	e	enum:vm::__anon9
EXECUTION_OK	vm/exec.hpp	/^   EXECUTION_OK,$/;"	e	enum:vm::__anon9
EXTERN	vm/external.cpp	/^#define EXTERN(/;"	d	file:
EXTERNAL0	vm/external.cpp	/^#define EXTERNAL0(/;"	d	file:
EXTERNAL1	vm/external.cpp	/^#define EXTERNAL1(/;"	d	file:
EXTERNAL2	vm/external.cpp	/^#define EXTERNAL2(/;"	d	file:
EXTERNAL3	vm/external.cpp	/^#define EXTERNAL3(/;"	d	file:
EXTERNAL_ARG	external/core.cpp	/^cpu_id(EXTERNAL_ARG(id))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/core.cpp	/^node_priority(EXTERNAL_ARG(id))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/lists.cpp	/^intlistappend(EXTERNAL_ARG(ls1), EXTERNAL_ARG(ls2))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/lists.cpp	/^intlistdiff(EXTERNAL_ARG(ls1), EXTERNAL_ARG(ls2))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/lists.cpp	/^intlistlength(EXTERNAL_ARG(ls))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/lists.cpp	/^intlistnth(EXTERNAL_ARG(ls), EXTERNAL_ARG(v))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/lists.cpp	/^intlistsub(EXTERNAL_ARG(p), EXTERNAL_ARG(a), EXTERNAL_ARG(b))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/lists.cpp	/^nodelistappend(EXTERNAL_ARG(ls1), EXTERNAL_ARG(ls2))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/lists.cpp	/^nodelistcount(EXTERNAL_ARG(ls), EXTERNAL_ARG(el))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/lists.cpp	/^nodelistlast(EXTERNAL_ARG(ls))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/lists.cpp	/^nodelistlength(EXTERNAL_ARG(ls))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/lists.cpp	/^nodelistremove(EXTERNAL_ARG(ls), EXTERNAL_ARG(n))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/lists.cpp	/^nodelistreverse(EXTERNAL_ARG(ls))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/lists.cpp	/^str2intlist(EXTERNAL_ARG(str))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/math.cpp	/^addfloatlists(EXTERNAL_ARG(ls1), EXTERNAL_ARG(ls2))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/math.cpp	/^convolve(EXTERNAL_ARG(bin_fact), EXTERNAL_ARG(ls))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/math.cpp	/^damp(EXTERNAL_ARG(ls1), EXTERNAL_ARG(ls2), EXTERNAL_ARG(fact))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/math.cpp	/^divide(EXTERNAL_ARG(ls1), EXTERNAL_ARG(ls2))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/math.cpp	/^intpower(EXTERNAL_ARG(n1), EXTERNAL_ARG(n2))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/math.cpp	/^normalize(EXTERNAL_ARG(x))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/math.cpp	/^residual(EXTERNAL_ARG(l1), EXTERNAL_ARG(l2))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/math.cpp	/^sigmoid(EXTERNAL_ARG(x))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/others.cpp	/^filecountwords(EXTERNAL_ARG(dirname), EXTERNAL_ARG(filenum))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/strings.cpp	/^concatenate(EXTERNAL_ARG(s1), EXTERNAL_ARG(s2))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/utils.cpp	/^float2int(EXTERNAL_ARG(x))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/utils.cpp	/^float2str(EXTERNAL_ARG(x))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/utils.cpp	/^int2str(EXTERNAL_ARG(x))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/utils.cpp	/^node2int(EXTERNAL_ARG(x))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/utils.cpp	/^randint(EXTERNAL_ARG(x))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/utils.cpp	/^str2float(EXTERNAL_ARG(x))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/utils.cpp	/^str2int(EXTERNAL_ARG(x))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/utils.cpp	/^truncate(EXTERNAL_ARG(x), EXTERNAL_ARG(many))$/;"	f	namespace:vm::external
EXTERNAL_ARG	external/utils.cpp	/^wastetime(EXTERNAL_ARG(x))$/;"	f	namespace:vm::external
EXTERNAL_ARG	vm/external.hpp	/^#define EXTERNAL_ARG(/;"	d
EXTERNAL_CORE_HPP	external/core.hpp	/^#define EXTERNAL_CORE_HPP$/;"	d
EXTERNAL_LISTS_HPP	external/lists.hpp	/^#define EXTERNAL_LISTS_HPP$/;"	d
EXTERNAL_MATH_HPP	external/math.hpp	/^#define EXTERNAL_MATH_HPP$/;"	d
EXTERNAL_OTHERS_HPP	external/others.hpp	/^#define EXTERNAL_OTHERS_HPP$/;"	d
EXTERNAL_STRING_HPP	external/strings.hpp	/^#define EXTERNAL_STRING_HPP$/;"	d
EXTERNAL_UTILS_HPP	external/utils.hpp	/^#define EXTERNAL_UTILS_HPP$/;"	d
Edge	client/springy.js	/^var Edge = function(id, source, target, data) {$/;"	c
Expressions	docs/manual.tex	/^\\subsection{Expressions}$/;"	b
FIELD_FLOAT	vm/types.hpp	/^   FIELD_FLOAT = 0x1,$/;"	e	enum:vm::field_type
FIELD_INT	vm/types.hpp	/^   FIELD_INT = 0x0,$/;"	e	enum:vm::field_type
FIELD_LIST_FLOAT	vm/types.hpp	/^   FIELD_LIST_FLOAT = 0x4,$/;"	e	enum:vm::field_type
FIELD_LIST_INT	vm/types.hpp	/^   FIELD_LIST_INT = 0x3,$/;"	e	enum:vm::field_type
FIELD_LIST_NODE	vm/types.hpp	/^   FIELD_LIST_NODE = 0x5,$/;"	e	enum:vm::field_type
FIELD_NODE	vm/types.hpp	/^   FIELD_NODE = 0x2,$/;"	e	enum:vm::field_type
FIELD_STRING	vm/types.hpp	/^	FIELD_STRING = 0x9$/;"	e	enum:vm::field_type
FIELD_WORKER	vm/types.hpp	/^   FIELD_WORKER = 0x6,$/;"	e	enum:vm::field_type
FINAL_FACE	sched/nodes/sim.hpp	/^   static const face_t FINAL_FACE = TOP;$/;"	m	class:sched::sim_node
FLOAT_BASE	vm/instr.hpp	/^const size_t FLOAT_BASE          = 3;$/;"	m	namespace:vm::instr
FLOAT_INSTR	vm/instr.hpp	/^   FLOAT_INSTR          =  0x09,$/;"	e	enum:vm::instr::instr_type
GCC_MINOR	Makefile	/^GCC_MINOR    := $(shell $(CXX) -v 2>&1 | \\$/;"	m
GET_NEXT	sched/thread/threaded.hpp	/^#define GET_NEXT(/;"	d
Graph	client/springy.js	/^var Graph = function() {$/;"	c
Graph.addEdge	client/springy.js	/^Graph.prototype.addEdge = function(edge) {$/;"	m
Graph.addGraphListener	client/springy.js	/^Graph.prototype.addGraphListener = function(obj) {$/;"	m
Graph.addNode	client/springy.js	/^Graph.prototype.addNode = function(node) {$/;"	m
Graph.detachNode	client/springy.js	/^Graph.prototype.detachNode = function(node) {$/;"	m
Graph.filterEdges	client/springy.js	/^Graph.prototype.filterEdges = function(fn) {$/;"	m
Graph.filterNodes	client/springy.js	/^Graph.prototype.filterNodes = function(fn) {$/;"	m
Graph.getEdges	client/springy.js	/^Graph.prototype.getEdges = function(node1, node2) {$/;"	m
Graph.getNode	client/springy.js	/^Graph.prototype.getNode = function(id) {$/;"	m
Graph.merge	client/springy.js	/^Graph.prototype.merge = function(data) {$/;"	m
Graph.newEdge	client/springy.js	/^Graph.prototype.newEdge = function(source, target, data) {$/;"	m
Graph.newNode	client/springy.js	/^Graph.prototype.newNode = function(data) {$/;"	m
Graph.notify	client/springy.js	/^Graph.prototype.notify = function() {$/;"	m
Graph.removeEdge	client/springy.js	/^Graph.prototype.removeEdge = function(edge) {$/;"	m
Graph.removeNode	client/springy.js	/^Graph.prototype.removeNode = function(node) {$/;"	m
Graph.reset	client/springy.js	/^Graph.prototype.reset = function () {$/;"	m
HASH_LIST	db/trie.cpp	/^#define HASH_LIST(/;"	d	file:
HASH_LIST	db/trie.cpp	/^#undef HASH_LIST$/;"	d	file:
HEAD_BASE	vm/instr.hpp	/^const size_t HEAD_BASE           = 4;$/;"	m	namespace:vm::instr
HEAD_INSTR	vm/instr.hpp	/^   HEAD_INSTR		      =  0x05,$/;"	e	enum:vm::instr::instr_type
HEAP_COMPARE	queue/safe_complex_pqueue.hpp	/^#define HEAP_COMPARE(/;"	d
HEAP_COMPARE	queue/safe_complex_pqueue.hpp	/^#undef HEAP_COMPARE$/;"	d
HEAP_COMPARE	queue/safe_simple_pqueue.hpp	/^#define HEAP_COMPARE(/;"	d
HEAP_COMPARE	queue/safe_simple_pqueue.hpp	/^#undef HEAP_COMPARE$/;"	d
HEAP_DEFINE_DATA	queue/heap_implementation.hpp	/^#define HEAP_DEFINE_DATA /;"	d
HEAP_DEFINE_DATA	queue/safe_complex_pqueue.hpp	/^	HEAP_DEFINE_DATA;$/;"	m	class:queue::intrusive_safe_complex_pqueue
HEAP_DEFINE_DATA	queue/safe_simple_pqueue.hpp	/^	HEAP_DEFINE_DATA;$/;"	m	class:queue::heap_queue
HEAP_DEFINE_EMPTY	queue/heap_implementation.hpp	/^#define HEAP_DEFINE_EMPTY	/;"	d
HEAP_DEFINE_EMPTY	queue/safe_complex_pqueue.hpp	/^	HEAP_DEFINE_EMPTY;$/;"	m	class:queue::intrusive_safe_complex_pqueue
HEAP_DEFINE_EMPTY	queue/safe_simple_pqueue.hpp	/^	HEAP_DEFINE_EMPTY;$/;"	m	class:queue::heap_queue
HEAP_DEFINE_HEAPIFYDOWN	queue/heap_implementation.hpp	/^#define HEAP_DEFINE_HEAPIFYDOWN	/;"	d
HEAP_DEFINE_HEAPIFYDOWN	queue/safe_complex_pqueue.hpp	/^	HEAP_DEFINE_HEAPIFYDOWN;$/;"	m	class:queue::intrusive_safe_complex_pqueue
HEAP_DEFINE_HEAPIFYDOWN	queue/safe_simple_pqueue.hpp	/^	HEAP_DEFINE_HEAPIFYDOWN;$/;"	m	class:queue::heap_queue
HEAP_DEFINE_HEAPIFYUP	queue/heap_implementation.hpp	/^#define HEAP_DEFINE_HEAPIFYUP	/;"	d
HEAP_DEFINE_HEAPIFYUP	queue/safe_complex_pqueue.hpp	/^	HEAP_DEFINE_HEAPIFYUP;$/;"	m	class:queue::intrusive_safe_complex_pqueue
HEAP_DEFINE_HEAPIFYUP	queue/safe_simple_pqueue.hpp	/^	HEAP_DEFINE_HEAPIFYUP;$/;"	m	class:queue::heap_queue
HEAP_DEFINE_MIN_VALUE	queue/heap_implementation.hpp	/^#define HEAP_DEFINE_MIN_VALUE	/;"	d
HEAP_DEFINE_MIN_VALUE	queue/safe_simple_pqueue.hpp	/^	HEAP_DEFINE_MIN_VALUE;$/;"	m	class:queue::heap_queue
HEAP_DEFINE_PRINT	queue/heap_implementation.hpp	/^#define HEAP_DEFINE_PRINT	/;"	d
HEAP_DEFINE_PRINT	queue/safe_simple_pqueue.hpp	/^	HEAP_DEFINE_PRINT;$/;"	m	class:queue::heap_queue
HEAP_DEFINE_SIZE	queue/heap_implementation.hpp	/^#define HEAP_DEFINE_SIZE /;"	d
HEAP_DEFINE_SIZE	queue/safe_complex_pqueue.hpp	/^   HEAP_DEFINE_SIZE;$/;"	m	class:queue::intrusive_safe_complex_pqueue
HEAP_DEFINE_UTILS	queue/heap_implementation.hpp	/^#define HEAP_DEFINE_UTILS	/;"	d
HEAP_DEFINE_UTILS	queue/safe_complex_pqueue.hpp	/^	HEAP_DEFINE_UTILS;$/;"	m	class:queue::intrusive_safe_complex_pqueue
HEAP_DEFINE_UTILS	queue/safe_simple_pqueue.hpp	/^	HEAP_DEFINE_UTILS;$/;"	m	class:queue::heap_queue
HEAP_FLOAT_ASC	queue/heap_implementation.hpp	/^	HEAP_FLOAT_ASC,$/;"	e	enum:__anon1
HEAP_FLOAT_DESC	queue/heap_implementation.hpp	/^	HEAP_FLOAT_DESC$/;"	e	enum:__anon1
HEAP_GET_POS	queue/safe_complex_pqueue.hpp	/^#define HEAP_GET_POS(/;"	d
HEAP_GET_POS	queue/safe_complex_pqueue.hpp	/^#undef HEAP_GET_POS$/;"	d
HEAP_GET_POS	queue/safe_simple_pqueue.hpp	/^#define HEAP_GET_POS(/;"	d
HEAP_GET_POS	queue/safe_simple_pqueue.hpp	/^#undef HEAP_GET_POS$/;"	d
HEAP_GET_PRIORITY	queue/safe_complex_pqueue.hpp	/^#define HEAP_GET_PRIORITY(/;"	d
HEAP_GET_PRIORITY	queue/safe_complex_pqueue.hpp	/^#undef HEAP_GET_PRIORITY$/;"	d
HEAP_GET_PRIORITY	queue/safe_simple_pqueue.hpp	/^#define HEAP_GET_PRIORITY(/;"	d
HEAP_GET_PRIORITY	queue/safe_simple_pqueue.hpp	/^#undef HEAP_GET_PRIORITY$/;"	d
HEAP_INT_ASC	queue/heap_implementation.hpp	/^	HEAP_INT_ASC,$/;"	e	enum:__anon1
HEAP_INT_DESC	queue/heap_implementation.hpp	/^	HEAP_INT_DESC,$/;"	e	enum:__anon1
HEAP_SET_INDEX	queue/heap_implementation.hpp	/^#define HEAP_SET_INDEX(/;"	d
HEIGHT	scripts/heat_color.py	/^HEIGHT = maxy * SCALE$/;"	v
HEIGHT	scripts/heat_count_color.py	/^HEIGHT = maxy * SCALE$/;"	v
HEIGHT	scripts/plots/active_inactive.py	/^HEIGHT = 64 * numcolumns$/;"	v
HIDDEN_BASE	scripts/generate_neural_network.py	/^HIDDEN_BASE = 100$/;"	v
Header	docs/manual.tex	/^\\subsection{Header}$/;"	b
How Are Rules Applied	docs/manual.tex	/^\\subsection{How Are Rules Applied}$/;"	b
How It All Fits Together The Quick Sort Algorithm	docs/manual.tex	/^\\section{How It All Fits Together: The Quick-Sort Algorithm}$/;"	s
How rules are executed	docs/vm.tex	/^\\section{How rules are executed}$/;"	s
IF_BASE	vm/instr.hpp	/^const size_t IF_BASE             = 2 + jump_size;$/;"	m	namespace:vm::instr
IF_INSTR	vm/instr.hpp	/^   IF_INSTR 		      =  0x60,$/;"	e	enum:vm::instr::instr_type
INCLUDE_DIRS	Makefile	/^INCLUDE_DIRS = -I.$/;"	m
INITIAL_FACE	sched/nodes/sim.hpp	/^   static const face_t INITIAL_FACE = BOTTOM;$/;"	m	class:sched::sim_node
INITIAL_NUM_ELEMS	mem/chunkgroup.hpp	/^   static const size_t INITIAL_NUM_ELEMS = 64;$/;"	m	class:mem::chunkgroup
INIT_DOUBLE_QUEUE_NODE	queue/intrusive.hpp	/^#define INIT_DOUBLE_QUEUE_NODE(/;"	d
INIT_PRIORITY_NODE	queue/intrusive.hpp	/^#define INIT_PRIORITY_NODE(/;"	d
INPUT_BASE	scripts/generate_neural_network.py	/^INPUT_BASE = 0$/;"	v
INSERT_LIST	db/trie.cpp	/^#define INSERT_LIST(/;"	d	file:
INSERT_LIST	db/trie.cpp	/^#undef INSERT_LIST$/;"	d	file:
INSTR_HPP	vm/instr.hpp	/^#define INSTR_HPP$/;"	d
INTERFACE_HPP	interface.hpp	/^#define INTERFACE_HPP$/;"	d
INVALID_FACE	sched/nodes/sim.hpp	/^   INVALID_FACE = -1,$/;"	e	enum:sched::face_t
ITER_BASE	vm/instr.hpp	/^const size_t ITER_BASE           = 8;$/;"	m	namespace:vm::instr
ITER_DB	vm/exec.cpp	/^	ITER_DB,$/;"	e	enum:vm::__anon8	file:
ITER_INSTR	vm/instr.hpp	/^   ITER_INSTR		      =  0xA0,$/;"	e	enum:vm::instr::instr_type
ITER_LOCAL	vm/exec.cpp	/^	ITER_LOCAL$/;"	e	enum:vm::__anon8	file:
ITER_QUEUE	vm/exec.cpp	/^	ITER_QUEUE,$/;"	e	enum:vm::__anon8	file:
Introduction	docs/manual.tex	/^\\section{Introduction}$/;"	s
LDFLAGS	Makefile	/^LDFLAGS = $(PROFILING) $(LIBRARY_DIRS) $(LIBRARIES)$/;"	m
LIBRARIES	Makefile	/^LIBRARIES = -pthread -lm -lreadline -lboost_thread-mt -lboost_system-mt \\$/;"	m
LIBRARY_DIRS	Makefile	/^LIBRARY_DIRS =$/;"	m
LIST_HPP	runtime/list.hpp	/^#define LIST_HPP$/;"	d
LOG_DATABASE	ui/manager.hpp	/^#define LOG_DATABASE(/;"	d
LOG_LINEAR_CONSUMPTION	ui/manager.hpp	/^#define LOG_LINEAR_CONSUMPTION(/;"	d
LOG_LINEAR_DERIVATION	ui/manager.hpp	/^#define LOG_LINEAR_DERIVATION(/;"	d
LOG_NEW_NODE	ui/manager.hpp	/^#define LOG_NEW_NODE(/;"	d
LOG_PERSISTENT_DERIVATION	ui/manager.hpp	/^#define LOG_PERSISTENT_DERIVATION(/;"	d
LOG_PROGRAM	ui/manager.hpp	/^#define LOG_PROGRAM(/;"	d
LOG_PROGRAM_RUNNING	ui/manager.hpp	/^#define LOG_PROGRAM_RUNNING(/;"	d
LOG_PROGRAM_STOPPED	ui/manager.hpp	/^#define LOG_PROGRAM_STOPPED(/;"	d
LOG_PROGRAM_TERMINATION	ui/manager.hpp	/^#define LOG_PROGRAM_TERMINATION(/;"	d
LOG_RULE_APPLIED	ui/manager.hpp	/^#define LOG_RULE_APPLIED(/;"	d
LOG_RULE_START	ui/manager.hpp	/^#define LOG_RULE_START(/;"	d
LOG_RUN	ui/manager.hpp	/^#define LOG_RUN(/;"	d
LOG_SET_COLOR	ui/manager.hpp	/^#define LOG_SET_COLOR(/;"	d
LOG_SET_EDGE_LABEL	ui/manager.hpp	/^#define LOG_SET_EDGE_LABEL(/;"	d
LOG_STEP_DONE	ui/manager.hpp	/^#define LOG_STEP_DONE(/;"	d
LOG_STEP_START	ui/manager.hpp	/^#define LOG_STEP_START(/;"	d
LOG_TUPLE_SEND	ui/manager.hpp	/^#define LOG_TUPLE_SEND(/;"	d
Layout.ForceDirected	client/springy.js	/^Layout.ForceDirected = function(graph, stiffness, repulsion, damping) {$/;"	c
Layout.ForceDirected.Point	client/springy.js	/^Layout.ForceDirected.Point = function(position, mass) {$/;"	c
Layout.ForceDirected.Point.applyForce	client/springy.js	/^Layout.ForceDirected.Point.prototype.applyForce = function(force) {$/;"	m
Layout.ForceDirected.Spring	client/springy.js	/^Layout.ForceDirected.Spring = function(point1, point2, length, k) {$/;"	c
Layout.ForceDirected.addAnimation	client/springy.js	/^Layout.ForceDirected.prototype.addAnimation = function (done, step) {$/;"	m
Layout.ForceDirected.applyCoulombsLaw	client/springy.js	/^Layout.ForceDirected.prototype.applyCoulombsLaw = function() {$/;"	m
Layout.ForceDirected.applyHookesLaw	client/springy.js	/^Layout.ForceDirected.prototype.applyHookesLaw = function() {$/;"	m
Layout.ForceDirected.attractToCentre	client/springy.js	/^Layout.ForceDirected.prototype.attractToCentre = function() {$/;"	m
Layout.ForceDirected.eachEdge	client/springy.js	/^Layout.ForceDirected.prototype.eachEdge = function(callback) {$/;"	m
Layout.ForceDirected.eachNode	client/springy.js	/^Layout.ForceDirected.prototype.eachNode = function(callback) {$/;"	m
Layout.ForceDirected.eachSpring	client/springy.js	/^Layout.ForceDirected.prototype.eachSpring = function(callback) {$/;"	m
Layout.ForceDirected.getBoundingBox	client/springy.js	/^Layout.ForceDirected.prototype.getBoundingBox = function() {$/;"	m
Layout.ForceDirected.nearest	client/springy.js	/^Layout.ForceDirected.prototype.nearest = function(pos) {$/;"	m
Layout.ForceDirected.point	client/springy.js	/^Layout.ForceDirected.prototype.point = function(node) {$/;"	m
Layout.ForceDirected.spring	client/springy.js	/^Layout.ForceDirected.prototype.spring = function(edge) {$/;"	m
Layout.ForceDirected.start	client/springy.js	/^Layout.ForceDirected.prototype.start = function(interval, render, done) {$/;"	m
Layout.ForceDirected.stop	client/springy.js	/^Layout.ForceDirected.prototype.stop = function () {$/;"	m
Layout.ForceDirected.totalEnergy	client/springy.js	/^Layout.ForceDirected.prototype.totalEnergy = function(timestep) {$/;"	m
Layout.ForceDirected.updatePosition	client/springy.js	/^Layout.ForceDirected.prototype.updatePosition = function(timestep) {$/;"	m
Layout.ForceDirected.updateVelocity	client/springy.js	/^Layout.ForceDirected.prototype.updateVelocity = function(timestep) {$/;"	m
Layout.ForceDirected.var.min.distance	client/springy.js	/^	var min = {node: null, point: null, distance: null};$/;"	p
Layout.ForceDirected.var.min.node	client/springy.js	/^	var min = {node: null, point: null, distance: null};$/;"	p
Layout.ForceDirected.var.min.point	client/springy.js	/^	var min = {node: null, point: null, distance: null};$/;"	p
MACHINE	vm/all.hpp	/^   process::machine *MACHINE;$/;"	m	class:vm::all
MACRO_CONCAT	utils/macros.hpp	/^#define MACRO_CONCAT(/;"	d
MAGIC1	vm/instr.hpp	/^const uint32_t MAGIC1 = 0x646c656d;$/;"	m	namespace:vm
MAGIC2	vm/instr.hpp	/^const uint32_t MAGIC2 = 0x6c696620;$/;"	m	namespace:vm
MAGIC_SIZE	vm/instr.hpp	/^const size_t MAGIC_SIZE = sizeof(uint64_t);$/;"	m	namespace:vm
MAJOR_VERSION	version.hpp	/^#define MAJOR_VERSION /;"	d
MAKE_OTHER_ACTIVE	sched/thread/threaded.hpp	/^#define MAKE_OTHER_ACTIVE(/;"	d
MARK_OWNED_NODES	conf.hpp	/^#define MARK_OWNED_NODES$/;"	d
MATCH_LIST	db/trie.cpp	/^#define MATCH_LIST(/;"	d	file:
MATCH_LIST_TYPE	db/trie.cpp	/^#define MATCH_LIST_TYPE(/;"	d	file:
MATCH_LIST_TYPE	db/trie.cpp	/^#undef MATCH_LIST_TYPE$/;"	d	file:
MAXLENGTH	sched/mpi.hpp	/^	static const size_t MAXLENGTH = 512 \/ sizeof(sim_sched::message_type);$/;"	m	class:sched::mpi_sched
MAXLENGTH	sched/sim.hpp	/^	static const size_t MAXLENGTH = 512 \/ sizeof(sim_sched::message_type);$/;"	m	class:sched::sim_sched
MAX_CONSTS	vm/all.hpp	/^#define MAX_CONSTS /;"	d
MAX_READ	scripts/generate_neural_network.py	/^	MAX_READ = 500$/;"	v
MAX_READ	scripts/generate_neural_network.py	/^	MAX_READ = int(sys.argv[5])$/;"	v
MAX_STRAT_LEVEL	vm/program.hpp	/^   static strat_level MAX_STRAT_LEVEL;$/;"	m	class:vm::program
MEM_ALLOCATOR_HPP	mem/allocator.hpp	/^#define MEM_ALLOCATOR_HPP$/;"	d
MEM_BASE_HPP	mem/base.hpp	/^#define MEM_BASE_HPP$/;"	d
MEM_CENTER_HPP	mem/center.hpp	/^#define MEM_CENTER_HPP$/;"	d
MEM_CHUNKGROUP_HPP	mem/chunkgroup.hpp	/^#define MEM_CHUNKGROUP_HPP$/;"	d
MEM_CHUNK_HPP	mem/chunk.hpp	/^#define MEM_CHUNK_HPP$/;"	d
MEM_METHODS	mem/base.hpp	/^#define MEM_METHODS(/;"	d
MEM_POOL_HPP	mem/pool.hpp	/^#define MEM_POOL_HPP$/;"	d
MEM_STAT_HPP	mem/stat.hpp	/^#define MEM_STAT_HPP$/;"	d
MEM_THREAD_HPP	mem/thread.hpp	/^#define MEM_THREAD_HPP$/;"	d
MINOR_VERSION	version.hpp	/^#define MINOR_VERSION /;"	d
MOVE_BASE	vm/instr.hpp	/^const size_t MOVE_BASE           = 3;$/;"	m	namespace:vm::instr
MOVE_INSTR	vm/instr.hpp	/^   MOVE_INSTR		      =  0x30,$/;"	e	enum:vm::instr::instr_type
MOVE_NIL_BASE	vm/instr.hpp	/^const size_t MOVE_NIL_BASE       = 2;$/;"	m	namespace:vm::instr
MOVE_NIL_INSTR	vm/instr.hpp	/^   MOVE_NIL_INSTR	      =  0x70,$/;"	e	enum:vm::instr::instr_type
MPI_HPP	sched/mpi.hpp	/^#define MPI_HPP$/;"	d
Meld Program Structure	docs/manual.tex	/^\\section{Meld Program Structure}$/;"	s
NEW_AXIOMS_BASE	vm/instr.hpp	/^const size_t NEW_AXIOMS_BASE     = 1 + jump_size;$/;"	m	namespace:vm::instr
NEW_AXIOMS_INSTR	vm/instr.hpp	/^   NEW_AXIOMS_INSTR     =  0x14,$/;"	e	enum:vm::instr::instr_type
NEW_NODE_BASE	vm/instr.hpp	/^const size_t NEW_NODE_BASE       = 2;$/;"	m	namespace:vm::instr
NEW_NODE_INSTR	vm/instr.hpp	/^   NEW_NODE_INSTR       =  0x13,$/;"	e	enum:vm::instr::instr_type
NEXT_BASE	vm/instr.hpp	/^const size_t NEXT_BASE           = 1;$/;"	m	namespace:vm::instr
NEXT_INSTR	vm/instr.hpp	/^   NEXT_INSTR		      =  0x01,$/;"	e	enum:vm::instr::instr_type
NODE_HPP	db/node.hpp	/^#define NODE_HPP$/;"	d
NODE_RUN	mock-simulator/simulator.cpp	/^#define NODE_RUN /;"	d	file:
NODE_RUN	sched/sim.cpp	/^#define NODE_RUN /;"	d	file:
NODE_RUN	sched/sim_tcp.cpp	/^#define NODE_RUN /;"	d	file:
NORTH	mock-simulator/simulator.cpp	/^   NORTH = 1,$/;"	e	enum:face_t	file:
NORTH	sched/nodes/sim.hpp	/^   NORTH = 1,$/;"	e	enum:sched::face_t
NOT_BASE	vm/instr.hpp	/^const size_t NOT_BASE            = 3;$/;"	m	namespace:vm::instr
NOT_INSTR	vm/instr.hpp	/^   NOT_INSTR		      =  0x07,$/;"	e	enum:vm::instr::instr_type
NOW_ACTIVE	stat/stat.hpp	/^   NOW_ACTIVE,$/;"	e	enum:statistics::sched_state
NOW_IDLE	stat/stat.hpp	/^   NOW_IDLE,$/;"	e	enum:statistics::sched_state
NOW_ROUND	stat/stat.hpp	/^   NOW_ROUND$/;"	e	enum:statistics::sched_state
NOW_SCHED	stat/stat.hpp	/^   NOW_SCHED,$/;"	e	enum:statistics::sched_state
NO_GLOBAL_PRIORITY	vm/predicate.hpp	/^   NO_GLOBAL_PRIORITY,$/;"	e	enum:vm::__anon10
NO_NEIGHBOR	sched/nodes/sim.hpp	/^   static const vm::node_val NO_NEIGHBOR = (vm::node_val)-1;$/;"	m	class:sched::sim_node
NUM_NODES_PER_PROCESS	vm/all.hpp	/^   size_t NUM_NODES_PER_PROCESS;$/;"	m	class:vm::all
NUM_REGS	vm/state.hpp	/^   static const size_t NUM_REGS = 32;$/;"	m	class:vm::state
NUM_THREADS	vm/all.hpp	/^   size_t NUM_THREADS;$/;"	m	class:vm::all
Node	client/springy.js	/^var Node = function(id, data) {$/;"	c
Node	client/springyui.js	/^	Node.prototype.getWidth = function() {$/;"	c
Node Instantiation	docs/manual.tex	/^\\subsection{Node Instantiation}$/;"	b
Node.getHeight	client/springyui.js	/^	Node.prototype.getHeight = function() {$/;"	m
Node.getWidth	client/springyui.js	/^	Node.prototype.getWidth = function() {$/;"	m
OBJS	Makefile	/^OBJS = $(patsubst %.cpp,%.o,$(SRCS))$/;"	m
ONE_PER_THREAD	scripts/generate_heat_grid.py	/^ONE_PER_THREAD = False$/;"	v
OPTIMIZATIONS	Makefile	/^OPTIMIZATIONS = -O0$/;"	m
OP_BASE	vm/instr.hpp	/^const size_t OP_BASE             = 5;$/;"	m	namespace:vm::instr
OP_DIVF	vm/instr.hpp	/^   OP_DIVF       = 0x14,$/;"	e	enum:vm::instr::instr_op
OP_DIVI	vm/instr.hpp	/^   OP_DIVI       = 0x15,$/;"	e	enum:vm::instr::instr_op
OP_EQA	vm/instr.hpp	/^   OP_EQA        = 0x17,$/;"	e	enum:vm::instr::instr_op
OP_EQF	vm/instr.hpp	/^   OP_EQF        = 0x2,$/;"	e	enum:vm::instr::instr_op
OP_EQI	vm/instr.hpp	/^   OP_EQI        = 0x3,$/;"	e	enum:vm::instr::instr_op
OP_GREATERA	vm/instr.hpp	/^   OP_GREATERA   = 0x18,$/;"	e	enum:vm::instr::instr_op
OP_GREATEREQF	vm/instr.hpp	/^   OP_GREATEREQF = 0xa,$/;"	e	enum:vm::instr::instr_op
OP_GREATEREQI	vm/instr.hpp	/^   OP_GREATEREQI = 0xb,$/;"	e	enum:vm::instr::instr_op
OP_GREATERF	vm/instr.hpp	/^   OP_GREATERF   = 0x8,$/;"	e	enum:vm::instr::instr_op
OP_GREATERI	vm/instr.hpp	/^   OP_GREATERI   = 0x9,$/;"	e	enum:vm::instr::instr_op
OP_INSTR	vm/instr.hpp	/^   OP_INSTR			      =  0xC0,$/;"	e	enum:vm::instr::instr_type
OP_LESSEQF	vm/instr.hpp	/^   OP_LESSEQF    = 0x6,$/;"	e	enum:vm::instr::instr_op
OP_LESSEQI	vm/instr.hpp	/^   OP_LESSEQI    = 0x7,$/;"	e	enum:vm::instr::instr_op
OP_LESSF	vm/instr.hpp	/^   OP_LESSF      = 0x4,$/;"	e	enum:vm::instr::instr_op
OP_LESSI	vm/instr.hpp	/^   OP_LESSI      = 0x5,$/;"	e	enum:vm::instr::instr_op
OP_MINUSF	vm/instr.hpp	/^   OP_MINUSF     = 0x10,$/;"	e	enum:vm::instr::instr_op
OP_MINUSI	vm/instr.hpp	/^   OP_MINUSI     = 0x11,$/;"	e	enum:vm::instr::instr_op
OP_MODF	vm/instr.hpp	/^   OP_MODF       = 0xc,$/;"	e	enum:vm::instr::instr_op
OP_MODI	vm/instr.hpp	/^   OP_MODI       = 0xd,$/;"	e	enum:vm::instr::instr_op
OP_NEQA	vm/instr.hpp	/^   OP_NEQA       = 0x16,$/;"	e	enum:vm::instr::instr_op
OP_NEQF	vm/instr.hpp	/^   OP_NEQF       = 0x0,$/;"	e	enum:vm::instr::instr_op
OP_NEQI	vm/instr.hpp	/^   OP_NEQI       = 0x1,$/;"	e	enum:vm::instr::instr_op
OP_ORB	vm/instr.hpp	/^   OP_ORB        = 0x19$/;"	e	enum:vm::instr::instr_op
OP_PLUSF	vm/instr.hpp	/^   OP_PLUSF      = 0xe,$/;"	e	enum:vm::instr::instr_op
OP_PLUSI	vm/instr.hpp	/^   OP_PLUSI      = 0xf,$/;"	e	enum:vm::instr::instr_op
OP_TIMESF	vm/instr.hpp	/^   OP_TIMESF     = 0x12,$/;"	e	enum:vm::instr::instr_op
OP_TIMESI	vm/instr.hpp	/^   OP_TIMESI     = 0x13,$/;"	e	enum:vm::instr::instr_op
OS	Makefile	/^OS = $(shell uname -s)$/;"	m
OUTPUT_BASE	scripts/generate_neural_network.py	/^OUTPUT_BASE = 200$/;"	v
POP_STATE	vm/exec.cpp	/^#define POP_STATE(/;"	d	file:
PORT	sched/mpi.hpp	/^	static int PORT;$/;"	m	class:sched::mpi_sched
PORT	sched/sim.hpp	/^	static int PORT;$/;"	m	class:sched::sim_sched
PREDICATE_DESCRIPTOR_SIZE	vm/program.cpp	/^static const size_t PREDICATE_DESCRIPTOR_SIZE = sizeof(code_size_t) +$/;"	m	namespace:vm	file:
PREDICATE_HPP	vm/predicate.hpp	/^#define PREDICATE_HPP$/;"	d
PRED_ACTION	vm/predicate.cpp	/^#define PRED_ACTION /;"	d	file:
PRED_AGG	vm/predicate.cpp	/^#define PRED_AGG /;"	d	file:
PRED_AGG_IMMEDIATE	vm/predicate.cpp	/^#define PRED_AGG_IMMEDIATE /;"	d	file:
PRED_AGG_INFO_MAX	vm/predicate.hpp	/^const size_t PRED_AGG_INFO_MAX = 32;$/;"	m	namespace:vm
PRED_AGG_LOCAL	vm/predicate.cpp	/^#define PRED_AGG_LOCAL /;"	d	file:
PRED_AGG_REMOTE	vm/predicate.cpp	/^#define PRED_AGG_REMOTE /;"	d	file:
PRED_AGG_REMOTE_AND_SELF	vm/predicate.cpp	/^#define PRED_AGG_REMOTE_AND_SELF /;"	d	file:
PRED_AGG_UNSAFE	vm/predicate.cpp	/^#define PRED_AGG_UNSAFE /;"	d	file:
PRED_ARGS_MAX	vm/predicate.hpp	/^const size_t PRED_ARGS_MAX = 32;$/;"	m	namespace:vm
PRED_DESCRIPTOR_BASE_SIZE	vm/predicate.hpp	/^const size_t PRED_DESCRIPTOR_BASE_SIZE = 4;$/;"	m	namespace:vm
PRED_LINEAR	vm/predicate.cpp	/^#define PRED_LINEAR /;"	d	file:
PRED_NAME_SIZE_MAX	vm/predicate.hpp	/^const size_t PRED_NAME_SIZE_MAX = 32;$/;"	m	namespace:vm
PRED_REUSED	vm/predicate.cpp	/^#define PRED_REUSED /;"	d	file:
PRED_REVERSE_ROUTE	vm/predicate.cpp	/^#define PRED_REVERSE_ROUTE /;"	d	file:
PRED_ROUTE	vm/predicate.cpp	/^#define PRED_ROUTE /;"	d	file:
PRIORITY_ASC	vm/predicate.hpp	/^   PRIORITY_ASC,$/;"	e	enum:vm::__anon10
PRIORITY_DESC	vm/predicate.hpp	/^   PRIORITY_DESC$/;"	e	enum:vm::__anon10
PROCESS_MACHINE_HPP	process/machine.hpp	/^#define PROCESS_MACHINE_HPP$/;"	d
PROCESS_WORK_HPP	process/work.hpp	/^#define PROCESS_WORK_HPP$/;"	d
PROFILING	Makefile	/^PROFILING = #-pg$/;"	m
PROGRAM	vm/all.hpp	/^   vm::program *PROGRAM;$/;"	m	class:vm::all
PROGRAM_HPP	vm/program.hpp	/^#define PROGRAM_HPP$/;"	d
PURGE_LIST	vm/state.cpp	/^#define PURGE_LIST(/;"	d	file:
PURGE_LIST	vm/state.cpp	/^#undef PURGE_LIST$/;"	d	file:
PURGE_OBJ	vm/state.cpp	/^#define PURGE_OBJ(/;"	d	file:
PURGE_OBJ	vm/state.cpp	/^#undef PURGE_OBJ$/;"	d	file:
PUSH_CURRENT_STATE	vm/exec.cpp	/^#define PUSH_CURRENT_STATE(/;"	d	file:
QUEUE_ASSERT_TOTAL_ZERO	queue/macros.hpp	/^#define QUEUE_ASSERT_TOTAL_ZERO(/;"	d
QUEUE_BOUNDED_PQUEUE_HPP	queue/bounded_pqueue.hpp	/^#define QUEUE_BOUNDED_PQUEUE_HPP$/;"	d
QUEUE_DECREMENT_TOTAL	queue/macros.hpp	/^#define QUEUE_DECREMENT_TOTAL(/;"	d
QUEUE_DEFINE_INTRUSIVE_CONSTRUCTOR	queue/intrusive_implementation.hpp	/^#define QUEUE_DEFINE_INTRUSIVE_CONSTRUCTOR(/;"	d
QUEUE_DEFINE_INTRUSIVE_CONST_ITERATOR	queue/intrusive_implementation.hpp	/^#define QUEUE_DEFINE_INTRUSIVE_CONST_ITERATOR(/;"	d
QUEUE_DEFINE_INTRUSIVE_DOUBLE_DATA	queue/intrusive_implementation.hpp	/^#define QUEUE_DEFINE_INTRUSIVE_DOUBLE_DATA(/;"	d
QUEUE_DEFINE_INTRUSIVE_DOUBLE_EMPTY	queue/intrusive_implementation.hpp	/^#define QUEUE_DEFINE_INTRUSIVE_DOUBLE_EMPTY(/;"	d
QUEUE_DEFINE_INTRUSIVE_DOUBLE_OPS	queue/intrusive_implementation.hpp	/^#define QUEUE_DEFINE_INTRUSIVE_DOUBLE_OPS(/;"	d
QUEUE_DEFINE_INTRUSIVE_DOUBLE_POP	queue/intrusive_implementation.hpp	/^#define QUEUE_DEFINE_INTRUSIVE_DOUBLE_POP(/;"	d
QUEUE_DEFINE_INTRUSIVE_DOUBLE_POP_IF_NOT_EMPTY	queue/intrusive_implementation.hpp	/^#define QUEUE_DEFINE_INTRUSIVE_DOUBLE_POP_IF_NOT_EMPTY(/;"	d
QUEUE_DEFINE_INTRUSIVE_IN_QUEUE	queue/intrusive_implementation.hpp	/^#define QUEUE_DEFINE_INTRUSIVE_IN_QUEUE(/;"	d
QUEUE_DEFINE_INTRUSIVE_MOVE_UP	queue/intrusive_implementation.hpp	/^#define QUEUE_DEFINE_INTRUSIVE_MOVE_UP(/;"	d
QUEUE_DEFINE_INTRUSIVE_REMOVE	queue/intrusive_implementation.hpp	/^#define QUEUE_DEFINE_INTRUSIVE_REMOVE(/;"	d
QUEUE_DEFINE_LINEAR_BASE_DATA	queue/unsafe_linear_queue.hpp	/^#define QUEUE_DEFINE_LINEAR_BASE_DATA(/;"	d
QUEUE_DEFINE_LINEAR_CLEAR	queue/unsafe_linear_queue.hpp	/^#define QUEUE_DEFINE_LINEAR_CLEAR(/;"	d
QUEUE_DEFINE_LINEAR_CONSTRUCTOR	queue/unsafe_linear_queue.hpp	/^#define QUEUE_DEFINE_LINEAR_CONSTRUCTOR(/;"	d
QUEUE_DEFINE_LINEAR_CONST_ITERATOR	queue/iterators.hpp	/^#define QUEUE_DEFINE_LINEAR_CONST_ITERATOR(/;"	d
QUEUE_DEFINE_LINEAR_CONST_ITERATOR_CLASS	queue/iterators.hpp	/^#define QUEUE_DEFINE_LINEAR_CONST_ITERATOR_CLASS(/;"	d
QUEUE_DEFINE_LINEAR_DATA	queue/unsafe_linear_queue.hpp	/^#define QUEUE_DEFINE_LINEAR_DATA(/;"	d
QUEUE_DEFINE_LINEAR_DESTRUCTOR	queue/unsafe_linear_queue.hpp	/^#define QUEUE_DEFINE_LINEAR_DESTRUCTOR(/;"	d
QUEUE_DEFINE_LINEAR_EMPTY	queue/unsafe_linear_queue.hpp	/^#define QUEUE_DEFINE_LINEAR_EMPTY(/;"	d
QUEUE_DEFINE_LINEAR_POP_LIST	queue/unsafe_linear_queue.hpp	/^#define QUEUE_DEFINE_LINEAR_POP_LIST(/;"	d
QUEUE_DEFINE_LINEAR_POP_NODE	queue/unsafe_linear_queue.hpp	/^#define QUEUE_DEFINE_LINEAR_POP_NODE(/;"	d
QUEUE_DEFINE_LINEAR_PUSH_NODE	queue/unsafe_linear_queue.hpp	/^#define QUEUE_DEFINE_LINEAR_PUSH_NODE(/;"	d
QUEUE_DEFINE_LINEAR_TOP_NODE	queue/unsafe_linear_queue.hpp	/^#define QUEUE_DEFINE_LINEAR_TOP_NODE(/;"	d
QUEUE_DEFINE_TOTAL	queue/macros.hpp	/^#define QUEUE_DEFINE_TOTAL(/;"	d
QUEUE_DEFINE_TOTAL_SERIAL	queue/macros.hpp	/^#define QUEUE_DEFINE_TOTAL_SERIAL(/;"	d
QUEUE_DEFINE_TOTAL_SIZE	queue/macros.hpp	/^#define QUEUE_DEFINE_TOTAL_SIZE(/;"	d
QUEUE_HEAP_IMPLEMENTATION_HPP	queue/heap_implementation.hpp	/^#define QUEUE_HEAP_IMPLEMENTATION_HPP$/;"	d
QUEUE_INCREMENT_TOTAL	queue/macros.hpp	/^#define QUEUE_INCREMENT_TOTAL(/;"	d
QUEUE_INCREMENT_TOTAL_N	queue/macros.hpp	/^#define QUEUE_INCREMENT_TOTAL_N(/;"	d
QUEUE_INTRUSIVE_HPP	queue/intrusive.hpp	/^#define QUEUE_INTRUSIVE_HPP$/;"	d
QUEUE_INTRUSIVE_IMPLEMENTATION_HPP	queue/intrusive_implementation.hpp	/^#define QUEUE_INTRUSIVE_IMPLEMENTATION_HPP$/;"	d
QUEUE_ITERATORS_HPP	queue/iterators.hpp	/^#define QUEUE_ITERATORS_HPP$/;"	d
QUEUE_MACROS_HPP	queue/macros.hpp	/^#define QUEUE_MACROS_HPP$/;"	d
QUEUE_NODE_HPP	queue/node.hpp	/^#define QUEUE_NODE_HPP$/;"	d
QUEUE_SAFE_COMPLEX_PQUEUE_HPP	queue/safe_complex_pqueue.hpp	/^#define QUEUE_SAFE_COMPLEX_PQUEUE_HPP$/;"	d
QUEUE_SAFE_DOUBLE_QUEUE_HPP	queue/safe_double_queue.hpp	/^#define QUEUE_SAFE_DOUBLE_QUEUE_HPP$/;"	d
QUEUE_SAFE_GENERAL_PQUEUE_HPP	queue/safe_general_pqueue.hpp	/^#define QUEUE_SAFE_GENERAL_PQUEUE_HPP$/;"	d
QUEUE_SAFE_QUEUE_HPP	queue/safe_linear_queue.hpp	/^#define QUEUE_SAFE_QUEUE_HPP$/;"	d
QUEUE_SAFE_SIMPLE_PQUEUE_HPP	queue/safe_simple_pqueue.hpp	/^#define QUEUE_SAFE_SIMPLE_PQUEUE_HPP$/;"	d
QUEUE_SIMPLE_LINEAR_PQUEUE_HPP	queue/simple_linear_pqueue.hpp	/^#define QUEUE_SIMPLE_LINEAR_PQUEUE_HPP$/;"	d
QUEUE_UNSAFE_DOUBLE_QUEUE_HPP	queue/unsafe_double_queue.hpp	/^#define QUEUE_UNSAFE_DOUBLE_QUEUE_HPP$/;"	d
QUEUE_UNSAFE_LINEAR_QUEUE_HPP	queue/unsafe_linear_queue.hpp	/^#define QUEUE_UNSAFE_LINEAR_QUEUE_HPP$/;"	d
QUEUE_ZERO_TOTAL	queue/macros.hpp	/^#define QUEUE_ZERO_TOTAL(/;"	d
READ_CODE	vm/program.cpp	/^#define READ_CODE(/;"	d	file:
RECEIVE_MESSAGE	mock-simulator/simulator.cpp	/^#define RECEIVE_MESSAGE /;"	d	file:
RECEIVE_MESSAGE	sched/sim.cpp	/^#define RECEIVE_MESSAGE /;"	d	file:
RECEIVE_MESSAGE	sched/sim_tcp.cpp	/^#define RECEIVE_MESSAGE /;"	d	file:
REMOVE_BASE	vm/instr.hpp	/^const size_t REMOVE_BASE         = 2;$/;"	m	namespace:vm::instr
REMOVE_INSTR	vm/instr.hpp	/^   REMOVE_INSTR 	      =  0x80,$/;"	e	enum:vm::instr::instr_type
REMOVE_NEIGHBOR	mock-simulator/simulator.cpp	/^#define REMOVE_NEIGHBOR /;"	d	file:
REMOVE_NEIGHBOR	sched/sim.cpp	/^#define REMOVE_NEIGHBOR /;"	d	file:
REMOVE_NEIGHBOR	sched/sim_tcp.cpp	/^#define REMOVE_NEIGHBOR /;"	d	file:
RESET_LINEAR_BASE	vm/instr.hpp	/^const size_t RESET_LINEAR_BASE   = 1 + jump_size;$/;"	m	namespace:vm::instr
RESET_LINEAR_INSTR	vm/instr.hpp	/^   RESET_LINEAR_INSTR   =  0x0E,$/;"	e	enum:vm::instr::instr_type
RETURN_BASE	vm/instr.hpp	/^const size_t RETURN_BASE         = 1;$/;"	m	namespace:vm::instr
RETURN_DERIVED	vm/exec.cpp	/^   RETURN_DERIVED,$/;"	e	enum:vm::return_type	file:
RETURN_DERIVED_BASE	vm/instr.hpp	/^const size_t RETURN_DERIVED_BASE = 1;$/;"	m	namespace:vm::instr
RETURN_DERIVED_INSTR	vm/instr.hpp	/^   RETURN_DERIVED_INSTR =  0xF0$/;"	e	enum:vm::instr::instr_type
RETURN_END_LINEAR	vm/exec.cpp	/^	RETURN_END_LINEAR,$/;"	e	enum:vm::return_type	file:
RETURN_FLOAT	vm/external.hpp	/^#define RETURN_FLOAT(/;"	d
RETURN_FLOAT_LIST	vm/external.hpp	/^#define RETURN_FLOAT_LIST(/;"	d
RETURN_INSTR	vm/instr.hpp	/^   RETURN_INSTR	      =  0x00,$/;"	e	enum:vm::instr::instr_type
RETURN_INT	vm/external.hpp	/^#define RETURN_INT(/;"	d
RETURN_INT_LIST	vm/external.hpp	/^#define RETURN_INT_LIST(/;"	d
RETURN_LINEAR	vm/exec.cpp	/^   RETURN_LINEAR,$/;"	e	enum:vm::return_type	file:
RETURN_LINEAR_BASE	vm/instr.hpp	/^const size_t RETURN_LINEAR_BASE  = 1;$/;"	m	namespace:vm::instr
RETURN_LINEAR_INSTR	vm/instr.hpp	/^   RETURN_LINEAR_INSTR  =  0xD0,$/;"	e	enum:vm::instr::instr_type
RETURN_NEXT	vm/exec.cpp	/^   RETURN_NEXT,$/;"	e	enum:vm::return_type	file:
RETURN_NODE	vm/external.hpp	/^#define RETURN_NODE(/;"	d
RETURN_NODE_LIST	vm/external.hpp	/^#define RETURN_NODE_LIST(/;"	d
RETURN_NO_RETURN	vm/exec.cpp	/^   RETURN_NO_RETURN$/;"	e	enum:vm::return_type	file:
RETURN_OK	vm/exec.cpp	/^   RETURN_OK,$/;"	e	enum:vm::return_type	file:
RETURN_PTR	vm/external.hpp	/^#define RETURN_PTR(/;"	d
RETURN_SELECT	vm/exec.cpp	/^   RETURN_SELECT,$/;"	e	enum:vm::return_type	file:
RETURN_SELECT_BASE	vm/instr.hpp	/^const size_t RETURN_SELECT_BASE  = 5;$/;"	m	namespace:vm::instr
RETURN_SELECT_INSTR	vm/instr.hpp	/^   RETURN_SELECT_INSTR  =  0x0B,$/;"	e	enum:vm::instr::instr_type
RETURN_STRING	vm/external.hpp	/^#define RETURN_STRING(/;"	d
RULE_BASE	vm/instr.hpp	/^const size_t RULE_BASE           = 1 + uint_size;$/;"	m	namespace:vm::instr
RULE_DONE_BASE	vm/instr.hpp	/^const size_t RULE_DONE_BASE      = 1;$/;"	m	namespace:vm::instr
RULE_DONE_INSTR	vm/instr.hpp	/^   RULE_DONE_INSTR      =  0x11,$/;"	e	enum:vm::instr::instr_type
RULE_INSTR	vm/instr.hpp	/^   RULE_INSTR           =  0x10,$/;"	e	enum:vm::instr::instr_type
RUNTIME_STRING_HPP	runtime/string.hpp	/^#define RUNTIME_STRING_HPP$/;"	d
RUN_NODE	mock-simulator/simulator.cpp	/^#define RUN_NODE /;"	d	file:
RUN_NODE	sched/sim.cpp	/^#define RUN_NODE /;"	d	file:
RUN_NODE	sched/sim_tcp.cpp	/^#define RUN_NODE /;"	d	file:
Renderer	client/springy.js	/^function Renderer(interval, layout, clear, drawEdge, drawNode) {$/;"	c
Renderer.addAnimation	client/springy.js	/^Renderer.prototype.addAnimation = function (done, step) {$/;"	m
Renderer.graphChanged	client/springy.js	/^Renderer.prototype.graphChanged = function(e) {$/;"	m
Renderer.start	client/springy.js	/^Renderer.prototype.start = function() {$/;"	m
Renderer.stop	client/springy.js	/^Renderer.prototype.stop = function () {$/;"	m
Rule Matcher	docs/vm.tex	/^\\subsection{Rule Matcher}$/;"	b
SCALE	scripts/heat_color.py	/^SCALE = 20$/;"	v
SCALE	scripts/heat_count_color.py	/^SCALE = 20$/;"	v
SCHED_BASE_HPP	sched/base.hpp	/^#define SCHED_BASE_HPP$/;"	d
SCHED_COMMON_HPP	sched/common.hpp	/^#define SCHED_COMMON_HPP$/;"	d
SCHED_NODES_IN_QUEUE_HPP	sched/nodes/in_queue.hpp	/^#define SCHED_NODES_IN_QUEUE_HPP$/;"	d
SCHED_NODES_SERIAL_HPP	sched/nodes/serial.hpp	/^#define SCHED_NODES_SERIAL_HPP$/;"	d
SCHED_NODES_SIM_HPP	sched/nodes/sim.hpp	/^#define SCHED_NODES_SIM_HPP$/;"	d
SCHED_NODES_THREAD_HPP	sched/nodes/thread.hpp	/^#define SCHED_NODES_THREAD_HPP$/;"	d
SCHED_NODES_THREAD_INTRUSIVE_HPP	sched/nodes/thread_intrusive.hpp	/^#define SCHED_NODES_THREAD_INTRUSIVE_HPP$/;"	d
SCHED_NODES_UNSAFE_STATIC_HPP	sched/nodes/unsafe_static.hpp	/^#define SCHED_NODES_UNSAFE_STATIC_HPP$/;"	d
SCHED_SERIAL	sched/types.hpp	/^   SCHED_SERIAL,$/;"	e	enum:sched::scheduler_type
SCHED_SERIAL_HPP	sched/serial.hpp	/^#define SCHED_SERIAL_HPP$/;"	d
SCHED_SERIAL_UI	sched/types.hpp	/^    SCHED_SERIAL_UI,$/;"	e	enum:sched::scheduler_type
SCHED_SIM	sched/types.hpp	/^    SCHED_SIM$/;"	e	enum:sched::scheduler_type
SCHED_SIM_HPP	sched/sim.hpp	/^#define SCHED_SIM_HPP$/;"	d
SCHED_THREAD_ASSERT_HPP	sched/thread/assert.hpp	/^#define SCHED_THREAD_ASSERT_HPP$/;"	d
SCHED_THREAD_STATE_HPP	sched/thread/state.hpp	/^#define SCHED_THREAD_STATE_HPP$/;"	d
SCHED_THREAD_STEAL_SET_HPP	sched/thread/steal_set.hpp	/^#define SCHED_THREAD_STEAL_SET_HPP$/;"	d
SCHED_THREAD_TERMINATION_BARRIER_HPP	sched/thread/termination_barrier.hpp	/^#define SCHED_THREAD_TERMINATION_BARRIER_HPP$/;"	d
SCHED_THREAD_THREADED_HPP	sched/thread/threaded.hpp	/^#define SCHED_THREAD_THREADED_HPP$/;"	d
SCHED_THREAD_TRI_BARRIER_HPP	sched/thread/tri_barrier.hpp	/^#define SCHED_THREAD_TRI_BARRIER_HPP$/;"	d
SCHED_TYPES_HPP	sched/types.hpp	/^#define SCHED_TYPES_HPP$/;"	d
SCHED_UNKNOWN	sched/types.hpp	/^   SCHED_UNKNOWN,$/;"	e	enum:sched::scheduler_type
SEEK_CODE	vm/program.cpp	/^#define SEEK_CODE(/;"	d	file:
SELECT_BASE	vm/instr.hpp	/^const size_t SELECT_BASE         = 9;$/;"	m	namespace:vm::instr
SELECT_INSTR	vm/instr.hpp	/^   SELECT_INSTR         =  0x0A,$/;"	e	enum:vm::instr::instr_type
SEND_BASE	vm/instr.hpp	/^const size_t SEND_BASE           = 3;$/;"	m	namespace:vm::instr
SEND_CLIENT_JSON	ui/manager.cpp	/^#define SEND_CLIENT_JSON(/;"	d	file:
SEND_CURRENT_CLIENT	ui/manager.cpp	/^#define SEND_CURRENT_CLIENT(/;"	d	file:
SEND_DELAY_BASE	vm/instr.hpp	/^const size_t SEND_DELAY_BASE     = 3 + uint_size;$/;"	m	namespace:vm::instr
SEND_DELAY_INSTR	vm/instr.hpp	/^   SEND_DELAY_INSTR     =  0x15,$/;"	e	enum:vm::instr::instr_type
SEND_INSTR	vm/instr.hpp	/^   SEND_INSTR 		      =  0x08,$/;"	e	enum:vm::instr::instr_type
SEND_JSON	ui/manager.cpp	/^#define SEND_JSON(/;"	d	file:
SEND_MESSAGE	mock-simulator/simulator.cpp	/^#define SEND_MESSAGE /;"	d	file:
SEND_MESSAGE	sched/sim.cpp	/^#define SEND_MESSAGE /;"	d	file:
SEND_MESSAGE	sched/sim_tcp.cpp	/^#define SEND_MESSAGE /;"	d	file:
SET_COLOR	mock-simulator/simulator.cpp	/^#define SET_COLOR /;"	d	file:
SET_COLOR	sched/sim.cpp	/^#define SET_COLOR /;"	d	file:
SET_COLOR	sched/sim_tcp.cpp	/^#define SET_COLOR /;"	d	file:
SHAKE	mock-simulator/simulator.cpp	/^#define SHAKE /;"	d	file:
SHAKE	sched/sim.cpp	/^#define SHAKE /;"	d	file:
SHAKE	sched/sim_tcp.cpp	/^#define SHAKE /;"	d	file:
SIZE_PATH	scripts/generate_random_shortest_path.py	/^SIZE_PATH = int(float(total) \/ 2.0)$/;"	v
SLICE_PERIOD	stat/stat.hpp	/^const unsigned int SLICE_PERIOD = 15;$/;"	m	namespace:statistics
SOUTH	mock-simulator/simulator.cpp	/^   SOUTH = 4,$/;"	e	enum:face_t	file:
SOUTH	sched/nodes/sim.hpp	/^   SOUTH = 4,$/;"	e	enum:sched::face_t
SRCS	Makefile	/^SRCS = utils\/utils.cpp \\$/;"	m
START_ROUND	sched/thread/threaded.hpp	/^#define START_ROUND(/;"	d
STATIC_INLINE	vm/instr.hpp	/^#define STATIC_INLINE /;"	d
STATIC_INLINE	vm/instr.hpp	/^#define STATIC_INLINE$/;"	d
STAT_SLICE_HPP	stat/slice.hpp	/^#define STAT_SLICE_HPP$/;"	d
STAT_SLICE_SET	stat/slice_set.hpp	/^#define STAT_SLICE_SET$/;"	d
STAT_STAT_HPP	stat/stat.hpp	/^#define STAT_STAT_HPP$/;"	d
STOP	mock-simulator/simulator.cpp	/^#define STOP /;"	d	file:
STOP	sched/sim.cpp	/^#define STOP /;"	d	file:
STOP	sched/sim_tcp.cpp	/^#define STOP /;"	d	file:
TAIL_BASE	vm/instr.hpp	/^const size_t TAIL_BASE           = 4;$/;"	m	namespace:vm::instr
TAIL_INSTR	vm/instr.hpp	/^   TAIL_INSTR		      =  0x06,$/;"	e	enum:vm::instr::instr_type
TAP	mock-simulator/simulator.cpp	/^#define TAP /;"	d	file:
TAP	sched/sim.cpp	/^#define TAP /;"	d	file:
TAP	sched/sim_tcp.cpp	/^#define TAP /;"	d	file:
TASK_STEALING_FACTOR	vm/all.hpp	/^   static const double TASK_STEALING_FACTOR = 0.2;$/;"	m	class:vm::all
TEMPORARY_CODE_DIRECTORY	ui/manager.hpp	/^#define TEMPORARY_CODE_DIRECTORY /;"	d
TEST_NIL_BASE	vm/instr.hpp	/^const size_t TEST_NIL_BASE       = 3;$/;"	m	namespace:vm::instr
TEST_NIL_INSTR	vm/instr.hpp	/^   TEST_NIL_INSTR	      =  0x03,$/;"	e	enum:vm::instr::instr_type
THREAD_ACTIVE	sched/thread/state.hpp	/^   THREAD_ACTIVE,$/;"	e	enum:sched::thread_state
THREAD_INACTIVE	sched/thread/state.hpp	/^   THREAD_INACTIVE$/;"	e	enum:sched::thread_state
TIME_TO_INSTANTIATE	sched/sim.cpp	/^static const int TIME_TO_INSTANTIATE = 500;$/;"	v	file:
TIME_TO_INSTANTIATE	sched/sim_tcp.cpp	/^static const int TIME_TO_INSTANTIATE = 500;$/;"	v	file:
TOP	mock-simulator/simulator.cpp	/^   TOP = 5$/;"	e	enum:face_t	file:
TOP	sched/nodes/sim.hpp	/^   TOP = 5$/;"	e	enum:sched::face_t
TRIE_MATCHING	conf.hpp	/^#define TRIE_MATCHING /;"	d
TYPES_HPP	vm/types.hpp	/^#define TYPES_HPP$/;"	d
UILIBRARIES	Makefile	/^UILIBRARIES = #-lwebsocketpp -ljson_spirit$/;"	m
UI_ADD_ELEM	ui/macros.hpp	/^#define UI_ADD_ELEM(/;"	d
UI_ADD_FIELD	ui/macros.hpp	/^#define UI_ADD_FIELD(/;"	d
UI_ADD_NODE_FIELD	ui/macros.hpp	/^#define UI_ADD_NODE_FIELD(/;"	d
UI_ADD_TUPLE_FIELD	ui/macros.hpp	/^#define UI_ADD_TUPLE_FIELD(/;"	d
UI_CLIENT_HPP	ui/client.hpp	/^#define UI_CLIENT_HPP$/;"	d
UI_MACROS_HPP	ui/macros.hpp	/^#define UI_MACROS_HPP$/;"	d
UI_MANAGER_HPP	ui/manager.hpp	/^#define UI_MANAGER_HPP$/;"	d
UI_NIL	ui/macros.hpp	/^#define UI_NIL /;"	d
UI_YES	ui/macros.hpp	/^#define UI_YES /;"	d
USE_ALLOCATOR	conf.hpp	/^const bool USE_ALLOCATOR = true;$/;"	v
USE_RULE_COUNTING	conf.hpp	/^#define USE_RULE_COUNTING /;"	d
USE_SIM	conf.hpp	/^#define USE_SIM$/;"	d
USE_THREADS	mock-simulator/simulator.cpp	/^#define USE_THREADS /;"	d	file:
USE_THREADS	sched/sim.cpp	/^#define USE_THREADS /;"	d	file:
USE_THREADS	sched/sim_tcp.cpp	/^#define USE_THREADS /;"	d	file:
UTILS_ATOMIC_HPP	utils/atomic.hpp	/^#define UTILS_ATOMIC_HPP$/;"	d
UTILS_FS_HPP	utils/fs.hpp	/^#define UTILS_FS_HPP$/;"	d
UTILS_INTERVAL_HPP	utils/interval.hpp	/^#define UTILS_INTERVAL_HPP$/;"	d
UTILS_MACROS_HPP	utils/macros.hpp	/^#define UTILS_MACROS_HPP$/;"	d
UTILS_RANDOM_HPP	utils/random.hpp	/^#define UTILS_RANDOM_HPP$/;"	d
UTILS_SERIALIZATION_HPP	utils/serialization.hpp	/^#define UTILS_SERIALIZATION_HPP$/;"	d
UTILS_SIMPLE_BARRIER_HPP	utils/simple_barrier.hpp	/^#define UTILS_SIMPLE_BARRIER_HPP$/;"	d
UTILS_SPINLOCK_HPP	utils/spinlock.hpp	/^#define UTILS_SPINLOCK_HPP$/;"	d
UTILS_STACK_HPP	utils/stack.hpp	/^#define UTILS_STACK_HPP$/;"	d
UTILS_TIME_HPP	utils/time.hpp	/^#define UTILS_TIME_HPP$/;"	d
UTILS_TREE_BARRIER_HPP	utils/tree_barrier.hpp	/^#define UTILS_TREE_BARRIER_HPP$/;"	d
UTILS_TYPES_HPP	utils/types.hpp	/^#define UTILS_TYPES_HPP$/;"	d
UTILS_UTILS_HPP	utils/utils.hpp	/^#define UTILS_UTILS_HPP$/;"	d
UTIL_CSV_LINE_HPP	utils/csv_line.hpp	/^#define UTIL_CSV_LINE_HPP$/;"	d
VERSION_HPP	version.hpp	/^#define VERSION_HPP$/;"	d
VM	tests/Makefile	/^VM = ..\/meld -d -f$/;"	m
VM_ALL_HPP	vm/all.hpp	/^#define VM_ALL_HPP$/;"	d
VM_EXEC_HPP	vm/exec.hpp	/^#define VM_EXEC_HPP$/;"	d
VM_EXTERNAL_HPP	vm/external.hpp	/^#define VM_EXTERNAL_HPP$/;"	d
VM_MATCH_HPP	vm/match.hpp	/^#define VM_MATCH_HPP$/;"	d
VM_RULE_HPP	vm/rule.hpp	/^#define VM_RULE_HPP$/;"	d
VM_RULE_MATCHER_HPP	vm/rule_matcher.hpp	/^#define VM_RULE_MATCHER_HPP$/;"	d
VM_STATE_HPP	vm/state.hpp	/^#define VM_STATE_HPP$/;"	d
VM_TUPLE_HPP	vm/tuple.hpp	/^#define VM_TUPLE_HPP$/;"	d
Vector	client/springy.js	/^Vector = function(x, y) {$/;"	c
Vector.add	client/springy.js	/^Vector.prototype.add = function(v2) {$/;"	m
Vector.angle	client/springy.js	/^Vector.prototype.angle = function () {$/;"	m
Vector.divide	client/springy.js	/^Vector.prototype.divide = function(n) {$/;"	m
Vector.magnitude	client/springy.js	/^Vector.prototype.magnitude = function() {$/;"	m
Vector.multiply	client/springy.js	/^Vector.prototype.multiply = function(n) {$/;"	m
Vector.normal	client/springy.js	/^Vector.prototype.normal = function() {$/;"	m
Vector.normalise	client/springy.js	/^Vector.prototype.normalise = function() {$/;"	m
Vector.random	client/springy.js	/^Vector.random = function() {$/;"	f
Vector.subtract	client/springy.js	/^Vector.prototype.subtract = function(v2) {$/;"	m
WAIT_FOR_DONE	ui/manager.hpp	/^#define WAIT_FOR_DONE(/;"	d
WAIT_FOR_NEXT	ui/manager.hpp	/^#define WAIT_FOR_NEXT(/;"	d
WARNINGS	Makefile	/^WARNINGS = -Wall -Wextra #-Werror$/;"	m
WEST	mock-simulator/simulator.cpp	/^   WEST = 3,$/;"	e	enum:face_t	file:
WEST	sched/nodes/sim.hpp	/^   WEST = 3,$/;"	e	enum:sched::face_t
WIDTH	scripts/heat_color.py	/^WIDTH = maxx * SCALE$/;"	v
WIDTH	scripts/heat_count_color.py	/^WIDTH = maxx * SCALE$/;"	v
WIDTH	scripts/plots/active_inactive.py	/^WIDTH = min(400, 1 * timetotal)$/;"	v
WRITE_COORDS	scripts/generate_heat_grid.py	/^WRITE_COORDS = True$/;"	v
__INTRUSIVE_IN_PRIORITY_QUEUE	queue/intrusive.hpp	/^#define __INTRUSIVE_IN_PRIORITY_QUEUE(/;"	d
__INTRUSIVE_IN_QUEUE	queue/intrusive.hpp	/^#define __INTRUSIVE_IN_QUEUE(/;"	d
__INTRUSIVE_NEXT	queue/intrusive.hpp	/^#define __INTRUSIVE_NEXT(/;"	d
__INTRUSIVE_POS	queue/intrusive.hpp	/^#define __INTRUSIVE_POS(/;"	d
__INTRUSIVE_PREV	queue/intrusive.hpp	/^#define __INTRUSIVE_PREV(/;"	d
__INTRUSIVE_PRIORITY	queue/intrusive.hpp	/^#define __INTRUSIVE_PRIORITY(/;"	d
__bind	client/springy.js	/^var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; }; \/\/ stolen from coffeescript, thanks jashkenas! ;-)$/;"	f
accel_pred	sched/mpi.hpp	/^	static vm::predicate *accel_pred;$/;"	m	class:sched::mpi_sched
accel_pred	sched/sim.hpp	/^	static vm::predicate *accel_pred;$/;"	m	class:sched::sim_sched
activate_node	mock-simulator/simulator.cpp	/^activate_node(int no, int ts = 0)$/;"	f	file:
active	scripts/plots/state_totals.py	/^active = {}$/;"	v
active_nodes	mock-simulator/simulator.cpp	/^static vector<bool> active_nodes; \/\/ bitmap for active nodes$/;"	v	file:
active_rules	vm/rule_matcher.hpp	/^	set_rules active_rules; \/* rules that *may* be derivable *\/$/;"	m	class:vm::rule_matcher
active_threads	sched/thread/termination_barrier.hpp	/^   utils::atomic<size_t> active_threads;$/;"	m	class:sched::termination_barrier
add	utils/csv_line.hpp	/^   void add(const std::string& str)$/;"	f	class:utils::csv_line
add_active	scripts/plots/state_totals.py	/^def add_active(thread):$/;"	f
add_agg_tuple	db/node.cpp	/^node::add_agg_tuple(vm::tuple *tuple, const ref_count many)$/;"	f	class:db::node
add_and_fetch	utils/atomic.hpp	/^   inline T add_and_fetch(const T plus) { return __sync_add_and_fetch(&elem, plus); }$/;"	f	class:utils::atomic
add_comm	scripts/plots/state_totals.py	/^def add_comm(thread):$/;"	f
add_count	db/trie.hpp	/^   virtual inline void add_count(const vm::ref_count many) { tpl->add_count(many); }$/;"	f	class:db::tuple_trie_leaf
add_count	db/trie.hpp	/^   virtual inline void add_count(const vm::ref_count) { }$/;"	f	class:db::agg_trie_leaf
add_count	db/tuple.hpp	/^   inline void add_count(const vm::ref_count& inc) { count += inc; }$/;"	f	class:db::simple_tuple
add_delay_work	sched/nodes/sim.hpp	/^   void add_delay_work(process::work& work, const vm::uint_val milliseconds)$/;"	f	class:sched::sim_node
add_delayed_tuples	sched/nodes/sim.hpp	/^   inline void add_delayed_tuples(db::simple_tuple_list& ls)$/;"	f	class:sched::sim_node
add_fact_to_node	vm/state.cpp	/^state::add_fact_to_node(vm::tuple *tpl, vm::ref_count count)$/;"	f	class:vm::state
add_float_list	vm/state.hpp	/^   inline void add_float_list(runtime::float_list *ls) { free_float_list.push_back(ls); }$/;"	f	class:vm::state
add_generated_tuple	vm/state.hpp	/^   inline void add_generated_tuple(db::simple_tuple *tpl) { tpl->set_generated_run(true); generated_tuples.push_back(tpl); }$/;"	f	class:vm::state
add_idle	scripts/plots/state_totals.py	/^def add_idle(thread):$/;"	f
add_int_list	vm/state.hpp	/^   inline void add_int_list(runtime::int_list *ls) { free_int_list.push_back(ls); }$/;"	f	class:vm::state
add_link	scripts/generate_random_shortest_path.py	/^def add_link(src, dst):$/;"	f
add_link	scripts/generate_shortest_path.py	/^def add_link(hash, k, v):$/;"	f
add_neighbor	sched/sim.cpp	/^sim_sched::add_neighbor(const size_t ts, sim_node *no, const node_val out, const face_t face, const int count)$/;"	f	class:sched::sim_sched
add_neighbor	sched/sim_tcp.cpp	/^sim_sched::add_neighbor(const size_t ts, sim_node *no, const node_val out, const face_t face, const int count)$/;"	f	class:sched::sim_sched
add_neighbor	scripts/check_coloring.py	/^def add_neighbor(src, dst):$/;"	f
add_neighbor_count	sched/sim.cpp	/^sim_sched::add_neighbor_count(const size_t ts, sim_node *no, const size_t total, const int count)$/;"	f	class:sched::sim_sched
add_neighbor_count	sched/sim_tcp.cpp	/^sim_sched::add_neighbor_count(const size_t ts, sim_node *no, const size_t total, const int count)$/;"	f	class:sched::sim_sched
add_node_list	vm/state.hpp	/^   inline void add_node_list(runtime::node_list *ls) { free_node_list.push_back(ls); }$/;"	f	class:vm::state
add_node_priority	sched/base.hpp	/^	virtual void add_node_priority(db::node *, const double) { }$/;"	f	class:sched::base
add_node_priority_other	sched/base.hpp	/^   virtual void add_node_priority_other(db::node *, const double) { }$/;"	f	class:sched::base
add_predicate	vm/rule.hpp	/^      inline void add_predicate(predicate *p) { predicates.push_back(p); }$/;"	f	class:vm::rule
add_received_tuple	sched/sim.cpp	/^sim_sched::add_received_tuple(sim_node *no, size_t ts, db::simple_tuple *stpl)$/;"	f	class:sched::sim_sched
add_received_tuple	sched/sim_tcp.cpp	/^sim_sched::add_received_tuple(sim_node *no, size_t ts, db::simple_tuple *stpl)$/;"	f	class:sched::sim_sched
add_result	scripts/lib_csv.py	/^def add_result(name, sched, threads, result):$/;"	f
add_round	scripts/plots/state_totals.py	/^def add_round(thread):$/;"	f
add_sched	scripts/plots/state_totals.py	/^def add_sched(thread):$/;"	f
add_string	vm/state.hpp	/^	inline void add_string(runtime::rstring::ptr str) { free_rstring.push_back(str); }$/;"	f	class:vm::state
add_thread	sched/thread/threaded.hpp	/^   static inline void add_thread(sched::base *add, vm::all *all)$/;"	f	class:sched::threaded
add_to_aggregate	vm/state.cpp	/^state::add_to_aggregate(db::simple_tuple *stpl)$/;"	f	class:vm::state
add_to_set	db/agg_configuration.cpp	/^agg_configuration::add_to_set(vm::tuple *tpl, const ref_count many)$/;"	f	class:db::agg_configuration
add_to_set	db/neighbor_agg_configuration.cpp	/^neighbor_agg_configuration::add_to_set(vm::tuple *tuple, const vm::ref_count count)$/;"	f	class:db::neighbor_agg_configuration
add_to_set	db/tuple_aggregate.cpp	/^tuple_aggregate::add_to_set(vm::tuple *tpl, const ref_count many)$/;"	f	class:db::tuple_aggregate
add_tuple	db/node.cpp	/^node::add_tuple(vm::tuple *tpl, ref_count many)$/;"	f	class:db::node
add_vacant	sched/sim.cpp	/^sim_sched::add_vacant(const size_t ts, sim_node *no, const face_t face, const int count)$/;"	f	class:sched::sim_sched
add_vacant	sched/sim_tcp.cpp	/^sim_sched::add_vacant(const size_t ts, sim_node *no, const face_t face, const int count)$/;"	f	class:sched::sim_sched
add_work	sched/nodes/serial.hpp	/^   inline void add_work(db::simple_tuple *stpl)$/;"	f	class:sched::serial_node
add_work	sched/nodes/thread.hpp	/^   inline void add_work(db::simple_tuple *stpl)$/;"	f	class:sched::thread_node
add_work	sched/nodes/unsafe_static.hpp	/^   inline void add_work(process::node_work& new_work)$/;"	f	class:sched::unsafe_static_node
address	mem/allocator.hpp	/^   inline const_pointer address(const_reference r) { return &r; }$/;"	f	class:mem::allocator
address	mem/allocator.hpp	/^   inline pointer address(reference r) { return &r; }$/;"	f	class:mem::allocator
advance	queue/bounded_pqueue.hpp	/^		inline void advance(void)$/;"	f	class:queue::bounded_pqueue::const_iterator
advance	vm/instr.hpp	/^advance(pcounter pc)$/;"	f	namespace:vm::instr
affected_rules	vm/predicate.hpp	/^   std::vector<rule_id> affected_rules;$/;"	m	class:vm::predicate
agg_configuration	db/agg_configuration.hpp	/^   explicit agg_configuration(const vm::predicate *_pred):$/;"	f	class:db::agg_configuration
agg_configuration	db/agg_configuration.hpp	/^class agg_configuration: public mem::base$/;"	c	namespace:db
agg_info	vm/predicate.hpp	/^   aggregate_info *agg_info;$/;"	m	class:vm::predicate
agg_trie	db/trie.hpp	/^   explicit agg_trie(void) {}$/;"	f	class:db::agg_trie
agg_trie	db/trie.hpp	/^class agg_trie: public trie, public mem::base$/;"	c	namespace:db
agg_trie_iterator	db/trie.hpp	/^   explicit agg_trie_iterator(agg_trie_leaf *first_leaf):$/;"	f	class:db::agg_trie_iterator
agg_trie_iterator	db/trie.hpp	/^   explicit agg_trie_iterator(void): \/\/ end iterator$/;"	f	class:db::agg_trie_iterator
agg_trie_iterator	db/trie.hpp	/^class agg_trie_iterator: public mem::base$/;"	c	namespace:db
agg_trie_leaf	db/trie.hpp	/^   explicit agg_trie_leaf(agg_configuration *_conf):$/;"	f	class:db::agg_trie_leaf
agg_trie_leaf	db/trie.hpp	/^class agg_trie_leaf: public trie_leaf$/;"	c	namespace:db
aggregate_info	vm/predicate.hpp	/^   } aggregate_info;$/;"	t	class:vm::predicate	typeref:struct:vm::predicate::__anon11
aggregate_map	db/node.hpp	/^                                 tuple_aggregate*> > > aggregate_map;$/;"	t	class:db::node
aggregate_safeness	vm/types.hpp	/^enum aggregate_safeness {$/;"	g	namespace:vm
aggregate_safeness_uses_neighborhood	vm/types.hpp	/^inline bool aggregate_safeness_uses_neighborhood(const aggregate_safeness safeness)$/;"	f	namespace:vm
aggregate_type	vm/types.hpp	/^enum aggregate_type {$/;"	g	namespace:vm
aggregate_type_string	vm/types.cpp	/^aggregate_type_string(aggregate_type type)$/;"	f	namespace:vm
aggs	db/node.hpp	/^   aggregate_map aggs;$/;"	m	class:db::node
alarm_thread	process/machine.hpp	/^   boost::thread *alarm_thread;$/;"	m	class:process::machine
all	db/database.hpp	/^   vm::all *all;$/;"	m	class:db::database
all	db/node.hpp	/^   vm::all *all;$/;"	m	class:db::node
all	process/machine.hpp	/^   vm::all *all;$/;"	m	class:process::machine
all	ui/client.hpp	/^      vm::all *all;$/;"	m	class:ui::client
all	ui/manager.hpp	/^      vm::all *all;$/;"	m	class:ui::manager
all	vm/all.hpp	/^   explicit all(void) {}$/;"	f	class:vm::all
all	vm/all.hpp	/^class all$/;"	c	namespace:vm
all	vm/state.hpp	/^   vm::all *all;$/;"	m	class:vm::state
all_finished	sched/thread/termination_barrier.hpp	/^   inline bool all_finished(void) const { return done; }$/;"	f	class:sched::termination_barrier
all_instantiated	sched/mpi.hpp	/^   static bool all_instantiated;$/;"	m	class:sched::mpi_sched
all_instantiated	sched/sim.hpp	/^   static bool all_instantiated;$/;"	m	class:sched::sim_sched
all_pairs	scripts/generate_shortest_path.py	/^all_pairs = False$/;"	v
all_present	db/neighbor_agg_configuration.cpp	/^neighbor_agg_configuration::all_present(void) const$/;"	f	class:db::neighbor_agg_configuration
all_threads_finished	sched/thread/threaded.hpp	/^   inline bool all_threads_finished(void) const$/;"	f	class:sched::threaded
alllinks	scripts/generate_shortest_path.py	/^alllinks = {}$/;"	v
alloc_predicate	vm/instr.hpp	/^inline predicate_id alloc_predicate(pcounter pc) { return predicate_get(pc, 1); }$/;"	f	namespace:vm::instr
alloc_reg	vm/instr.hpp	/^inline reg_num alloc_reg(pcounter pc) { return reg_get(pc, 2); }$/;"	f	namespace:vm::instr
allocate	mem/allocator.hpp	/^   inline pointer allocate(size_type cnt,$/;"	f	class:mem::allocator
allocate	mem/center.cpp	/^center::allocate(size_t cnt, size_t sz)$/;"	f	class:mem::center
allocate	mem/chunk.hpp	/^   inline void* allocate(const size_t size)$/;"	f	class:mem::chunk
allocate	mem/chunkgroup.hpp	/^   inline void* allocate(void)$/;"	f	class:mem::chunkgroup
allocate	mem/pool.hpp	/^   inline void* allocate(const size_t size)$/;"	f	class:mem::pool
allocator	mem/allocator.hpp	/^	inline allocator(allocator const&) {}$/;"	f	class:mem::allocator
allocator	mem/allocator.hpp	/^   inline allocator(allocator<U> const&) {}$/;"	f	class:mem::allocator
allocator	mem/allocator.hpp	/^   inline explicit allocator(void) {}$/;"	f	class:mem::allocator
allocator	mem/allocator.hpp	/^class allocator$/;"	c	namespace:mem
any_exact	vm/match.hpp	/^   bool any_exact;$/;"	m	class:vm::match
arg	scripts/generate_grid.py	/^arg = sys.argv[1]$/;"	v
arg_size	vm/instr.hpp	/^STATIC_INLINE size_t arg_size<ARGUMENT_ANYTHING>(const instr_val v)$/;"	f	namespace:vm::instr
arg_size	vm/instr.hpp	/^STATIC_INLINE size_t arg_size<ARGUMENT_ANYTHING_NOT_NIL>(const instr_val v)$/;"	f	namespace:vm::instr
arg_size	vm/instr.hpp	/^STATIC_INLINE size_t arg_size<ARGUMENT_BOOL>(const instr_val v)$/;"	f	namespace:vm::instr
arg_size	vm/instr.hpp	/^STATIC_INLINE size_t arg_size<ARGUMENT_LIST>(const instr_val v)$/;"	f	namespace:vm::instr
arg_size	vm/instr.hpp	/^STATIC_INLINE size_t arg_size<ARGUMENT_NODE>(const instr_val v)$/;"	f	namespace:vm::instr
arg_size	vm/instr.hpp	/^STATIC_INLINE size_t arg_size<ARGUMENT_NON_LIST>(const instr_val v)$/;"	f	namespace:vm::instr
arg_size	vm/instr.hpp	/^STATIC_INLINE size_t arg_size<ARGUMENT_WRITABLE>(const instr_val v)$/;"	f	namespace:vm::instr
arg_size	vm/instr.hpp	/^size_t arg_size<ARGUMENT_INT>(const instr_val v)$/;"	f	namespace:vm::instr
args	scripts/check_coloring.py	/^			args = d['args']$/;"	v
argument	vm/external.hpp	/^typedef tuple_field argument;$/;"	t	namespace:vm
argument_id	vm/defs.hpp	/^typedef size_t argument_id;$/;"	t	namespace:vm
argument_size	vm/instr.hpp	/^const size_t argument_size = 1;$/;"	m	namespace:vm::instr
as_persistent	vm/rule.hpp	/^      inline bool as_persistent(void) const { return is_persistent; }$/;"	f	class:vm::rule
assert_end	db/node.cpp	/^node::assert_end(void) const$/;"	f	class:db::node
assert_end	sched/nodes/in_queue.hpp	/^   virtual void assert_end(void) const$/;"	f	class:sched::in_queue_node
assert_end	sched/nodes/serial.hpp	/^   virtual void assert_end(void) const$/;"	f	class:sched::serial_node
assert_end	sched/nodes/sim.hpp	/^   virtual void assert_end(void) const$/;"	f	class:sched::sim_node
assert_end	sched/nodes/thread.hpp	/^   virtual void assert_end(void) const$/;"	f	class:sched::thread_node
assert_end	sched/nodes/unsafe_static.hpp	/^   virtual void assert_end(void) const$/;"	f	class:sched::unsafe_static_node
assert_end	sched/serial.cpp	/^serial_local::assert_end(void) const$/;"	f	class:sched::serial_local
assert_end	sched/sim.cpp	/^sim_sched::assert_end(void) const$/;"	f	class:sched::sim_sched
assert_end	sched/sim_tcp.cpp	/^sim_sched::assert_end(void) const$/;"	f	class:sched::sim_sched
assert_end_iteration	db/node.hpp	/^   virtual void assert_end_iteration(void) const {}$/;"	f	class:db::node
assert_end_iteration	sched/nodes/in_queue.hpp	/^   virtual void assert_end_iteration(void) const$/;"	f	class:sched::in_queue_node
assert_end_iteration	sched/nodes/serial.hpp	/^   virtual void assert_end_iteration(void) const$/;"	f	class:sched::serial_node
assert_end_iteration	sched/nodes/sim.hpp	/^   virtual void assert_end_iteration(void) const$/;"	f	class:sched::sim_node
assert_end_iteration	sched/nodes/thread.hpp	/^   virtual void assert_end_iteration(void) const$/;"	f	class:sched::thread_node
assert_end_iteration	sched/nodes/unsafe_static.hpp	/^   virtual void assert_end_iteration(void) const$/;"	f	class:sched::unsafe_static_node
assert_end_iteration	sched/serial.cpp	/^serial_local::assert_end_iteration(void) const$/;"	f	class:sched::serial_local
assert_end_iteration	sched/sim.cpp	/^sim_sched::assert_end_iteration(void) const$/;"	f	class:sched::sim_sched
assert_end_iteration	sched/sim_tcp.cpp	/^sim_sched::assert_end_iteration(void) const$/;"	f	class:sched::sim_sched
assert_heap	queue/safe_complex_pqueue.hpp	/^	void assert_heap(void)$/;"	f	class:queue::intrusive_safe_complex_pqueue
assert_static_nodes_end	sched/common.cpp	/^assert_static_nodes_end(const process_id id, vm::all *all)$/;"	f	namespace:sched
assert_static_nodes_end	sched/common.hpp	/^inline void assert_static_nodes_end(const vm::process_id, vm::all *) {}$/;"	f	namespace:sched
assert_static_nodes_end_iteration	sched/common.cpp	/^assert_static_nodes_end_iteration(const process_id id, vm::all *all)$/;"	f	namespace:sched
assert_static_nodes_end_iteration	sched/common.hpp	/^inline void assert_static_nodes_end_iteration(const vm::process_id, vm::all *) {}$/;"	f	namespace:sched
assert_thread_disable_work_count	sched/thread/assert.cpp	/^assert_thread_disable_work_count(void)$/;"	f	namespace:sched
assert_thread_end_iteration	sched/thread/assert.cpp	/^assert_thread_end_iteration(void)$/;"	f	namespace:sched
assert_thread_iteration	sched/thread/assert.cpp	/^assert_thread_iteration(const size_t iteration)$/;"	f	namespace:sched
assert_thread_pop_work	sched/thread/assert.cpp	/^assert_thread_pop_work(void)$/;"	f	namespace:sched
assert_thread_push_work	sched/thread/assert.cpp	/^assert_thread_push_work(void)$/;"	f	namespace:sched
atomic	utils/atomic.hpp	/^   atomic(const T _elem): elem(_elem) {}$/;"	f	class:utils::atomic
atomic	utils/atomic.hpp	/^class atomic$/;"	c	namespace:utils
atomic_ref	utils/atomic.hpp	/^   atomic_ref(T _ref): ref(_ref) {}$/;"	f	class:utils::atomic_ref
atomic_ref	utils/atomic.hpp	/^class atomic_ref$/;"	c	namespace:utils
barrier	utils/simple_barrier.hpp	/^   explicit barrier(const size_t x):$/;"	f	class:utils::simple_barrier
base	mem/base.hpp	/^class base$/;"	c	namespace:mem
base	sched/base.cpp	/^base::base(const vm::process_id _id, vm::all *_all):$/;"	f	class:sched::base
base	sched/base.hpp	/^class base$/;"	c	namespace:sched
base	scripts/generate_heat_chain.py	/^	base = float(nodes) * float(nodes)$/;"	v
basic_invariants	db/trie.hpp	/^   inline void basic_invariants(void)$/;"	f	class:db::trie
beat	stat/slice_set.cpp	/^slice_set::beat(vm::all *all)$/;"	f	class:statistics::slice_set
beat_thread	stat/slice_set.cpp	/^slice_set::beat_thread(const process_id id, slice& sl, vm::all *all)$/;"	f	class:statistics::slice_set
before	utils/time.hpp	/^   boost::posix_time::ptime before;$/;"	m	class:utils::execution_time
begin	db/trie.hpp	/^   inline const_iterator begin(void) const { return iterator((agg_trie_leaf*)first_leaf); }$/;"	f	class:db::agg_trie
begin	db/trie.hpp	/^   inline const_iterator begin(void) const { return iterator((tuple_trie_leaf*)first_leaf); }$/;"	f	class:db::tuple_trie
begin	db/trie.hpp	/^   inline iterator begin(void) { return iterator((agg_trie_leaf*)first_leaf); }$/;"	f	class:db::agg_trie
begin	db/trie.hpp	/^   inline iterator begin(void) { return iterator((tuple_trie_leaf*)first_leaf); }$/;"	f	class:db::tuple_trie
begin	queue/bounded_pqueue.hpp	/^	inline const_iterator begin(void) const { return const_iterator(leaves); }$/;"	f	class:queue::bounded_pqueue
begin	queue/safe_linear_queue.hpp	/^	inline const_iterator begin(void) const$/;"	f	class:queue::push_safe_linear_queue
begin	queue/safe_simple_pqueue.hpp	/^	inline const_iterator begin(void) const$/;"	f	class:queue::heap_queue
begin	sched/nodes/serial.hpp	/^	inline queue_iterator begin(void) const { return queue.begin(); }$/;"	f	class:sched::serial_node
begin_active_rules	vm/rule_matcher.hpp	/^	rule_iterator begin_active_rules(void) const { return active_rules.begin(); }$/;"	f	class:vm::rule_matcher
begin_dropped_rules	vm/rule_matcher.hpp	/^	rule_iterator begin_dropped_rules(void) const { return dropped_rules.begin(); }$/;"	f	class:vm::rule_matcher
begin_predicates	vm/rule.hpp	/^		inline predicate_iterator begin_predicates(void) const { return predicates.begin(); }$/;"	f	class:vm::rule
begin_rules	vm/predicate.hpp	/^   inline rule_iterator begin_rules(void) const$/;"	f	class:vm::predicate
between	utils/interval.hpp	/^   const bool between(const T& val) const$/;"	f	class:utils::interval
bias_hidden	scripts/generate_neural_network.py	/^bias_hidden = str(HIDDEN_BASE + num_hidden)$/;"	v
bias_input	scripts/generate_neural_network.py	/^bias_input = str(INPUT_BASE + num_input)$/;"	v
bin	queue/bounded_pqueue.hpp	/^   C bin;$/;"	m	class:queue::queue_tree_node
bool_val	vm/defs.hpp	/^typedef bool bool_val;$/;"	t	namespace:vm
bottom	mem/chunk.hpp	/^   unsigned char *bottom;$/;"	m	class:mem::chunk
bottom	sched/nodes/sim.hpp	/^   vm::node_val bottom;$/;"	m	class:sched::sim_node
bottom_neighbors	mock-simulator/simulator.cpp	/^static vector<int> top_neighbors, bottom_neighbors;$/;"	v	file:
bounded_pqueue	queue/bounded_pqueue.hpp	/^   explicit bounded_pqueue(const size_t _range):$/;"	f	class:queue::bounded_pqueue
bounded_pqueue	queue/bounded_pqueue.hpp	/^class bounded_pqueue$/;"	c	namespace:queue
bucket	db/trie.hpp	/^   trie_node **bucket;$/;"	m	class:db::trie_node
buckets	db/trie.hpp	/^   trie_node **buckets;$/;"	m	class:db::trie_hash
build	utils/tree_barrier.hpp	/^   bool build(inner_node *parent, const size_t depth)$/;"	f	class:utils::tree_barrier
build_aggregate_info	vm/predicate.cpp	/^predicate::build_aggregate_info(vm::program *prog)$/;"	f	class:vm::predicate
build_cool_name	scripts/plots/dir_plot_base.sh	/^build_cool_name ()$/;"	f
build_field_info	vm/predicate.cpp	/^predicate::build_field_info(void)$/;"	f	class:vm::predicate
build_match_object	vm/exec.cpp	/^build_match_object(match& m, pcounter pc, state& state, const predicate *pred)$/;"	f	namespace:vm
build_results	scripts/lib_csv.py	/^def build_results(vec):$/;"	f
build_tree	queue/bounded_pqueue.hpp	/^   tree_node* build_tree(const size_t height, const size_t prio)$/;"	f	class:queue::bounded_pqueue
byte	utils/types.hpp	/^typedef unsigned char byte;$/;"	t	namespace:utils
byte_code	vm/defs.hpp	/^typedef byte_code_el* byte_code;$/;"	t	namespace:vm
byte_code_el	vm/defs.hpp	/^typedef unsigned char byte_code_el;$/;"	t	namespace:vm
byte_get	vm/instr.hpp	/^inline utils::byte byte_get(pcounter x, size_t off) { return *(utils::byte*)(x + off); }$/;"	f	namespace:vm::instr
cache_info	vm/predicate.cpp	/^predicate::cache_info(vm::program *prog)$/;"	f	class:vm::predicate
cairo	scripts/heat_color.py	/^import cairo$/;"	i
cairo	scripts/heat_count_color.py	/^import cairo$/;"	i
cairo	scripts/plots/active_inactive.py	/^import cairo$/;"	i
call_dest	vm/instr.hpp	/^inline reg_num call_dest(pcounter pc) { return reg_get(pc, 3); }$/;"	f	namespace:vm::instr
call_extern_id	vm/instr.hpp	/^inline external_function_id call_extern_id(pcounter pc) { return (external_function_id)byte_get(pc, 1); }$/;"	f	namespace:vm::instr
call_num_args	vm/instr.hpp	/^inline size_t call_num_args(pcounter pc) { return (size_t)byte_get(pc, 2); }$/;"	f	namespace:vm::instr
call_val	vm/instr.hpp	/^inline instr_val call_val(pcounter pc) { return val_get(pc, 0); }$/;"	f	namespace:vm::instr
can_be_consumed	db/tuple.hpp	/^   inline bool can_be_consumed(void) const$/;"	f	class:db::simple_tuple
center	mem/center.hpp	/^class center$/;"	c	namespace:mem
changed	db/agg_configuration.hpp	/^   bool changed;$/;"	m	class:db::agg_configuration
check_delayed_queue	sched/sim.cpp	/^sim_sched::check_delayed_queue(void)$/;"	f	class:sched::sim_sched
check_delayed_queue	sched/sim_tcp.cpp	/^sim_sched::check_delayed_queue(void)$/;"	f	class:sched::sim_sched
check_if_rule_predicate_activated	vm/state.cpp	/^state::check_if_rule_predicate_activated(vm::rule *rule)$/;"	f	class:vm::state
check_insert	db/trie.cpp	/^trie::check_insert(void *data, const ref_count many, val_stack& vals, type_stack& typs, bool& found)$/;"	f	class:db::trie
check_insert	db/trie.cpp	/^tuple_trie::check_insert(vm::tuple *tpl, const ref_count many, bool& found)$/;"	f	class:db::tuple_trie
checked	scripts/check_coloring.py	/^			checked = True$/;"	v
checked	scripts/check_coloring.py	/^	checked = False$/;"	v
child	db/trie.hpp	/^   trie_node *child;$/;"	m	class:db::trie_node
children_count	utils/tree_barrier.hpp	/^      utils::atomic<size_t> children_count;$/;"	m	class:utils::tree_barrier::inner_node
chunk	mem/chunk.hpp	/^   explicit chunk(const size_t size, const size_t num_elems):$/;"	f	class:mem::chunk
chunk	mem/chunk.hpp	/^class chunk$/;"	c	namespace:mem
chunk_map	mem/pool.hpp	/^   typedef std::tr1::unordered_map<size_t, chunkgroup*> chunk_map;$/;"	t	class:mem::pool
chunkgroup	mem/chunkgroup.hpp	/^   explicit chunkgroup(const size_t _size):$/;"	f	class:mem::chunkgroup
chunkgroup	mem/chunkgroup.hpp	/^class chunkgroup$/;"	c	namespace:mem
chunks	mem/pool.hpp	/^   chunk_map chunks;$/;"	m	class:mem::pool
cleanup	mem/thread.cpp	/^cleanup(const size_t num_threads)$/;"	f	namespace:mem
cleanup	ui/manager.cpp	/^manager::cleanup(void)$/;"	f	class:ui::manager
cleanup	vm/state.cpp	/^state::cleanup(void)$/;"	f	class:vm::state
cleanup_externals	vm/external.cpp	/^cleanup_externals(void)$/;"	f	namespace:vm
cleanup_keys	ui/manager.cpp	/^cleanup_keys(void)$/;"	f	namespace:ui
cleanup_list	ui/manager.hpp	/^      std::vector<client*> cleanup_list;$/;"	m	class:ui::manager
cleanup_memsystem	mem/thread.cpp	/^cleanup_memsystem(void)$/;"	f	namespace:mem
cleanup_sched_key	sched/base.cpp	/^cleanup_sched_key(void)$/;"	f	namespace:sched
clear	queue/safe_simple_pqueue.hpp	/^   void clear(void)$/;"	f	class:queue::heap_queue
clear	queue/simple_linear_pqueue.hpp	/^   void clear(void)$/;"	f	class:queue::simple_linear_pqueue
clear	queue/unsafe_linear_queue.hpp	/^   inline void clear(void)$/;"	f	class:queue::unsafe_linear_queue
clear	queue/unsafe_linear_queue.hpp	/^   inline void clear(void)$/;"	f	class:queue::unsafe_linear_queue_count
clear	sched/thread/steal_set.hpp	/^   inline void clear(void)$/;"	f	class:sched::steal_set
clear_dropped_rules	vm/rule_matcher.hpp	/^	void clear_dropped_rules(void)$/;"	f	class:vm::rule_matcher
cliaddr	mock-simulator/simulator.cpp	/^static struct sockaddr_in servaddr, cliaddr;$/;"	v	typeref:struct:	file:
client	ui/client.cpp	/^client::client(connection_ptr _conn):$/;"	f	class:ui::client
client	ui/client.hpp	/^class client$/;"	c	namespace:ui
client_key	ui/manager.cpp	/^static pthread_key_t client_key;$/;"	m	namespace:ui	file:
client_list	ui/manager.hpp	/^      typedef std::map<connection_ptr, client *> client_list;$/;"	t	class:ui::manager
client_mtx	ui/manager.hpp	/^      mutable boost::mutex client_mtx;$/;"	m	class:ui::manager
clients	ui/manager.hpp	/^      client_list clients;$/;"	m	class:ui::manager
clients_served	ui/manager.hpp	/^      utils::atomic<size_t> clients_served;$/;"	m	class:ui::manager
clilen	mock-simulator/simulator.cpp	/^static socklen_t clilen;$/;"	v	file:
cnt	utils/simple_barrier.hpp	/^   utils::atomic<size_t> cnt;$/;"	m	class:utils::simple_barrier
code	vm/program.hpp	/^   std::vector<byte_code> code;$/;"	m	class:vm::program
code	vm/rule.hpp	/^      byte_code code;$/;"	m	class:vm::rule
code_offset_t	vm/defs.hpp	/^typedef code_size_t code_offset_t;$/;"	t	namespace:vm
code_size	vm/program.hpp	/^   std::vector<code_size_t> code_size;$/;"	m	class:vm::program
code_size	vm/rule.hpp	/^		code_size_t code_size;$/;"	m	class:vm::rule
code_size_t	vm/defs.hpp	/^typedef uint32_t code_size_t;$/;"	t	namespace:vm
colocated_dest	vm/instr.hpp	/^inline reg_num colocated_dest(const pcounter pc) { return reg_get(pc, 3); }$/;"	f	namespace:vm::instr
colocated_first	vm/instr.hpp	/^inline instr_val colocated_first(const pcounter pc) { return val_get(pc, 1); }$/;"	f	namespace:vm::instr
colocated_second	vm/instr.hpp	/^inline instr_val colocated_second(const pcounter pc) { return val_get(pc, 2); }$/;"	f	namespace:vm::instr
color	scripts/check_coloring.py	/^			color = int(args[0])$/;"	v
colors	scripts/check_coloring.py	/^colors = {}$/;"	v
comm	scripts/plots/state_totals.py	/^comm = {}$/;"	v
command_args	server.cpp	/^static vector<string> command_args;$/;"	v	file:
command_type	server.cpp	/^} command_type;$/;"	t	typeref:enum:__anon5	file:
commit_delete	db/trie.cpp	/^trie::commit_delete(trie_node *node, ref_count many)$/;"	f	class:db::trie
compare_and_set	utils/atomic.hpp	/^   inline T compare_and_set(T comp, T new_val)$/;"	f	class:utils::atomic_ref
compare_test_set	utils/atomic.hpp	/^   inline bool compare_test_set(T comp, T new_val)$/;"	f	class:utils::atomic_ref
conf	db/trie.hpp	/^   agg_configuration *conf;$/;"	m	class:db::agg_trie_leaf
conn	ui/client.hpp	/^      connection_ptr conn;$/;"	m	class:ui::client
connection_ptr	ui/client.hpp	/^      typedef websocketpp::server::connection_ptr connection_ptr;$/;"	t	class:ui::client
connection_ptr	ui/manager.hpp	/^      typedef websocketpp::server::connection_ptr connection_ptr;$/;"	t	class:ui::manager
connfd	mock-simulator/simulator.cpp	/^static int listenfd, connfd;$/;"	v	file:
cons	runtime/list.hpp	/^   explicit cons(list_ptr _tail, const T _head):$/;"	f	class:runtime::cons
cons	runtime/list.hpp	/^class cons: public mem::base$/;"	c	namespace:runtime
cons_dest	vm/instr.hpp	/^inline instr_val cons_dest(pcounter pc) { return val_get(pc, 4); }$/;"	f	namespace:vm::instr
cons_head	vm/instr.hpp	/^inline instr_val cons_head(pcounter pc) { return val_get(pc, 2); }$/;"	f	namespace:vm::instr
cons_tail	vm/instr.hpp	/^inline instr_val cons_tail(pcounter pc) { return val_get(pc, 3); }$/;"	f	namespace:vm::instr
cons_type	vm/instr.hpp	/^inline field_type cons_type(pcounter pc) { return get_list_type(pc, 1); }$/;"	f	namespace:vm::instr
const_code	vm/program.hpp	/^	byte_code const_code;$/;"	m	class:vm::program
const_code_size	vm/program.hpp	/^	code_size_t const_code_size;$/;"	m	class:vm::program
const_id	vm/defs.hpp	/^typedef uint_val const_id;$/;"	t	namespace:vm
const_iterator	db/agg_configuration.hpp	/^   typedef tuple_trie::const_iterator const_iterator;$/;"	t	class:db::agg_configuration
const_iterator	db/trie.hpp	/^   typedef agg_trie_iterator const_iterator;$/;"	t	class:db::agg_trie
const_iterator	db/trie.hpp	/^   typedef tuple_trie_iterator const_iterator;$/;"	t	class:db::tuple_trie
const_iterator	queue/bounded_pqueue.hpp	/^		explicit const_iterator(): is_end(true) {}$/;"	f	class:queue::bounded_pqueue::const_iterator
const_iterator	queue/bounded_pqueue.hpp	/^		explicit const_iterator(const leaves_vector& v):$/;"	f	class:queue::bounded_pqueue::const_iterator
const_iterator	queue/bounded_pqueue.hpp	/^	class const_iterator$/;"	c	class:queue::bounded_pqueue
const_iterator	queue/safe_simple_pqueue.hpp	/^		explicit const_iterator(const heap_vector* v): cur_pos(0), end(false), vec(v) {}$/;"	f	class:queue::heap_queue::const_iterator
const_iterator	queue/safe_simple_pqueue.hpp	/^		explicit const_iterator(void): end(true), vec(NULL)$/;"	f	class:queue::heap_queue::const_iterator
const_iterator	queue/safe_simple_pqueue.hpp	/^	class const_iterator$/;"	c	class:queue::heap_queue
const_pointer	mem/allocator.hpp	/^   typedef const value_type* const_pointer;$/;"	t	class:mem::allocator
const_reference	mem/allocator.hpp	/^   typedef const value_type& const_reference;$/;"	t	class:mem::allocator
const_types	vm/program.hpp	/^	std::vector<field_type> const_types;$/;"	m	class:vm::program
construct	mem/allocator.hpp	/^   inline void construct(pointer p, const T& t) { new (p) T(t); }$/;"	f	class:mem::allocator
consts	vm/all.hpp	/^	tuple_field consts[MAX_CONSTS];$/;"	m	class:vm::all
container_type	utils/stack.hpp	/^   typedef std::vector<T, mem::allocator<T> > container_type;$/;"	t	class:utils::stack
content	runtime/string.hpp	/^	const std::string content;$/;"	m	class:runtime::rstring
continuation_frame	db/trie.cpp	/^struct continuation_frame {$/;"	s	namespace:db	file:
continuation_stack	db/trie.cpp	/^typedef utils::stack<continuation_frame> continuation_stack;$/;"	t	namespace:db	file:
convert_hash	db/trie.cpp	/^trie_node::convert_hash(const field_type& type)$/;"	f	class:db::trie_node
coord	scripts/heat_color.py	/^	coord = read_coord(data)$/;"	v
coord	scripts/heat_count_color.py	/^	coord = read_coord(data)$/;"	v
coords	scripts/heat_color.py	/^coords = {}$/;"	v
coords	scripts/heat_count_color.py	/^coords = {}$/;"	v
copy	runtime/list.hpp	/^   list_ptr copy(list_ptr ptr)$/;"	f	class:runtime::cons
copy	vm/tuple.cpp	/^tuple::copy(void) const$/;"	f	class:vm::tuple
copy_except	vm/tuple.cpp	/^tuple::copy_except(const field_num field) const$/;"	f	class:vm::tuple
copy_field	vm/tuple.cpp	/^tuple::copy_field(tuple *ret, const field_num i) const$/;"	f	class:vm::tuple
copy_from_node	process/work.hpp	/^   void copy_from_node(db::node *_node, node_work& w)$/;"	f	class:process::work
copy_reg	vm/state.hpp	/^   inline void copy_reg(const reg_num& reg_from, const reg_num& reg_to) {$/;"	f	class:vm::state
copy_reg2const	vm/state.cpp	/^state::copy_reg2const(const reg_num& reg_from, const const_id& cid)$/;"	f	class:vm::state
corresponds	db/agg_configuration.hpp	/^   vm::tuple *corresponds;$/;"	m	class:db::agg_configuration
count	db/tuple.hpp	/^   vm::ref_count count;$/;"	m	class:db::simple_tuple
count	scripts/generate_neural_network.py	/^   count = count + 1$/;"	v
count	scripts/generate_neural_network.py	/^count = 0$/;"	v
count	scripts/heat_count_color.py	/^	count = counts[node]$/;"	v
count	utils/tree_barrier.hpp	/^      size_t count;$/;"	m	class:utils::tree_barrier::inner_node
count	vm/state.hpp	/^   ref_count count;$/;"	m	class:vm::state
count_number_words	external/others.cpp	/^count_number_words(ifstream& fp)$/;"	f	namespace:vm::external
count_refs	db/trie.cpp	/^trie_hash::count_refs(void) const$/;"	f	class:db::trie_hash
count_refs	db/trie.cpp	/^trie_node::count_refs(void) const$/;"	f	class:db::trie_node
count_total	db/node.cpp	/^node::count_total(const predicate_id id) const$/;"	f	class:db::node
counter	queue/bounded_pqueue.hpp	/^   A counter;$/;"	m	class:queue::queue_tree_node
counter	scripts/lib.py	/^counter = 0$/;"	v
counter	ui/client.hpp	/^      utils::atomic<int> counter;$/;"	m	class:ui::client
counts	scripts/heat_count_color.py	/^counts = {}$/;"	v
create_configuration	db/neighbor_tuple_aggregate.cpp	/^neighbor_tuple_aggregate::create_configuration(void) const$/;"	f	class:db::neighbor_tuple_aggregate
create_configuration	db/tuple_aggregate.cpp	/^tuple_aggregate::create_configuration(void) const$/;"	f	class:db::tuple_aggregate
create_fn	db/database.hpp	/^   create_node_fn create_fn;$/;"	m	class:db::database
create_leaf	db/trie.hpp	/^   virtual trie_leaf* create_leaf(void *, const vm::ref_count)$/;"	f	class:db::agg_trie
create_leaf	db/trie.hpp	/^   virtual trie_leaf* create_leaf(void *data, const vm::ref_count many)$/;"	f	class:db::tuple_trie
create_new	db/tuple.hpp	/^   static simple_tuple* create_new(vm::tuple *tuple) { return new simple_tuple(tuple, 1); }$/;"	f	class:db::simple_tuple
create_node	db/database.cpp	/^database::create_node(void)$/;"	f	class:database
create_node	sched/mpi.hpp	/^   static db::node* create_node(const db::node::node_id id, const db::node::node_id trans, vm::all *all)$/;"	f	class:sched::mpi_sched
create_node	sched/serial.hpp	/^   static db::node* create_node(const db::node::node_id id, const db::node::node_id trans, vm::all *all)$/;"	f	class:sched::serial_local
create_node	sched/sim.hpp	/^   static db::node* create_node(const db::node::node_id id, const db::node::node_id trans, vm::all *all)$/;"	f	class:sched::sim_sched
create_node_fn	db/database.hpp	/^   typedef boost::function3<node*, node::node_id, node::node_id, vm::all *> create_node_fn;$/;"	t	class:db::database
create_node_id	db/database.cpp	/^database::create_node_id(const db::node::node_id id)$/;"	f	class:database
create_pool	mem/thread.cpp	/^create_pool(void)$/;"	f	namespace:mem
csv	scripts/csv_benchmarks.py	/^import csv$/;"	i
csv	scripts/csv_step.py	/^import csv$/;"	i
csv	scripts/duplicate_neural_network.py	/^import csv$/;"	i
csv	scripts/generate_neural_network.py	/^import csv$/;"	i
csv	scripts/plots/state_totals.py	/^import csv$/;"	i
csv	scripts/transform_letter_data.py	/^import csv$/;"	i
csv_line	utils/csv_line.hpp	/^   explicit csv_line(void): is_header(false) {}$/;"	f	class:utils::csv_line
csv_line	utils/csv_line.hpp	/^class csv_line$/;"	c	namespace:utils
ctx	scripts/heat_color.py	/^ctx = cairo.Context(surface)$/;"	v
ctx	scripts/heat_count_color.py	/^ctx = cairo.Context(surface)$/;"	v
ctx	scripts/plots/active_inactive.py	/^ctx = cairo.Context(surface)$/;"	v
cunits	ui/client.hpp	/^      utils::atomic<size_t> cunits;$/;"	m	class:ui::client
cur	mem/chunk.hpp	/^   unsigned char *cur;$/;"	m	class:mem::chunk
cur_pos	queue/bounded_pqueue.hpp	/^		size_t cur_pos;$/;"	m	class:queue::bounded_pqueue::const_iterator
cur_pos	queue/safe_simple_pqueue.hpp	/^		size_t cur_pos;$/;"	m	class:queue::heap_queue::const_iterator
current_id	vm/predicate.hpp	/^   static predicate_id current_id;$/;"	m	class:vm::predicate
current_leaf	db/trie.hpp	/^   agg_trie_leaf *current_leaf;$/;"	m	class:db::agg_trie_iterator
current_leaf	db/trie.hpp	/^   tuple_trie_leaf *current_leaf;$/;"	m	class:db::tuple_trie_iterator
current_level	vm/state.hpp	/^	vm::strat_level current_level;$/;"	m	class:vm::state
current_node	sched/mpi.hpp	/^	sim_node *current_node;$/;"	m	class:sched::mpi_sched
current_node	sched/serial.hpp	/^	serial_node *current_node;$/;"	m	class:sched::serial_local
current_node	sched/sim.hpp	/^	sim_node *current_node;$/;"	m	class:sched::sim_sched
current_rule	vm/state.hpp	/^   size_t current_rule;$/;"	m	class:vm::state
currentwidth	scripts/plots/active_inactive.py	/^	currentwidth = endwidth$/;"	v
currentwidth	scripts/plots/active_inactive.py	/^currentwidth = widthgap \/ 2.0$/;"	v
data	db/trie.hpp	/^   vm::tuple_field data;$/;"	m	class:db::trie_node
data	db/tuple.hpp	/^   vm::tuple *data;$/;"	m	class:db::simple_tuple
data	queue/node.hpp	/^   T data;$/;"	m	class:queue::queue_node
data	queue/node.hpp	/^   T data;$/;"	m	class:queue::unsafe_queue_node
data	queue/safe_general_pqueue.hpp	/^   std::priority_queue<queue_item, std::vector<queue_item>, queue_item_comparator> data;$/;"	m	class:queue::general_pqueue
data	queue/safe_linear_queue.hpp	/^   T data;$/;"	m	class:queue::special_queue_node
data	queue/safe_simple_pqueue.hpp	/^		T data;$/;"	m	class:queue::heap_queue::heap_object
data	scripts/lib_csv.py	/^data = {}$/;"	v
data	utils/csv_line.hpp	/^   std::vector<std::string> data;$/;"	m	class:utils::csv_line
data	utils/spinlock.hpp	/^   volatile unsigned int data;$/;"	m	class:utils::spinlock
database	db/database.cpp	/^database::database(const string& filename, create_node_fn _create_fn, vm::all *_all):$/;"	f	class:db::database
database	db/database.hpp	/^class database$/;"	c	namespace:db
database_error	db/database.hpp	/^    explicit database_error(const std::string& msg) :$/;"	f	class:db::database_error
database_error	db/database.hpp	/^class database_error : public std::runtime_error {$/;"	c	namespace:db
db	db/agg_configuration.cpp	/^namespace db$/;"	n	file:
db	db/agg_configuration.hpp	/^namespace db$/;"	n
db	db/database.cpp	/^namespace db$/;"	n	file:
db	db/database.hpp	/^namespace db$/;"	n
db	db/edge_set.hpp	/^namespace db$/;"	n
db	db/neighbor_agg_configuration.cpp	/^namespace db$/;"	n	file:
db	db/neighbor_agg_configuration.hpp	/^namespace db$/;"	n
db	db/neighbor_tuple_aggregate.cpp	/^namespace db$/;"	n	file:
db	db/neighbor_tuple_aggregate.hpp	/^namespace db$/;"	n
db	db/node.cpp	/^namespace db$/;"	n	file:
db	db/node.hpp	/^namespace db {$/;"	n
db	db/trie.cpp	/^namespace db$/;"	n	file:
db	db/trie.hpp	/^namespace db$/;"	n
db	db/tuple.cpp	/^namespace db$/;"	n	file:
db	db/tuple.hpp	/^namespace db$/;"	n
db	db/tuple_aggregate.cpp	/^namespace db$/;"	n	file:
db	db/tuple_aggregate.hpp	/^namespace db$/;"	n
db	scripts/check_coloring.py	/^db = read_db(sys.stdin.readlines())$/;"	v
db	scripts/count_db_total.py	/^db = read_db(sys.stdin.readlines())$/;"	v
db	scripts/heat_color.py	/^db = read_db(sys.stdin.readlines())$/;"	v
db	scripts/heat_count_color.py	/^db = read_db(sys.stdin.readlines())$/;"	v
db	ui/manager.hpp	/^namespace db$/;"	n
db	vm/all.hpp	/^namespace db {$/;"	n
deactivate_signals	process/machine.cpp	/^machine::deactivate_signals(void)$/;"	f	class:process::machine
deallocate	mem/allocator.hpp	/^   inline void deallocate(pointer p, size_type cnt)$/;"	f	class:mem::allocator
deallocate	mem/center.cpp	/^center::deallocate(void *p, size_t cnt, size_t sz)$/;"	f	class:mem::center
deallocate	mem/chunkgroup.hpp	/^   inline void deallocate(void* ptr)$/;"	f	class:mem::chunkgroup
deallocate	mem/pool.hpp	/^   inline void deallocate(void *ptr, const size_t size)$/;"	f	class:mem::pool
debug	queue/safe_complex_pqueue.hpp	/^   static const bool debug = false;$/;"	m	class:queue::intrusive_safe_complex_pqueue
debug_file_name	stat/stat.cpp	/^static string debug_file_name;$/;"	m	namespace:statistics	file:
dec_count	db/tuple.hpp	/^   inline void dec_count(const vm::ref_count& inc) { assert(inc > 0); count -= inc; }$/;"	f	class:db::simple_tuple
dec_neighbor_count	sched/nodes/sim.hpp	/^   inline void dec_neighbor_count(void)$/;"	f	class:sched::sim_node
dec_refs	runtime/list.hpp	/^   inline void dec_refs(void)$/;"	f	class:runtime::cons
dec_refs	runtime/list.hpp	/^   static inline void dec_refs(list_ptr ls)$/;"	f	class:runtime::cons
dec_refs	runtime/string.hpp	/^	inline void dec_refs(void)$/;"	f	class:runtime::rstring
default_strings	vm/program.hpp	/^	string_store default_strings;$/;"	m	class:vm::program
define_get	vm/state.hpp	/^#define define_get(/;"	d
define_get	vm/state.hpp	/^#undef define_get$/;"	d
define_get	vm/tuple.hpp	/^#define define_get(/;"	d
define_get	vm/tuple.hpp	/^#undef define_get$/;"	d
define_get_const	vm/all.hpp	/^#define define_get_const(/;"	d
define_get_const	vm/all.hpp	/^#undef define_get_const$/;"	d
define_set	vm/state.hpp	/^#define define_set(/;"	d
define_set	vm/state.hpp	/^#undef define_set$/;"	d
define_set	vm/tuple.hpp	/^#define define_set(/;"	d
define_set	vm/tuple.hpp	/^#undef define_set$/;"	d
define_set_const	vm/all.hpp	/^#define define_set_const(/;"	d
define_set_const	vm/all.hpp	/^#undef define_set_const$/;"	d
delay_mtx	queue/safe_general_pqueue.hpp	/^   mutable boost::mutex delay_mtx;$/;"	m	class:queue::general_pqueue
delay_queue	sched/mpi.hpp	/^   queue::general_pqueue<work_info, utils::unix_timestamp> delay_queue;$/;"	m	class:sched::mpi_sched
delay_queue	sched/nodes/sim.hpp	/^   queue::general_pqueue<process::work, utils::unix_timestamp> delay_queue;$/;"	m	class:sched::sim_node
delay_queue	sched/sim.hpp	/^   queue::general_pqueue<work_info, utils::unix_timestamp> delay_queue;$/;"	m	class:sched::sim_sched
delayed_available	sched/nodes/sim.hpp	/^   inline bool delayed_available(void) const$/;"	f	class:sched::sim_node
delete_all	db/node.cpp	/^node::delete_all(const predicate*)$/;"	f	class:db::node
delete_all	queue/bounded_pqueue.hpp	/^   void delete_all(void)$/;"	f	class:queue::queue_tree_node
delete_branch	db/trie.cpp	/^trie::delete_branch(trie_node *node)$/;"	f	class:db::trie
delete_by_index	db/node.cpp	/^node::delete_by_index(const predicate *pred, const match& m)$/;"	f	class:db::node
delete_by_index	db/trie.cpp	/^trie::delete_by_index(const match& m)$/;"	f	class:db::trie
delete_by_index	db/tuple_aggregate.cpp	/^tuple_aggregate::delete_by_index(const match& m)$/;"	f	class:db::tuple_aggregate
delete_by_leaf	db/node.cpp	/^node::delete_by_leaf(const predicate *pred, tuple_trie_leaf *leaf)$/;"	f	class:db::node
delete_by_leaf	db/trie.cpp	/^trie::delete_by_leaf(trie_leaf *leaf)$/;"	f	class:db::trie
delete_index	vm/instr.hpp	/^inline field_num delete_index(pcounter pc) { return field_num_get(pc, 0); }$/;"	f	namespace:vm::instr
delete_info	db/node.hpp	/^   typedef trie::delete_info delete_info;$/;"	t	class:db::node
delete_info	db/trie.hpp	/^      explicit delete_info(const bool):$/;"	f	class:db::trie::delete_info
delete_info	db/trie.hpp	/^      explicit delete_info(trie *_tr,$/;"	f	class:db::trie::delete_info
delete_info	db/trie.hpp	/^   class delete_info$/;"	c	class:db::trie
delete_num_args	vm/instr.hpp	/^inline size_t delete_num_args(pcounter pc) { return (size_t)byte_get(pc, 2); }$/;"	f	namespace:vm::instr
delete_path	db/trie.cpp	/^trie::delete_path(trie_node *node)$/;"	f	class:db::trie
delete_pool	mem/thread.cpp	/^delete_pool(void)$/;"	f	namespace:mem
delete_predicate	vm/instr.hpp	/^inline predicate_id delete_predicate(const pcounter pc) { return predicate_get(pc, 1); }$/;"	f	namespace:vm::instr
delete_temp_file	ui/manager.cpp	/^delete_temp_file(const string& file)$/;"	f	namespace:ui
delete_tuple	db/node.cpp	/^node::delete_tuple(vm::tuple *tuple, ref_count many)$/;"	f	class:db::node
delete_tuple	db/trie.cpp	/^tuple_trie::delete_tuple(vm::tuple *tpl, const ref_count many)$/;"	f	class:db::tuple_trie
delete_val	vm/instr.hpp	/^inline instr_val delete_val(pcounter pc) { return val_get(pc, index_size); }$/;"	f	namespace:vm::instr
depth	scripts/generate_pyramid.py	/^depth = int(sys.argv[1])$/;"	v
deregister_tuple	vm/rule_matcher.cpp	/^rule_matcher::deregister_tuple(tuple *tpl, const ref_count count)$/;"	f	class:vm::rule_matcher
dest	scripts/generate_shortest_path.py	/^		dest = random.randint(0, total-1)$/;"	v
dest	scripts/generate_shortest_path.py	/^	dest = source$/;"	v
destroy	mem/allocator.hpp	/^   inline void destroy(pointer p) { p->~T(); }$/;"	f	class:mem::allocator
destroy	runtime/list.hpp	/^   inline void destroy(void)$/;"	f	class:runtime::cons
destroy	runtime/string.hpp	/^	inline void destroy(void)$/;"	f	class:runtime::rstring
deterministic_timestamp	vm/state.hpp	/^typedef size_t deterministic_timestamp;$/;"	t	namespace:vm
difference_type	mem/allocator.hpp	/^   typedef std::ptrdiff_t difference_type;$/;"	t	class:mem::allocator
dir	scripts/csv_benchmarks.py	/^dir = str(sys.argv[1])$/;"	v
distance	scripts/generate_random_shortest_path.py	/^	distance = random.randint(1, 10)$/;"	v
divisible_by	scripts/generate_heat_grid.py	/^def divisible_by(x, y):$/;"	f
doSplashBP	prolog/splash_bp.pl	/^doSplashBP :-$/;"	l
do_agg_tuple_add	sched/base.cpp	/^base::do_agg_tuple_add(node *node, vm::tuple *tuple, const ref_count count)$/;"	f	class:sched::base
do_blocks	scripts/generate_heat_grid.py	/^def do_blocks(thread):$/;"	f
do_execute	vm/exec.cpp	/^do_execute(byte_code code, state& state)$/;"	f	namespace:vm
do_exit	tests/test.sh	/^do_exit ()$/;"	f
do_generate	db/agg_configuration.cpp	/^agg_configuration::do_generate(const aggregate_type typ, const field_num field)$/;"	f	class:db::agg_configuration
do_generate	db/neighbor_agg_configuration.cpp	/^neighbor_agg_configuration::do_generate(const aggregate_type typ, const field_num num)$/;"	f	class:db::neighbor_agg_configuration
do_insert	queue/safe_complex_pqueue.hpp	/^	void do_insert(heap_object node, const heap_priority prio)$/;"	f	class:queue::intrusive_safe_complex_pqueue
do_loop	sched/base.cpp	/^base::do_loop(void)$/;"	f	class:sched::base
do_match	vm/exec.cpp	/^do_match(const tuple *tuple, const field_num& field, const instr_val& val,$/;"	f	namespace:vm
do_matches	vm/exec.cpp	/^do_matches(pcounter pc, const tuple *tuple, const state& state)$/;"	f	namespace:vm
do_node	scripts/generate_heat_grid.py	/^def do_node(row, col):$/;"	f
do_persistent_tuples	vm/state.cpp	/^state::do_persistent_tuples(void)$/;"	f	class:vm::state
do_pop	queue/safe_complex_pqueue.hpp	/^	heap_object do_pop(void)$/;"	f	class:queue::intrusive_safe_complex_pqueue
do_range	scripts/generate_heat_grid.py	/^def do_range(startrow, endrow, startcol, endcol):$/;"	f
do_remove	queue/safe_complex_pqueue.hpp	/^	void do_remove(heap_object obj)$/;"	f	class:queue::intrusive_safe_complex_pqueue
do_run	benchs/instrument.sh	/^do_run ()$/;"	f
do_run	benchs/mix_even.sh	/^do_run ()$/;"	f
do_run	benchs/mpi_even.sh	/^do_run ()$/;"	f
do_run	benchs/threads_even.sh	/^do_run ()$/;"	f
do_serial	tests/test.sh	/^do_serial ()$/;"	f
do_test	tests/test.sh	/^do_test ()$/;"	f
do_time_mpi	benchs/lib/common.sh	/^do_time_mpi ()$/;"	f
do_time_sched	benchs/threads.sh	/^do_time_sched ()$/;"	f
do_tuple_add	sched/base.cpp	/^base::do_tuple_add(node *node, vm::tuple *tuple, const ref_count count)$/;"	f	class:sched::base
do_weights	scripts/generate_heat_grid.py	/^def do_weights(row, col):$/;"	f
do_work	sched/base.cpp	/^base::do_work(db::node *node)$/;"	f	class:sched::base
done	sched/thread/termination_barrier.hpp	/^   volatile bool done;$/;"	m	class:sched::termination_barrier
done	ui/client.hpp	/^      volatile bool done;$/;"	m	class:ui::client
done	utils/simple_barrier.hpp	/^   volatile bool done;$/;"	m	class:utils::simple_barrier
drop_constant	scripts/generate_heat_chain.py	/^		drop_constant = float(drop_part)$/;"	v
drop_constant	scripts/generate_heat_chain.py	/^	drop_constant = 1.0 \/ float(nodes)$/;"	v
drop_constant	scripts/generate_heat_chain.py	/^drop_constant = 0$/;"	v
drop_part	scripts/generate_heat_chain.py	/^		drop_part = drop_type[8:]$/;"	v
drop_type	scripts/generate_heat_chain.py	/^		drop_type = 'constant'$/;"	v
drop_type	scripts/generate_heat_chain.py	/^	drop_type = 'constant'$/;"	v
drop_type	scripts/generate_heat_chain.py	/^	drop_type = 'linear'$/;"	v
drop_type	scripts/generate_heat_chain.py	/^	drop_type = sys.argv[2]$/;"	v
drop_type	scripts/generate_heat_chain.py	/^drop_type = ''$/;"	v
dropped_rules	vm/rule_matcher.hpp	/^	set_rules dropped_rules; \/* any dropped rule *\/$/;"	m	class:vm::rule_matcher
dump	db/node.cpp	/^node::dump(ostream& cout) const$/;"	f	class:db::node
dump	db/trie.cpp	/^tuple_trie::dump(ostream& cout) const$/;"	f	class:db::tuple_trie
dump_database	interface.cpp	/^bool dump_database = false;$/;"	v
dump_db	db/database.cpp	/^database::dump_db(ostream& cout) const$/;"	f	class:database
dur	utils/time.hpp	/^   boost::posix_time::time_duration dur;$/;"	m	class:utils::execution_time
east	sched/nodes/sim.hpp	/^   vm::node_val east;$/;"	m	class:sched::sim_node
east_neighbors	mock-simulator/simulator.cpp	/^static vector<int> west_neighbors, east_neighbors;$/;"	v	file:
edge_info	db/node.hpp	/^   edge_map edge_info;$/;"	m	class:db::node
edge_map	db/node.hpp	/^                  edge_map; $/;"	t	class:db::node
edge_set	db/edge_set.hpp	/^               mem::allocator<vm::node_val> > edge_set;$/;"	t	namespace:db
edges	scripts/check_coloring.py	/^					edges = neighbors[node]$/;"	v
elem	utils/atomic.hpp	/^   volatile T elem;$/;"	m	class:utils::atomic
empty	db/trie.hpp	/^   inline bool empty(void) const { return number_of_references == 0; }$/;"	f	class:db::trie
empty	db/tuple_aggregate.hpp	/^   inline bool empty(void) const { return vals.empty(); }$/;"	f	class:db::tuple_aggregate
empty	queue/bounded_pqueue.hpp	/^   inline bool empty(void) const { return total == 0; }$/;"	f	class:queue::bounded_pqueue
empty	queue/safe_general_pqueue.hpp	/^   inline bool empty(void) const$/;"	f	class:queue::general_pqueue
empty	queue/safe_linear_queue.hpp	/^   inline bool empty(void) const { return head == tail; }$/;"	f	class:queue::safe_linear_queue
empty	queue/safe_linear_queue.hpp	/^   inline bool empty(void) const$/;"	f	class:queue::push_safe_linear_queue
empty	queue/simple_linear_pqueue.hpp	/^   inline bool empty(void) const { return total == 0; }$/;"	f	class:queue::simple_linear_pqueue
empty	sched/thread/steal_set.hpp	/^   inline bool empty(void) const { return requests.empty(); }$/;"	f	class:sched::steal_set
end	db/trie.hpp	/^   inline const_iterator end(void) const { return iterator(); }$/;"	f	class:db::agg_trie
end	db/trie.hpp	/^   inline const_iterator end(void) const { return iterator(); }$/;"	f	class:db::tuple_trie
end	db/trie.hpp	/^   inline iterator end(void) { return iterator(); }$/;"	f	class:db::agg_trie
end	db/trie.hpp	/^   inline iterator end(void) { return iterator(); }$/;"	f	class:db::tuple_trie
end	queue/bounded_pqueue.hpp	/^	inline const_iterator end(void) const { return const_iterator(); }$/;"	f	class:queue::bounded_pqueue
end	queue/safe_linear_queue.hpp	/^	inline const_iterator end(void) const$/;"	f	class:queue::push_safe_linear_queue
end	queue/safe_simple_pqueue.hpp	/^		mutable bool end;$/;"	m	class:queue::heap_queue::const_iterator
end	queue/safe_simple_pqueue.hpp	/^	inline const_iterator end(void) const$/;"	f	class:queue::heap_queue
end	sched/mpi.hpp	/^   virtual void end(void) {}$/;"	f	class:sched::mpi_sched
end	sched/nodes/serial.hpp	/^	inline queue_iterator end(void) const { return queue.end(); }$/;"	f	class:sched::serial_node
end	sched/serial.hpp	/^   virtual void end(void) {}$/;"	f	class:sched::serial_local
end	sched/sim.hpp	/^   virtual void end(void) {}$/;"	f	class:sched::sim_sched
end_active_rules	vm/rule_matcher.hpp	/^	rule_iterator end_active_rules(void) const { return active_rules.end(); }$/;"	f	class:vm::rule_matcher
end_dropped_rules	vm/rule_matcher.hpp	/^	rule_iterator end_dropped_rules(void) const { return dropped_rules.end(); }$/;"	f	class:vm::rule_matcher
end_iteration	db/node.cpp	/^node::end_iteration(void)$/;"	f	class:db::node
end_iteration	sched/base.hpp	/^   inline bool end_iteration(void)$/;"	f	class:sched::base
end_predicates	vm/rule.hpp	/^		inline predicate_iterator end_predicates(void) const { return predicates.end(); }$/;"	f	class:vm::rule
end_rules	vm/predicate.hpp	/^   inline rule_iterator end_rules(void) const$/;"	f	class:vm::predicate
endwidth	scripts/plots/active_inactive.py	/^	endwidth = startwidth + int(widthdivision)$/;"	v
ensure_pool	mem/thread.cpp	/^ensure_pool(void)$/;"	f	namespace:mem
env	sched/mpi.cpp	/^            boost::mpi::environment env;$/;"	m	class:sched::mpi	file:
equal	runtime/list.hpp	/^	bool equal(const list_ptr l1, const list_ptr l2)$/;"	f	class:runtime::cons
erase	db/trie.cpp	/^agg_trie::erase(agg_trie_iterator& it)$/;"	f	class:db::agg_trie
errno	scripts/csv_benchmarks.py	/^import errno$/;"	i
errno	scripts/lib_csv.py	/^import errno$/;"	i
event_database	ui/manager.cpp	/^manager::event_database(db::database *db)$/;"	f	class:ui::manager
event_linear_consumption	ui/manager.cpp	/^manager::event_linear_consumption(const db::node *node, const vm::tuple *tpl)$/;"	f	class:ui::manager
event_linear_derivation	ui/manager.cpp	/^manager::event_linear_derivation(const db::node *n, const vm::tuple *tpl)$/;"	f	class:ui::manager
event_new_node	ui/manager.cpp	/^manager::event_new_node(const db::node *node)$/;"	f	class:ui::manager
event_persistent_derivation	ui/manager.cpp	/^manager::event_persistent_derivation(const db::node *n, const vm::tuple *tpl)$/;"	f	class:ui::manager
event_program	ui/manager.cpp	/^manager::event_program(vm::program *pgrm)$/;"	f	class:ui::manager
event_program_running	ui/manager.cpp	/^manager::event_program_running(void)$/;"	f	class:ui::manager
event_program_stopped	ui/manager.cpp	/^manager::event_program_stopped(void)$/;"	f	class:ui::manager
event_program_termination	ui/manager.cpp	/^manager::event_program_termination(void)$/;"	f	class:ui::manager
event_rule_applied	ui/manager.cpp	/^manager::event_rule_applied(const db::node *who, const vm::rule *rule)$/;"	f	class:ui::manager
event_rule_start	ui/manager.cpp	/^manager::event_rule_start(const db::node *who, const vm::rule *rule)$/;"	f	class:ui::manager
event_set_color	ui/manager.cpp	/^manager::event_set_color(const db::node *n, const int r, const int g, const int b)$/;"	f	class:ui::manager
event_set_edge_label	ui/manager.cpp	/^manager::event_set_edge_label(const vm::node_val from, const vm::node_val to, const string& label)$/;"	f	class:ui::manager
event_step_done	ui/manager.cpp	/^manager::event_step_done(const db::node *n)$/;"	f	class:ui::manager
event_step_start	ui/manager.cpp	/^manager::event_step_start(const db::node *n)$/;"	f	class:ui::manager
event_tuple_send	ui/manager.cpp	/^manager::event_tuple_send(const db::node *from, const db::node *to, const vm::tuple *tpl)$/;"	f	class:ui::manager
event_type	ui/manager.hpp	/^} event_type;$/;"	t	namespace:ui	typeref:enum:ui::__anon6
exact	vm/match.hpp	/^   bool exact;$/;"	m	struct:vm::match_field
execute	vm/exec.cpp	/^execute(pcounter pc, state& state)$/;"	f	namespace:vm
execute_alloc	vm/exec.cpp	/^execute_alloc(const pcounter& pc, state& state)$/;"	f	namespace:vm
execute_bytecode	vm/exec.cpp	/^execute_bytecode(byte_code code, state& state)$/;"	f	namespace:vm
execute_call	vm/exec.cpp	/^execute_call(pcounter pc, state& state)$/;"	f	namespace:vm
execute_colocated	vm/exec.cpp	/^execute_colocated(pcounter pc, state& state)$/;"	f	namespace:vm
execute_cons	vm/exec.cpp	/^execute_cons(pcounter pc, state& state)$/;"	f	namespace:vm
execute_const_code	process/machine.cpp	/^machine::execute_const_code(void)$/;"	f	class:process::machine
execute_delete	vm/exec.cpp	/^execute_delete(const pcounter pc, state& state)$/;"	f	namespace:vm
execute_float	vm/exec.cpp	/^execute_float(pcounter& pc, state& state)$/;"	f	namespace:vm
execute_head	vm/exec.cpp	/^execute_head(pcounter& pc, state& state)$/;"	f	namespace:vm
execute_iter	vm/exec.cpp	/^execute_iter(pcounter pc, const utils::byte options, const utils::byte options_arguments,$/;"	f	namespace:vm
execute_move	vm/exec.cpp	/^execute_move(const pcounter& pc, state& state)$/;"	f	namespace:vm
execute_move_nil	vm/exec.cpp	/^execute_move_nil(pcounter& pc, state& state)$/;"	f	namespace:vm
execute_new_axioms	vm/exec.cpp	/^execute_new_axioms(pcounter pc, state& state)$/;"	f	namespace:vm
execute_new_node	vm/exec.cpp	/^execute_new_node(const pcounter& pc, state& state)$/;"	f	namespace:vm
execute_not	vm/exec.cpp	/^execute_not(pcounter& pc, state& state)$/;"	f	namespace:vm
execute_op	vm/exec.cpp	/^execute_op(const pcounter& pc, state& state)$/;"	f	namespace:vm
execute_remove	vm/exec.cpp	/^execute_remove(pcounter pc, state& state)$/;"	f	namespace:vm
execute_rule	vm/exec.cpp	/^execute_rule(const pcounter& pc, state& state)$/;"	f	namespace:vm
execute_rule	vm/exec.cpp	/^execute_rule(const rule_id rule_id, state& state)$/;"	f	namespace:vm
execute_rule_done	vm/exec.cpp	/^execute_rule_done(const pcounter& pc, state& state)$/;"	f	namespace:vm
execute_select	vm/exec.cpp	/^execute_select(pcounter pc, state& state)$/;"	f	namespace:vm
execute_send	vm/exec.cpp	/^execute_send(const pcounter& pc, state& state)$/;"	f	namespace:vm
execute_send_delay	vm/exec.cpp	/^execute_send_delay(const pcounter& pc, state& state)$/;"	f	namespace:vm
execute_send_self	vm/exec.cpp	/^execute_send_self(tuple *tuple, state& state)$/;"	f	namespace:vm
execute_tail	vm/exec.cpp	/^execute_tail(pcounter& pc, state& state)$/;"	f	namespace:vm
execute_test_nil	vm/exec.cpp	/^execute_test_nil(pcounter pc, state& state)$/;"	f	namespace:vm
execution_return	vm/exec.hpp	/^} execution_return;$/;"	t	namespace:vm	typeref:enum:vm::__anon9
execution_time	utils/time.hpp	/^   explicit execution_time(void) {}$/;"	f	class:utils::execution_time
execution_time	utils/time.hpp	/^class execution_time$/;"	c	namespace:utils
expand	db/trie.cpp	/^trie_hash::expand(void)$/;"	f	class:db::trie_hash
external	external/core.cpp	/^namespace external$/;"	n	namespace:vm	file:
external	external/core.hpp	/^namespace external$/;"	n	namespace:vm
external	external/lists.cpp	/^namespace external$/;"	n	namespace:vm	file:
external	external/lists.hpp	/^namespace external$/;"	n	namespace:vm
external	external/math.cpp	/^namespace external$/;"	n	namespace:vm	file:
external	external/math.hpp	/^namespace external$/;"	n	namespace:vm
external	external/others.cpp	/^namespace external$/;"	n	namespace:vm	file:
external	external/others.hpp	/^namespace external$/;"	n	namespace:vm
external	external/strings.cpp	/^namespace external$/;"	n	namespace:vm	file:
external	external/strings.hpp	/^namespace external$/;"	n	namespace:vm
external	external/utils.cpp	/^namespace external$/;"	n	namespace:vm	file:
external	external/utils.hpp	/^namespace external$/;"	n	namespace:vm
external0	vm/external.cpp	/^external0(external_function_ptr ptr, const field_type ret)$/;"	f	namespace:vm
external1	vm/external.cpp	/^external1(external_function_ptr ptr, const field_type ret, const field_type arg1)$/;"	f	namespace:vm
external2	vm/external.cpp	/^external2(external_function_ptr ptr, const field_type ret, const field_type arg1, const field_type arg2)$/;"	f	namespace:vm
external3	vm/external.cpp	/^external3(external_function_ptr ptr, const field_type ret, const field_type arg1,$/;"	f	namespace:vm
external_function	vm/external.cpp	/^external_function::external_function(external_function_ptr _ptr,$/;"	f	class:vm::external_function
external_function	vm/external.hpp	/^class external_function$/;"	c	namespace:vm
external_function_id	vm/external.hpp	/^typedef size_t external_function_id;$/;"	t	namespace:vm
external_function_ptr	vm/external.hpp	/^typedef external_function_ptr0 external_function_ptr;$/;"	t	namespace:vm
external_function_ptr0	vm/external.hpp	/^typedef argument (*external_function_ptr0)();$/;"	t	namespace:vm
external_function_ptr1	vm/external.hpp	/^typedef argument (*external_function_ptr1)(argument);$/;"	t	namespace:vm
external_function_ptr2	vm/external.hpp	/^typedef argument (*external_function_ptr2)(argument,argument);$/;"	t	namespace:vm
external_function_ptr3	vm/external.hpp	/^typedef argument (*external_function_ptr3)(argument, argument, argument);$/;"	t	namespace:vm
f	scripts/plots/state_totals.py	/^f = open(file, 'rb')$/;"	v
f	scripts/transform_pagerank.py	/^f = open(file, 'rb')$/;"	v
face_t	mock-simulator/simulator.cpp	/^enum face_t {$/;"	g	file:
face_t	sched/nodes/sim.hpp	/^enum face_t {$/;"	g	namespace:sched
fail_sched	interface.cpp	/^fail_sched(char* sched)$/;"	f	file:
fetch	vm/instr.hpp	/^inline instr_type fetch(pcounter pc) { return (instr_type)*pc; }$/;"	f	namespace:vm::instr
fetch_and_add	utils/atomic.hpp	/^   inline T fetch_and_add(const T plus) { return __sync_fetch_and_add(&elem, plus); }$/;"	f	class:utils::atomic
fetch_and_sub	utils/atomic.hpp	/^   inline T fetch_and_sub(const T sub) { return __sync_fetch_and_sub(&elem, sub); }$/;"	f	class:utils::atomic
field	vm/exec.cpp	/^	const field_num field;$/;"	m	class:vm::tuple_sorter	file:
field	vm/predicate.hpp	/^      field_num field;$/;"	m	struct:vm::predicate::__anon11
field_equal	vm/tuple.cpp	/^tuple::field_equal(const tuple& other, const field_num i) const$/;"	f	class:vm::tuple
field_num	vm/defs.hpp	/^typedef unsigned short field_num;$/;"	t	namespace:vm
field_num_get	vm/instr.hpp	/^inline field_num field_num_get(pcounter x, size_t off) { return (field_num)*(x + off); }$/;"	f	namespace:vm::instr
field_size	vm/instr.hpp	/^const size_t field_size = 2;$/;"	m	namespace:vm::instr
field_type	vm/types.hpp	/^enum field_type {$/;"	g	namespace:vm
field_type_size	vm/types.cpp	/^field_type_size(field_type type)$/;"	f	namespace:vm
field_type_string	vm/types.cpp	/^field_type_string(field_type type)$/;"	f	namespace:vm
fields	vm/tuple.hpp	/^   tuple_field *fields;$/;"	m	class:vm::tuple
fields_offset	vm/predicate.hpp	/^   std::vector<size_t> fields_offset;$/;"	m	class:vm::predicate
fields_size	vm/predicate.hpp	/^   std::vector<size_t> fields_size;$/;"	m	class:vm::predicate
fifth	scripts/generate_heat_grid.py	/^		fifth = side \/ 5$/;"	v
file	scripts/csv_benchmarks.py	/^file = str(sys.argv[2])$/;"	v
file	scripts/generate_neural_network.py	/^file = sys.argv[4]$/;"	v
file	scripts/plots/state_totals.py	/^file = sys.argv[1]$/;"	v
file	scripts/transform_pagerank.py	/^file = sys.argv[1]$/;"	v
file_exists	utils/fs.cpp	/^file_exists(const string& filename)$/;"	f	namespace:utils
file_is_valid	ui/manager.cpp	/^bool file_is_valid(const std::string &str)$/;"	f	namespace:ui
file_print_and_remove	utils/fs.cpp	/^file_print_and_remove(const string& filename)$/;"	f	namespace:utils
filename	process/machine.hpp	/^   const std::string filename;$/;"	m	class:process::machine
filename	vm/program.hpp	/^   const std::string filename;$/;"	m	class:vm::program
find_configuration	db/trie.cpp	/^agg_trie::find_configuration(vm::tuple *tpl)$/;"	f	class:db::agg_trie
find_node	db/database.cpp	/^database::find_node(const node::node_id id) const$/;"	f	class:database
find_scheduler	sched/mpi.hpp	/^   sim_sched *find_scheduler(const db::node *) { return this; }$/;"	f	class:sched::mpi_sched
find_scheduler	sched/serial.hpp	/^   serial_local *find_scheduler(const db::node *) { return this; }$/;"	f	class:sched::serial_local
find_scheduler	sched/sim.hpp	/^   sim_sched *find_scheduler(const db::node *) { return this; }$/;"	f	class:sched::sim_sched
finish	interface.cpp	/^finish(void)$/;"	f	file:
finish_work	sched/base.hpp	/^   virtual void finish_work(db::node *)$/;"	f	class:sched::base
first	scripts/plots/state_totals.py	/^      first = False$/;"	v
first	scripts/plots/state_totals.py	/^first = True$/;"	v
first_chunk	mem/chunkgroup.hpp	/^   chunk *first_chunk;$/;"	m	class:mem::chunkgroup
first_leaf	db/trie.hpp	/^   trie_leaf *first_leaf;$/;"	m	class:db::trie
float_dest	vm/instr.hpp	/^inline instr_val float_dest(pcounter pc) { return val_get(pc, 2); }$/;"	f	namespace:vm::instr
float_field	vm/defs.hpp	/^	float_val float_field;$/;"	m	union:vm::__anon7
float_list	runtime/list.hpp	/^typedef cons<vm::float_val> float_list;$/;"	t	namespace:runtime
float_op	vm/instr.hpp	/^inline instr_val float_op(pcounter pc) { return val_get(pc, 1); }$/;"	f	namespace:vm::instr
float_priority	queue/heap_implementation.hpp	/^	float float_priority;$/;"	m	union:__anon2
float_size	vm/instr.hpp	/^const size_t float_size = sizeof(float_val);$/;"	m	namespace:vm::instr
float_val	vm/defs.hpp	/^typedef float float_val;$/;"	t	namespace:vm
force_aggregate	process/work.hpp	/^   inline bool force_aggregate(void) const { return mod & mods::FORCE_AGGREGATE; }$/;"	f	class:process::node_work
force_read	mock-simulator/simulator.cpp	/^force_read(int sock)$/;"	f	file:
fp	scripts/plots/active_inactive.py	/^fp = open(sys.argv[1], 'r')$/;"	v
free_float_list	vm/state.hpp	/^	std::list<runtime::float_list*, mem::allocator<runtime::float_list*> > free_float_list;$/;"	m	class:vm::state
free_int_list	vm/state.hpp	/^   std::list<runtime::int_list*, mem::allocator<runtime::int_list*> > free_int_list;$/;"	m	class:vm::state
free_node_list	vm/state.hpp	/^   std::list<runtime::node_list*, mem::allocator<runtime::node_list*> > free_node_list;$/;"	m	class:vm::state
free_objs	mem/chunkgroup.hpp	/^   mem_node *free_objs; \/\/ list of freed objects$/;"	m	class:mem::chunkgroup
free_rstring	vm/state.hpp	/^	std::list<runtime::rstring::ptr, mem::allocator<runtime::rstring::ptr> > free_rstring;$/;"	m	class:vm::state
fromScreen	client/springyui.js	/^	fromScreen = function(s) {$/;"	f
from_stack_to_list	runtime/list.hpp	/^from_stack_to_list(TStack& stk)$/;"	f	namespace:runtime
from_stack_to_reverse_list	runtime/list.hpp	/^from_stack_to_reverse_list(TStack& stk)$/;"	f	namespace:runtime
from_string	utils/utils.hpp	/^bool from_string(T& t, $/;"	f	namespace:utils
gap	scripts/plots/active_inactive.py	/^	gap = heightdivision \/ 3.0$/;"	v
gather_active_tuples	sched/base.hpp	/^	virtual db::simple_tuple_vector gather_active_tuples(db::node *, const vm::predicate_id) { return db::simple_tuple_vector(); }$/;"	f	class:sched::base
gather_active_tuples	sched/serial.cpp	/^serial_local::gather_active_tuples(db::node *node, const vm::predicate_id pred)$/;"	f	class:sched::serial_local
gather_active_tuples	sched/sim.cpp	/^sim_sched::gather_active_tuples(db::node *node, const vm::predicate_id pred)$/;"	f	class:sched::sim_sched
gather_active_tuples	sched/sim_tcp.cpp	/^sim_sched::gather_active_tuples(db::node *node, const vm::predicate_id pred)$/;"	f	class:sched::sim_sched
gather_next_tuples	sched/base.hpp	/^   virtual void gather_next_tuples(db::node *, db::simple_tuple_list&) { }$/;"	f	class:sched::base
gather_next_tuples	sched/serial.cpp	/^serial_local::gather_next_tuples(db::node *node, simple_tuple_list& ls)$/;"	f	class:sched::serial_local
gather_next_tuples	sched/sim.cpp	/^sim_sched::gather_next_tuples(db::node *node, simple_tuple_list& ls)$/;"	f	class:sched::sim_sched
gather_next_tuples	sched/sim_tcp.cpp	/^sim_sched::gather_next_tuples(db::node *node, simple_tuple_list& ls)$/;"	f	class:sched::sim_sched
general_pqueue	queue/safe_general_pqueue.hpp	/^class general_pqueue$/;"	c	namespace:queue
generate	db/agg_configuration.cpp	/^agg_configuration::generate(const aggregate_type typ, const field_num field,$/;"	f	class:db::agg_configuration
generate	db/tuple_aggregate.cpp	/^tuple_aggregate::generate(void)$/;"	f	class:db::tuple_aggregate
generate_aggs	sched/serial.cpp	/^serial_local::generate_aggs(void)$/;"	f	class:sched::serial_local
generate_aggs	sched/sim.cpp	/^sim_sched::generate_aggs(void)$/;"	f	class:sched::sim_sched
generate_aggs	sched/sim_tcp.cpp	/^sim_sched::generate_aggs(void)$/;"	f	class:sched::sim_sched
generate_first	db/agg_configuration.cpp	/^agg_configuration::generate_first(void) const$/;"	f	class:db::agg_configuration
generate_max_float	db/agg_configuration.cpp	/^agg_configuration::generate_max_float(const field_num field) const$/;"	f	class:db::agg_configuration
generate_max_int	db/agg_configuration.cpp	/^agg_configuration::generate_max_int(const field_num field) const$/;"	f	class:db::agg_configuration
generate_min_float	db/agg_configuration.cpp	/^agg_configuration::generate_min_float(const field_num field) const$/;"	f	class:db::agg_configuration
generate_min_int	db/agg_configuration.cpp	/^agg_configuration::generate_min_int(const field_num field) const$/;"	f	class:db::agg_configuration
generate_sink	scripts/generate_powergrid.py	/^def generate_sink():$/;"	f
generate_source_capacity	scripts/generate_powergrid.py	/^def generate_source_capacity():$/;"	f
generate_sum_float	db/agg_configuration.cpp	/^agg_configuration::generate_sum_float(const field_num field) const$/;"	f	class:db::agg_configuration
generate_sum_int	db/agg_configuration.cpp	/^agg_configuration::generate_sum_int(const field_num field) const$/;"	f	class:db::agg_configuration
generate_sum_list_float	db/agg_configuration.cpp	/^agg_configuration::generate_sum_list_float(const field_num field) const$/;"	f	class:db::agg_configuration
generate_tree	scripts/generate_binary_tree.py	/^def generate_tree(root, levels):$/;"	f
generate_weight	scripts/generate_shortest_path.py	/^def generate_weight():$/;"	f
generated_other_level	vm/state.hpp	/^	db::simple_tuple_vector generated_other_level; \/\/ tuples for later computation (another stratification level or time delay)$/;"	m	class:vm::state
generated_persistent_tuples	vm/state.hpp	/^	db::simple_tuple_list generated_persistent_tuples; \/\/ persistent tuples while running the rule$/;"	m	class:vm::state
generated_this_run	db/tuple.hpp	/^   bool generated_this_run;$/;"	m	class:db::simple_tuple
generated_tuples	vm/state.hpp	/^	db::simple_tuple_list generated_tuples; \/\/ tuples generated while running the rule$/;"	m	class:vm::state
get	runtime/list.hpp	/^	T get(const list_ptr ls, const size_t pos, const T def)$/;"	f	class:runtime::cons
get	utils/atomic.hpp	/^   inline T get(void) const { return (T)ref; }$/;"	f	class:utils::atomic_ref
get_agg_safeness	vm/predicate.hpp	/^   inline aggregate_safeness get_agg_safeness(void) const { return agg_info->safeness; }$/;"	f	class:vm::predicate
get_agg_strat_level	vm/predicate.hpp	/^   strat_level get_agg_strat_level(void) const { return agg_info->local_level; }$/;"	f	class:vm::predicate
get_aggregate_field	vm/predicate.hpp	/^   inline field_num get_aggregate_field(void) const { return agg_info->field; }$/;"	f	class:vm::predicate
get_aggregate_type	vm/predicate.hpp	/^   inline aggregate_type get_aggregate_type(void) const { return agg_info->type; }$/;"	f	class:vm::predicate
get_all	process/machine.hpp	/^   vm::all *get_all(void) const { return this->all; }$/;"	f	class:process::machine
get_arg_type	vm/external.hpp	/^   inline field_type get_arg_type(const size_t i) const { return spec[i]; }$/;"	f	class:vm::external_function
get_argument	vm/all.hpp	/^	inline runtime::rstring::ptr get_argument(const argument_id id)$/;"	f	class:vm::all
get_by_float	db/trie.cpp	/^trie_node::get_by_float(const float_val val) const$/;"	f	class:db::trie_node
get_by_int	db/trie.cpp	/^trie_node::get_by_int(const int_val val) const$/;"	f	class:db::trie_node
get_by_node	db/trie.cpp	/^trie_node::get_by_node(const node_val val) const$/;"	f	class:db::trie_node
get_bytecode	vm/rule.hpp	/^		inline byte_code get_bytecode(void) const { return code; }$/;"	f	class:vm::rule
get_child	db/trie.hpp	/^   inline trie_node* get_child(void) const { return (trie_node*)((vm::ptr_val)child & (~(vm::ptr_val)(0x1))); }$/;"	f	class:db::trie_node
get_client	ui/manager.cpp	/^manager::get_client(connection_ptr conn)$/;"	f	class:ui::manager
get_conf	db/trie.hpp	/^   inline agg_configuration *get_conf(void) const { return conf; }$/;"	f	class:db::agg_trie_leaf
get_const_bytecode	vm/program.hpp	/^	inline byte_code get_const_bytecode(void) const { return const_code; }$/;"	f	class:vm::program
get_const_type	vm/program.hpp	/^	inline field_type get_const_type(const const_id& id) const { return const_types[id]; }$/;"	f	class:vm::program
get_content	runtime/string.hpp	/^	inline std::string get_content(void) const$/;"	f	class:runtime::rstring
get_count	db/trie.hpp	/^   virtual inline size_t get_count(void) const { return 1; }$/;"	f	class:db::agg_trie_leaf
get_count	db/trie.hpp	/^   virtual inline size_t get_count(void) const { return tpl->get_count(); }$/;"	f	class:db::tuple_trie_leaf
get_count	db/tuple.hpp	/^   inline vm::ref_count get_count(void) const { return count; }$/;"	f	class:db::simple_tuple
get_creation_function	process/machine.cpp	/^get_creation_function(const scheduler_type sched_type)$/;"	f	namespace:process
get_default_string	vm/program.hpp	/^	inline runtime::rstring::ptr get_default_string(const size_t i) const$/;"	f	class:vm::program
get_edge_predicate	vm/program.cpp	/^program::get_edge_predicate(void) const$/;"	f	class:vm::program
get_edge_set	db/node.hpp	/^   const edge_set& get_edge_set(const vm::predicate_id id) const {$/;"	f	class:db::node
get_face	sched/nodes/sim.hpp	/^   face_t get_face(const vm::node_val node) {$/;"	f	class:sched::sim_node
get_field	vm/tuple.hpp	/^   tuple_field get_field(const field_num& field) const { return fields[field]; }$/;"	f	class:vm::tuple
get_field_from_obj	ui/manager.cpp	/^get_field_from_obj(Object& obj, const string& field)$/;"	f	namespace:ui
get_field_size	vm/predicate.hpp	/^   inline size_t get_field_size(const field_num field) const { return fields_size[field]; }$/;"	f	class:vm::predicate
get_field_type	vm/predicate.hpp	/^   inline field_type get_field_type(const field_num field) const { return types[field]; }$/;"	f	class:vm::predicate
get_field_type	vm/tuple.hpp	/^   field_type get_field_type(const field_num& field) const { return pred->get_field_type(field); }$/;"	f	class:vm::tuple
get_float	db/trie.cpp	/^trie_hash::get_float(const float_val& val) const$/;"	f	class:db::trie_hash
get_float_priority_level	sched/nodes/thread_intrusive.hpp	/^	inline vm::float_val get_float_priority_level(void) { return priority_level.float_priority; }$/;"	f	class:sched::thread_intrusive_node
get_fun_ptr	vm/external.hpp	/^   inline external_function_ptr get_fun_ptr(void) const { return ptr; }$/;"	f	class:vm::external_function
get_generated_run	db/tuple.hpp	/^   inline bool get_generated_run(void) const$/;"	f	class:db::simple_tuple
get_group	mem/pool.hpp	/^   chunkgroup *get_group(const size_t size)$/;"	f	class:mem::pool
get_hash	db/trie.hpp	/^   inline trie_hash* get_hash(void) const { return (trie_hash*)child; }$/;"	f	class:db::trie_node
get_head	runtime/list.hpp	/^   const T get_head(void) const { return head; }$/;"	f	class:runtime::cons
get_id	db/node.hpp	/^   inline node_id get_id(void) const { return id; }$/;"	f	class:db::node
get_id	sched/base.hpp	/^   inline vm::process_id get_id(void) const { return id; }$/;"	f	class:sched::base
get_id	scripts/generate_binary_tree.py	/^from lib import get_id$/;"	i
get_id	scripts/lib.py	/^def get_id():$/;"	f
get_id	vm/predicate.hpp	/^   inline predicate_id get_id(void) const { return id; }$/;"	f	class:vm::predicate
get_id	vm/rule.hpp	/^      inline rule_id get_id(void) const { return id; }$/;"	f	class:vm::rule
get_info	scripts/plots/state_totals.py	/^def get_info(name, data):$/;"	f
get_init_predicate	vm/program.cpp	/^program::get_init_predicate(void) const$/;"	f	class:vm::program
get_initial_priority	vm/program.hpp	/^   inline heap_priority get_initial_priority(void) const { return initial_priority; }$/;"	f	class:vm::program
get_int	db/trie.cpp	/^trie_hash::get_int(const int_val& val) const$/;"	f	class:db::trie_hash
get_int_priority_level	sched/nodes/thread_intrusive.hpp	/^	inline vm::int_val get_int_priority_level(void) { return priority_level.int_priority; }$/;"	f	class:sched::thread_intrusive_node
get_leaf	db/trie.hpp	/^   inline trie_leaf* get_leaf(void) const$/;"	f	class:db::trie_node
get_leaf	db/trie.hpp	/^   inline tuple_trie_leaf* get_leaf(void) const$/;"	f	class:db::tuple_trie_iterator
get_leaf	vm/state.hpp	/^   inline db::tuple_trie_leaf* get_leaf(const reg_num& num) const { return saved_leafs[num]; }$/;"	f	class:vm::state
get_list_type	vm/instr.hpp	/^inline field_type get_list_type(pcounter pc, size_t off) {$/;"	f	namespace:vm::instr
get_memory_in_use	mem/stat.cpp	/^get_memory_in_use(void)$/;"	f	namespace:mem
get_min_value	sched/nodes/thread_intrusive.hpp	/^	heap_priority get_min_value(void) const { return prioritized_tuples.min_value(); }$/;"	f	class:sched::thread_intrusive_node
get_name	vm/predicate.hpp	/^   inline std::string get_name(void) const { return name; }$/;"	f	class:vm::predicate
get_name	vm/program.hpp	/^   inline std::string get_name(void) const { return filename; }$/;"	f	class:vm::program
get_neighbor	mock-simulator/simulator.cpp	/^get_neighbor(const int node, const face_t side)$/;"	f	file:
get_neighbor_count	sched/nodes/sim.hpp	/^   inline size_t get_neighbor_count(void) const$/;"	f	class:sched::sim_node
get_neighbors_at	mock-simulator/simulator.cpp	/^get_neighbors_at(const face_t face)$/;"	f	file:
get_next	db/trie.hpp	/^   inline trie_node* get_next(void) const { return next; }$/;"	f	class:db::trie_node
get_next_node	mock-simulator/simulator.cpp	/^get_next_node(void)$/;"	f	file:
get_node	db/trie.cpp	/^trie_hash::get_node(const node_val& val) const$/;"	f	class:db::trie_hash
get_node	process/work.hpp	/^   inline db::node* get_node(void) const { return node; }$/;"	f	class:process::work
get_node_at_face	sched/nodes/sim.hpp	/^   vm::node_val *get_node_at_face(const face_t face) {$/;"	f	class:sched::sim_node
get_node_iterator	db/database.hpp	/^   map_nodes::iterator get_node_iterator(const node::node_id id) { return nodes.find(id); }$/;"	f	class:db::database
get_node_val	vm/exec.cpp	/^get_node_val(const pcounter& m, state& state)$/;"	f	namespace:vm
get_node_val	vm/exec.cpp	/^get_node_val(pcounter& m, state& state)$/;"	f	namespace:vm
get_num_args	vm/external.hpp	/^   inline size_t get_num_args(void) const { return num_args; }$/;"	f	class:vm::external_function
get_num_mallocs	mem/stat.cpp	/^get_num_mallocs(void)$/;"	f	namespace:mem
get_op_function	vm/exec.cpp	/^bool_val get_op_function<bool_val>(const instr_val& val, pcounter& m, state& state)$/;"	f	namespace:vm
get_op_function	vm/exec.cpp	/^float_list* get_op_function<float_list*>(const instr_val& val, pcounter& m, state& state)$/;"	f	namespace:vm
get_op_function	vm/exec.cpp	/^float_val get_op_function<float_val>(const instr_val& val, pcounter& m, state& state)$/;"	f	namespace:vm
get_op_function	vm/exec.cpp	/^int_list* get_op_function<int_list*>(const instr_val& val, pcounter& m, state& state)$/;"	f	namespace:vm
get_op_function	vm/exec.cpp	/^int_val get_op_function<int_val>(const instr_val& val, pcounter& m, state& state)$/;"	f	namespace:vm
get_op_function	vm/exec.cpp	/^node_list* get_op_function<node_list*>(const instr_val& val, pcounter& m, state& state)$/;"	f	namespace:vm
get_op_function	vm/exec.cpp	/^node_val get_op_function<node_val>(const instr_val& val, pcounter& m, state& state)$/;"	f	namespace:vm
get_op_function	vm/exec.cpp	/^ptr_val get_op_function<ptr_val>(const instr_val& val, pcounter& m, state& state)$/;"	f	namespace:vm
get_op_function	vm/exec.cpp	/^rstring::ptr get_op_function<rstring::ptr>(const instr_val& val, pcounter& m, state& state)$/;"	f	namespace:vm
get_owner	db/node.hpp	/^   inline sched::base *get_owner(void) const { return owner; }$/;"	f	class:db::node
get_parent	db/trie.hpp	/^   inline trie_node* get_parent(void) const { return parent; }$/;"	f	class:db::trie_node
get_pool	mem/thread.cpp	/^get_pool(void)$/;"	f	namespace:mem
get_predicate	db/tuple.hpp	/^	inline const vm::predicate* get_predicate(void) const$/;"	f	class:db::simple_tuple
get_predicate	vm/program.cpp	/^program::get_predicate(const predicate_id& id) const$/;"	f	class:vm::program
get_predicate	vm/tuple.hpp	/^   inline const predicate* get_predicate(void) const { return pred; }$/;"	f	class:vm::tuple
get_predicate_by_name	vm/program.cpp	/^program::get_predicate_by_name(const string& name) const$/;"	f	class:vm::program
get_predicate_bytecode	vm/program.hpp	/^   byte_code get_predicate_bytecode(const predicate_id id) const {$/;"	f	class:vm::program
get_predicate_id	db/tuple.hpp	/^   inline vm::predicate_id get_predicate_id(void) const$/;"	f	class:db::simple_tuple
get_predicate_id	vm/tuple.hpp	/^   inline predicate_id get_predicate_id(void) const { return pred->get_id(); }$/;"	f	class:vm::tuple
get_priority_argument	vm/predicate.hpp	/^   field_num get_priority_argument(void) const { return priority_argument; }$/;"	f	class:vm::predicate
get_priority_argument	vm/program.hpp	/^	inline field_num get_priority_argument(void) const { return priority_pred->get_priority_argument(); }$/;"	f	class:vm::program
get_priority_level	sched/nodes/thread_intrusive.hpp	/^	inline heap_priority get_priority_level(void) { return priority_level; }$/;"	f	class:sched::thread_intrusive_node
get_priority_predicate	vm/program.hpp	/^	inline predicate *get_priority_predicate(void) const { return priority_pred; }$/;"	f	class:vm::program
get_priority_strat_level	vm/program.hpp	/^   inline strat_level get_priority_strat_level(void) const { return priority_strat_level; }$/;"	f	class:vm::program
get_priority_type	vm/program.hpp	/^   inline field_type get_priority_type(void) const { return priority_type; }$/;"	f	class:vm::program
get_queue	queue/simple_linear_pqueue.hpp	/^   inline queue& get_queue(const size_t prio)$/;"	f	class:queue::simple_linear_pqueue
get_remote_pred	vm/predicate.hpp	/^   inline const predicate *get_remote_pred(void) const { return agg_info->remote_pred; }$/;"	f	class:vm::predicate
get_return_type	vm/external.hpp	/^   inline field_type get_return_type(void) const { return ret; }$/;"	f	class:vm::external_function
get_route_predicate	vm/program.cpp	/^program::get_route_predicate(const size_t& i) const$/;"	f	class:vm::program
get_rule	vm/program.hpp	/^   inline rule *get_rule(const rule_id id) const {$/;"	f	class:vm::program
get_sched_name	scripts/lib_csv.py	/^def get_sched_name(sched):$/;"	f
get_sched_threads	scripts/lib_csv.py	/^def get_sched_threads(sched):$/;"	f
get_sched_type	process/machine.hpp	/^   sched::scheduler_type get_sched_type(void) const { return sched_type; }$/;"	f	class:process::machine
get_scheduler	process/machine.hpp	/^   sched::base *get_scheduler(const vm::process_id id) { return this->all->ALL_THREADS[id]; }$/;"	f	class:process::machine
get_scheduler	sched/base.cpp	/^base::get_scheduler(void)$/;"	f	class:sched::base
get_size	vm/predicate.hpp	/^   inline size_t get_size(void) const { return tuple_size; }$/;"	f	class:vm::predicate
get_stat_file	stat/stat.cpp	/^get_stat_file(void)$/;"	f	namespace:statistics
get_storage	db/node.cpp	/^node::get_storage(const predicate* pred)$/;"	f	class:db::node
get_storage_size	vm/tuple.cpp	/^tuple::get_storage_size(void) const$/;"	f	class:vm::tuple
get_strat_level	db/tuple.hpp	/^   inline vm::strat_level get_strat_level(void) const$/;"	f	class:db::simple_tuple
get_strat_level	process/work.hpp	/^   inline vm::strat_level get_strat_level(void) const { return tuple->get_strat_level(); }$/;"	f	class:process::node_work
get_strat_level	vm/predicate.hpp	/^   inline strat_level get_strat_level(void) const { return level; }$/;"	f	class:vm::predicate
get_string	vm/rule.hpp	/^		inline const std::string get_string(void) const { return str; }$/;"	f	class:vm::rule
get_tail	runtime/list.hpp	/^   list_ptr get_tail(void) const { return tail; }$/;"	f	class:runtime::cons
get_timestamp	utils/time.hpp	/^get_timestamp(void)$/;"	f	namespace:utils
get_translated_id	db/node.hpp	/^   inline node_id get_translated_id(void) const { return translation; }$/;"	f	class:db::node
get_tuple	db/trie.hpp	/^   inline simple_tuple *get_tuple(void) const { return tpl; }$/;"	f	class:db::tuple_trie_leaf
get_tuple	db/tuple.hpp	/^   inline vm::tuple* get_tuple(void) const { return data; }$/;"	f	class:db::simple_tuple
get_tuple	process/work.hpp	/^   inline db::simple_tuple* get_tuple(void) const { return tuple; }$/;"	f	class:process::node_work
get_tuple	vm/exec.cpp	/^	static inline tuple *get_tuple(const iter_object& l)$/;"	f	class:vm::tuple_sorter	file:
get_tuple_queue	vm/state.hpp	/^	inline db::simple_tuple* get_tuple_queue(const reg_num& num) const { return saved_stuples[num]; }$/;"	f	class:vm::state
get_tuples_until_timestamp	sched/nodes/sim.hpp	/^   inline void get_tuples_until_timestamp(db::simple_tuple_list& ls, const size_t until)$/;"	f	class:sched::sim_node
get_type_stack	vm/match.hpp	/^   inline void get_type_stack(match_type_stack& stk) const {$/;"	f	class:vm::match
get_uint	db/trie.cpp	/^trie_hash::get_uint(const uint_val& val) const$/;"	f	class:db::trie_hash
get_underlying_tuple	db/trie.hpp	/^	inline vm::tuple *get_underlying_tuple(void) const { return tpl->get_tuple(); }$/;"	f	class:db::tuple_trie_leaf
get_underlying_tuple	process/work.hpp	/^   inline vm::tuple* get_underlying_tuple(void) const { return get_tuple()->get_tuple(); }$/;"	f	class:process::node_work
get_val_stack	vm/match.hpp	/^   inline void get_val_stack(match_val_stack& stk) const {$/;"	f	class:vm::match
get_work	sched/nodes/unsafe_static.hpp	/^   inline process::node_work get_work(void)$/;"	f	class:sched::unsafe_static_node
get_work	sched/serial.cpp	/^serial_local::get_work(void)$/;"	f	class:sched::serial_local
get_work	sched/sim.cpp	/^sim_sched::get_work(void)$/;"	f	class:sched::sim_sched
get_work	sched/sim_tcp.cpp	/^sim_sched::get_work(void)$/;"	f	class:sched::sim_sched
global_prio	vm/predicate.hpp	/^   priority_type global_prio;$/;"	m	class:vm::predicate
half	scripts/generate_heat_grid.py	/^		half = side \/ 2$/;"	v
handle_accel	sched/sim.cpp	/^sim_sched::handle_accel(const deterministic_timestamp ts, const db::node::node_id node,$/;"	f	class:sched::sim_sched
handle_accel	sched/sim_tcp.cpp	/^sim_sched::handle_accel(const deterministic_timestamp ts, const db::node::node_id node,$/;"	f	class:sched::sim_sched
handle_add_neighbor	sched/sim.cpp	/^sim_sched::handle_add_neighbor(const deterministic_timestamp ts, const db::node::node_id in,$/;"	f	class:sched::sim_sched
handle_add_neighbor	sched/sim_tcp.cpp	/^sim_sched::handle_add_neighbor(const deterministic_timestamp ts, const db::node::node_id in,$/;"	f	class:sched::sim_sched
handle_create_n_nodes	sched/sim.cpp	/^sim_sched::handle_create_n_nodes(deterministic_timestamp ts, size_t n, node::node_id start_id)$/;"	f	class:sched::sim_sched
handle_create_one_node	sched/sim_tcp.cpp	/^sim_sched::handle_create_one_node(deterministic_timestamp ts, size_t n, node::node_id start_id)$/;"	f	class:sched::sim_sched
handle_data	mock-simulator/simulator.cpp	/^handle_data(message_type *data, int sock)$/;"	f	file:
handle_deterministic_computation	sched/sim.cpp	/^sim_sched::handle_deterministic_computation(void)$/;"	f	class:sched::sim_sched
handle_deterministic_computation	sched/sim_tcp.cpp	/^sim_sched::handle_deterministic_computation(void)$/;"	f	class:sched::sim_sched
handle_receive_message	sched/sim.cpp	/^sim_sched::handle_receive_message(const deterministic_timestamp ts, db::node::node_id node,$/;"	f	class:sched::sim_sched
handle_receive_message	sched/sim_tcp.cpp	/^sim_sched::handle_receive_message(const deterministic_timestamp ts, db::node::node_id node,$/;"	f	class:sched::sim_sched
handle_remove_neighbor	sched/sim.cpp	/^sim_sched::handle_remove_neighbor(const deterministic_timestamp ts,$/;"	f	class:sched::sim_sched
handle_remove_neighbor	sched/sim_tcp.cpp	/^sim_sched::handle_remove_neighbor(const deterministic_timestamp ts,$/;"	f	class:sched::sim_sched
handle_run_node	sched/sim.cpp	/^sim_sched::handle_run_node(const deterministic_timestamp ts, const db::node::node_id node)$/;"	f	class:sched::sim_sched
handle_run_node	sched/sim_tcp.cpp	/^sim_sched::handle_run_node(const deterministic_timestamp ts, const db::node::node_id node)$/;"	f	class:sched::sim_sched
handle_shake	sched/sim.cpp	/^sim_sched::handle_shake(const deterministic_timestamp ts, const db::node::node_id node,$/;"	f	class:sched::sim_sched
handle_shake	sched/sim_tcp.cpp	/^sim_sched::handle_shake(const deterministic_timestamp ts, const db::node::node_id node,$/;"	f	class:sched::sim_sched
handle_tap	sched/sim.cpp	/^sim_sched::handle_tap(const deterministic_timestamp ts, const db::node::node_id node)$/;"	f	class:sched::sim_sched
handle_tap	sched/sim_tcp.cpp	/^sim_sched::handle_tap(const deterministic_timestamp ts, const db::node::node_id node)$/;"	f	class:sched::sim_sched
has_any_exact	vm/match.hpp	/^   inline bool has_any_exact(void) const { return any_exact; }$/;"	f	class:vm::match
has_been_instantiated	sched/nodes/sim.hpp	/^   inline bool has_been_instantiated(void) const$/;"	f	class:sched::sim_node
has_been_prioritized	sched/nodes/thread_intrusive.hpp	/^	bool has_been_prioritized;$/;"	m	class:sched::thread_intrusive_node
has_been_touched	sched/nodes/thread_intrusive.hpp	/^   bool has_been_touched;$/;"	m	class:sched::thread_intrusive_node
has_changed	db/agg_configuration.hpp	/^   inline bool has_changed(void) const { return changed; }$/;"	f	class:db::agg_configuration
has_global_priority	vm/program.hpp	/^	inline bool has_global_priority(void) const { return priority_pred != NULL; }$/;"	f	class:vm::program
has_link	scripts/generate_shortest_path.py	/^def has_link(hash, k, v):$/;"	f
has_normal_work	sched/nodes/thread_intrusive.hpp	/^	virtual bool has_normal_work(void) const { return thread_node::has_work(); }$/;"	f	class:sched::thread_intrusive_node
has_prio_work	sched/nodes/thread_intrusive.hpp	/^	virtual bool has_prio_work(void) const { return !prioritized_tuples.empty(); }$/;"	f	class:sched::thread_intrusive_node
has_priority_level	sched/nodes/thread_intrusive.hpp	/^	inline bool has_priority_level(void) const {$/;"	f	class:sched::thread_intrusive_node
has_value	external/lists.cpp	/^has_value(const int_list *_l, int_val v)$/;"	f	namespace:vm::external
has_work	sched/nodes/serial.hpp	/^   inline bool has_work(void) const { return !queue.empty(); }$/;"	f	class:sched::serial_node
has_work	sched/nodes/sim.hpp	/^	inline bool has_work(void) const { return !tuple_pqueue.empty(); }$/;"	f	class:sched::sim_node
has_work	sched/nodes/thread.hpp	/^   virtual inline bool has_work(void) const { return !queue.empty(); }$/;"	f	class:sched::thread_node
has_work	sched/nodes/thread_intrusive.hpp	/^	virtual bool has_work(void) const { return thread_node::has_work() || !prioritized_tuples.empty(); }$/;"	f	class:sched::thread_intrusive_node
has_work	sched/nodes/unsafe_static.hpp	/^   inline bool has_work(void) const { return !queue.empty(); }$/;"	f	class:sched::unsafe_static_node
has_work	sched/serial.hpp	/^   inline bool has_work(void) const { return !queue_nodes.empty(); }$/;"	f	class:sched::serial_local
hash_external	vm/external.cpp	/^static hash_external_type hash_external;$/;"	m	namespace:vm	file:
hash_external_type	vm/external.cpp	/^typedef unordered_map<external_function_id, external_function*> hash_external_type;$/;"	t	namespace:vm	file:
hash_has	scripts/generate_shortest_path.py	/^def hash_has(hash, x):$/;"	f
hash_item	db/trie.hpp	/^   inline size_t hash_item(const size_t item) const { return item & (num_buckets-1); }$/;"	f	class:db::trie_hash
hashed	db/trie.hpp	/^   bool hashed;$/;"	m	class:db::trie_node
head	queue/safe_linear_queue.hpp	/^   volatile node *head;$/;"	m	class:queue::push_safe_linear_queue
head	queue/safe_linear_queue.hpp	/^   volatile node *head;$/;"	m	class:queue::safe_linear_queue
head	runtime/list.hpp	/^   const T head;$/;"	m	class:runtime::cons
head_cons	vm/instr.hpp	/^inline instr_val head_cons(pcounter pc) { return val_get(pc, 2); }$/;"	f	namespace:vm::instr
head_dest	vm/instr.hpp	/^inline instr_val head_dest(pcounter pc) { return val_get(pc, 3); }$/;"	f	namespace:vm::instr
head_type	vm/instr.hpp	/^inline field_type head_type(pcounter pc) { return get_list_type(pc, 1); }$/;"	f	namespace:vm::instr
header	scripts/plots/state_totals.py	/^header = ['type']$/;"	v
heap_object	queue/safe_complex_pqueue.hpp	/^	typedef T* heap_object;$/;"	t	class:queue::intrusive_safe_complex_pqueue
heap_object	queue/safe_simple_pqueue.hpp	/^	class heap_object$/;"	c	class:queue::heap_queue
heap_priority	queue/heap_implementation.hpp	/^} heap_priority;$/;"	t	typeref:union:__anon2
heap_queue	queue/safe_simple_pqueue.hpp	/^	explicit heap_queue(void) {}$/;"	f	class:queue::heap_queue
heap_queue	queue/safe_simple_pqueue.hpp	/^class heap_queue$/;"	c	namespace:queue
heap_type	queue/heap_implementation.hpp	/^} heap_type;$/;"	t	typeref:enum:__anon1
heat	scripts/heat_color.py	/^	heat = heats[node]$/;"	v
heat	scripts/heat_color.py	/^	heat = read_heat_node(data)$/;"	v
heats	scripts/heat_color.py	/^heats = {}$/;"	v
height	scripts/generate_grid.py	/^   height = int(lenvec[1])$/;"	v
height	scripts/generate_grid.py	/^   height = width$/;"	v
height	scripts/plots/active_inactive.py	/^	height = (i + 1) * heightdivision$/;"	v
heightdivision	scripts/plots/active_inactive.py	/^heightdivision = HEIGHT\/numcolumns$/;"	v
help	meld.cpp	/^help(void)$/;"	f	file:
help	server.cpp	/^help(void)$/;"	f	file:
help_schedulers	interface.cpp	/^help_schedulers(void)$/;"	f
highestxinner	scripts/heat_color.py	/^			highestxinner = x$/;"	v
highestxinner	scripts/heat_color.py	/^highestxinner = None$/;"	v
highestxinner	scripts/heat_count_color.py	/^			highestxinner = x$/;"	v
highestxinner	scripts/heat_count_color.py	/^highestxinner = None$/;"	v
highestyinner	scripts/heat_color.py	/^			highestyinner = y$/;"	v
highestyinner	scripts/heat_color.py	/^highestyinner = None$/;"	v
highestyinner	scripts/heat_count_color.py	/^			highestyinner = y$/;"	v
highestyinner	scripts/heat_count_color.py	/^highestyinner = None$/;"	v
host_size	vm/instr.hpp	/^const size_t host_size = 0;$/;"	m	namespace:vm::instr
i_am_on_queue	sched/nodes/in_queue.hpp	/^   volatile bool i_am_on_queue;$/;"	m	class:sched::in_queue_node
id	db/node.hpp	/^	node_id id;$/;"	m	class:db::node
id	sched/base.hpp	/^   const vm::process_id id;$/;"	m	class:sched::base
id	utils/tree_barrier.hpp	/^      const size_t id;$/;"	m	class:utils::tree_barrier::inner_node
id	vm/predicate.hpp	/^   predicate_id id;$/;"	m	class:vm::predicate
id	vm/rule.hpp	/^      rule_id id;$/;"	m	class:vm::rule
idle	scripts/plots/state_totals.py	/^idle = {}$/;"	v
idx	scripts/generate_random_shortest_path.py	/^	idx = random.randint(0, len(links)-1)$/;"	v
if_jump	vm/instr.hpp	/^inline code_offset_t if_jump(pcounter pc) { return jump_get(pc, 2); }$/;"	f	namespace:vm::instr
if_reg	vm/instr.hpp	/^inline reg_num if_reg(pcounter pc) { return reg_get(pc, 1); }$/;"	f	namespace:vm::instr
ignore	vm/rule_matcher.hpp	/^         bool ignore;$/;"	m	class:vm::rule_matcher::rule_matcher_obj
implement_cons	vm/exec.cpp	/^#define implement_cons(/;"	d	file:
implement_cons	vm/exec.cpp	/^#undef implement_cons$/;"	d	file:
implement_head	vm/exec.cpp	/^#define implement_head(/;"	d	file:
implement_head	vm/exec.cpp	/^#undef implement_head$/;"	d	file:
implement_operation	vm/exec.cpp	/^#define implement_operation(/;"	d	file:
implement_operation	vm/exec.cpp	/^#undef implement_operation$/;"	d	file:
implement_tail	vm/exec.cpp	/^#define implement_tail(/;"	d	file:
implement_tail	vm/exec.cpp	/^#undef implement_tail$/;"	d	file:
in_file	scripts/csv_step.py	/^in_file = str(sys.argv[1])$/;"	v
in_queue	queue/safe_complex_pqueue.hpp	/^	static inline bool in_queue(heap_object node)$/;"	f	class:queue::intrusive_safe_complex_pqueue
in_queue	sched/nodes/in_queue.hpp	/^   inline bool in_queue(void) const$/;"	f	class:sched::in_queue_node
in_queue_node	sched/nodes/in_queue.hpp	/^   explicit in_queue_node(const db::node::node_id _id, const db::node::node_id _trans, vm::all *all):$/;"	f	class:sched::in_queue_node
in_queue_node	sched/nodes/in_queue.hpp	/^class in_queue_node: public db::node$/;"	c	namespace:sched
inc_count	db/tuple.hpp	/^   inline void inc_count(const vm::ref_count& inc) { assert(inc > 0); count += inc; }$/;"	f	class:db::simple_tuple
inc_neighbor_count	sched/nodes/sim.hpp	/^   inline void inc_neighbor_count(void)$/;"	f	class:sched::sim_node
inc_refs	runtime/list.hpp	/^   inline void inc_refs(void)$/;"	f	class:runtime::cons
inc_refs	runtime/list.hpp	/^   static inline void inc_refs(list_ptr ls)$/;"	f	class:runtime::cons
inc_refs	runtime/string.hpp	/^	inline void inc_refs(void)$/;"	f	class:runtime::rstring
index_size	vm/instr.hpp	/^const size_t index_size = 1;$/;"	m	namespace:vm::instr
init	db/node.cpp	/^node::init(void)$/;"	f	class:db::node
init	mem/thread.cpp	/^init(void)$/;"	f	namespace:mem
init	sched/base.cpp	/^init(void)$/;"	f	namespace:sched
init	sched/serial.cpp	/^serial_local::init(const size_t)$/;"	f	class:sched::serial_local
init	sched/sim.cpp	/^sim_sched::init(const size_t num_threads)$/;"	f	class:sched::sim_sched
init	sched/sim_tcp.cpp	/^sim_sched::init(const size_t num_threads)$/;"	f	class:sched::sim_sched
init	ui/manager.cpp	/^init(void)$/;"	f	namespace:ui
init	vm/program.hpp	/^   mutable predicate *init;$/;"	m	class:vm::program
init_barriers	sched/thread/threaded.cpp	/^threaded::init_barriers(const size_t num_threads)$/;"	f	class:sched::threaded
init_core_statistics	vm/state.cpp	/^state::init_core_statistics(void)$/;"	f	class:vm::state
init_external_functions	vm/external.cpp	/^init_external_functions(void)$/;"	f	namespace:vm
init_node	sched/base.hpp	/^   virtual void init_node(db::node *node)$/;"	f	class:sched::base
init_thread	process/machine.cpp	/^machine::init_thread(sched::base *sched)$/;"	f	class:process::machine
initial_priority	vm/program.hpp	/^   heap_priority initial_priority;$/;"	m	class:vm::program
inner	scripts/heat_color.py	/^	inner = inners[node]$/;"	v
inner	scripts/heat_color.py	/^	inner = read_inner(data)$/;"	v
inner	scripts/heat_count_color.py	/^	inner = inners[node]$/;"	v
inner	scripts/heat_count_color.py	/^	inner = read_inner(data)$/;"	v
inner_delete_by_leaf	db/trie.cpp	/^trie::inner_delete_by_leaf(trie_leaf *leaf, const ref_count count)$/;"	f	class:db::trie
inner_node	utils/tree_barrier.hpp	/^      explicit inner_node(tree_barrier *tb, inner_node *_parent, const size_t _count, const size_t _id):$/;"	f	class:utils::tree_barrier::inner_node
inner_node	utils/tree_barrier.hpp	/^   class inner_node$/;"	c	class:utils::tree_barrier
inners	scripts/heat_color.py	/^inners = {}$/;"	v
inners	scripts/heat_count_color.py	/^inners = {}$/;"	v
innerweight	scripts/generate_heat_grid.py	/^innerweight = float(sys.argv[4])$/;"	v
input	scripts/duplicate_neural_network.py	/^input = sys.argv[1]$/;"	v
input	scripts/transform_letter_data.py	/^input = sys.argv[1]$/;"	v
ins_active	sched/base.hpp	/^#define ins_active /;"	d
ins_active	sched/base.hpp	/^#define ins_active$/;"	d
ins_idle	sched/base.hpp	/^#define ins_idle /;"	d
ins_idle	sched/base.hpp	/^#define ins_idle$/;"	d
ins_round	sched/base.hpp	/^#define ins_round /;"	d
ins_round	sched/base.hpp	/^#define ins_round$/;"	d
ins_sched	sched/base.hpp	/^#define ins_sched /;"	d
ins_sched	sched/base.hpp	/^#define ins_sched$/;"	d
ins_state	sched/base.hpp	/^   mutable statistics::sched_state ins_state;$/;"	m	class:sched::base
insert	db/trie.cpp	/^trie_node::insert(const tuple_field& field, const field_type& type, val_stack& vals, type_stack& typs)$/;"	f	class:db::trie_node
insert	queue/safe_complex_pqueue.hpp	/^	void insert(heap_object node, const heap_priority prio)$/;"	f	class:queue::intrusive_safe_complex_pqueue
insert	queue/safe_simple_pqueue.hpp	/^	void insert(T el, const heap_priority prio)$/;"	f	class:queue::heap_queue
insert_float	db/trie.cpp	/^trie_hash::insert_float(const float_val& val, trie_node *node)$/;"	f	class:db::trie_hash
insert_int	db/trie.cpp	/^trie_hash::insert_int(const int_val& val, trie_node *node)$/;"	f	class:db::trie_hash
insert_node	db/trie.cpp	/^trie_hash::insert_node(const node_val& val, trie_node *node)$/;"	f	class:db::trie_hash
insert_tuple	db/trie.cpp	/^tuple_trie::insert_tuple(vm::tuple *tpl, const ref_count many)$/;"	f	class:db::tuple_trie
insert_uint	db/trie.cpp	/^trie_hash::insert_uint(const uint_val& val, trie_node *node)$/;"	f	class:db::trie_hash
inside_outer	scripts/generate_heat_grid.py	/^def inside_outer(row, col):$/;"	f
insideheat	scripts/generate_heat_grid.py	/^insideheat = float(sys.argv[6])$/;"	v
instantiate_all_nodes	sched/sim.cpp	/^sim_sched::instantiate_all_nodes(void)$/;"	f	class:sched::sim_sched
instantiate_one_node	sched/sim_tcp.cpp	/^sim_sched::instantiate_one_node(void)$/;"	f	class:sched::sim_sched
instantiated_flag	sched/nodes/sim.hpp	/^   bool instantiated_flag;$/;"	m	class:sched::sim_node
instr	vm/instr.cpp	/^namespace instr {$/;"	n	namespace:vm	file:
instr	vm/instr.hpp	/^namespace instr {$/;"	n	namespace:vm
instr_argument_type	vm/instr.hpp	/^enum instr_argument_type {$/;"	g	namespace:vm::instr
instr_call_args_size	vm/instr.hpp	/^instr_call_args_size(pcounter arg, size_t num)$/;"	f	namespace:vm::instr
instr_delete_args_size	vm/instr.hpp	/^instr_delete_args_size(pcounter arg, size_t num)$/;"	f	namespace:vm::instr
instr_op	vm/instr.hpp	/^enum instr_op {$/;"	g	namespace:vm::instr
instr_print	vm/instr.cpp	/^instr_print(pcounter pc, const bool recurse, const int tabcount, const program *prog, ostream& cout)$/;"	f	namespace:vm
instr_print_simple	vm/instr.cpp	/^instr_print_simple(pcounter pc, const int tabcount, const program *prog, ostream& cout)$/;"	f	namespace:vm
instr_type	vm/instr.hpp	/^enum instr_type {$/;"	g	namespace:vm::instr
instr_val	vm/instr.hpp	/^typedef unsigned char instr_val;$/;"	t	namespace:vm
instrs_print	vm/instr.cpp	/^instrs_print(byte_code code, const code_size_t len, const int tabcount, const program* prog, ostream& cout)$/;"	f	namespace:vm
instrs_print_until	vm/instr.cpp	/^instrs_print_until(byte_code code, byte_code until, const int tabcount, const program* prog, ostream& cout)$/;"	f	namespace:vm
instrs_print_until_end_linear	vm/instr.cpp	/^instrs_print_until_end_linear(byte_code code, const int tabcount, const program* prog, ostream& cout)$/;"	f	namespace:vm
instrs_print_until_return_select	vm/instr.cpp	/^instrs_print_until_return_select(byte_code code, const int tabcount, const program* prog, ostream& cout)$/;"	f	namespace:vm
intHandler	mock-simulator/simulator.cpp	/^intHandler(int dummy = 0)$/;"	f	file:
int_field	vm/defs.hpp	/^	int_val int_field;$/;"	m	union:vm::__anon7
int_list	runtime/list.hpp	/^typedef cons<vm::int_val> int_list;$/;"	t	namespace:runtime
int_priority	queue/heap_implementation.hpp	/^	int int_priority;$/;"	m	union:__anon2
int_size	vm/instr.hpp	/^const size_t int_size = sizeof(int_val);$/;"	m	namespace:vm::instr
int_val	vm/defs.hpp	/^typedef int32_t int_val;$/;"	t	namespace:vm
intersect_line_box.bl.x	client/springyui.js	/^		var bl = {x: p3.x, y: p3.y + h};$/;"	p
intersect_line_box.br.x	client/springyui.js	/^		var br = {x: p3.x + w, y: p3.y + h};$/;"	p
intersect_line_box.tr.x	client/springyui.js	/^		var tr = {x: p3.x + w, y: p3.y};$/;"	p
interval	utils/interval.hpp	/^   explicit interval(const T& _min_val, const T& _max_val):$/;"	f	class:utils::interval
interval	utils/interval.hpp	/^class interval$/;"	c	namespace:utils
intrusive_safe_complex_pqueue	queue/safe_complex_pqueue.hpp	/^	intrusive_safe_complex_pqueue(const heap_type _typ): typ(_typ) {}$/;"	f	class:queue::intrusive_safe_complex_pqueue
intrusive_safe_complex_pqueue	queue/safe_complex_pqueue.hpp	/^	intrusive_safe_complex_pqueue(void) {}$/;"	f	class:queue::intrusive_safe_complex_pqueue
intrusive_safe_complex_pqueue	queue/safe_complex_pqueue.hpp	/^class intrusive_safe_complex_pqueue$/;"	c	namespace:queue
intrusive_safe_double_queue	queue/safe_double_queue.hpp	/^class intrusive_safe_double_queue$/;"	c	namespace:queue
intrusive_unsafe_double_bounded_pqueue	queue/bounded_pqueue.hpp	/^struct intrusive_unsafe_double_bounded_pqueue$/;"	s	namespace:queue
intrusive_unsafe_double_queue	queue/unsafe_double_queue.hpp	/^class intrusive_unsafe_double_queue$/;"	c	namespace:queue
inverse	scripts/generate_heat_chain.py	/^		inverse = nodes - previous$/;"	v
is_action	vm/predicate.hpp	/^   bool is_action;$/;"	m	class:vm::predicate
is_action	vm/tuple.hpp	/^   inline bool is_action(void) const { return pred->is_action_pred(); }$/;"	f	class:vm::tuple
is_action_pred	vm/predicate.hpp	/^   inline bool is_action_pred(void) const { return is_action; }$/;"	f	class:vm::predicate
is_active	sched/thread/termination_barrier.hpp	/^   inline void is_active(void)$/;"	f	class:sched::termination_barrier
is_active	sched/thread/threaded.hpp	/^   inline bool is_active(void) const { return tstate == THREAD_ACTIVE; }$/;"	f	class:sched::threaded
is_aggregate	db/tuple.hpp	/^   inline bool is_aggregate(void) const$/;"	f	class:db::simple_tuple
is_aggregate	vm/predicate.hpp	/^   inline bool is_aggregate(void) const { return agg_info != NULL; }$/;"	f	class:vm::predicate
is_aggregate	vm/tuple.hpp	/^   inline bool is_aggregate(void) const { return pred->is_aggregate(); }$/;"	f	class:vm::tuple
is_alive	ui/client.cpp	/^client::is_alive(void) const$/;"	f	class:ui::client
is_data_available	mock-simulator/simulator.cpp	/^is_data_available(int sock)$/;"	f	file:
is_empty	db/agg_configuration.hpp	/^   inline bool is_empty(void) const { return vals.empty(); }$/;"	f	class:db::agg_configuration
is_end	queue/bounded_pqueue.hpp	/^		bool is_end;$/;"	m	class:queue::bounded_pqueue::const_iterator
is_final_aggregate	db/tuple.hpp	/^   bool is_final_aggregate;$/;"	m	class:db::simple_tuple
is_global_priority	vm/predicate.hpp	/^	bool is_global_priority(void) const { return global_prio != NO_GLOBAL_PRIORITY; }$/;"	f	class:vm::predicate
is_global_priority_asc	vm/predicate.hpp	/^	inline bool is_global_priority_asc(void) const { return global_prio == PRIORITY_ASC; }$/;"	f	class:vm::predicate
is_global_priority_desc	vm/predicate.hpp	/^	inline bool is_global_priority_desc(void) const { return global_prio == PRIORITY_DESC; }$/;"	f	class:vm::predicate
is_hashed	db/trie.hpp	/^   inline bool is_hashed(void) const { return hashed; }$/;"	f	class:db::trie_node
is_header	utils/csv_line.hpp	/^   bool is_header;$/;"	m	class:utils::csv_line
is_inactive	sched/thread/termination_barrier.hpp	/^   inline void is_inactive(void)$/;"	f	class:sched::termination_barrier
is_inactive	sched/thread/threaded.hpp	/^   inline bool is_inactive(void) const { return tstate == THREAD_INACTIVE; }$/;"	f	class:sched::threaded
is_int	ui/manager.cpp	/^is_int(Value& v)$/;"	f	namespace:ui
is_it_a_leaf	vm/state.hpp	/^	inline bool is_it_a_leaf(const reg_num& num) const { return is_leaf[num]; }$/;"	f	class:vm::state
is_leaf	db/trie.hpp	/^   inline bool is_leaf(void) const { return (vm::ptr_val)child & 0x1; }$/;"	f	class:db::trie_node
is_leaf	queue/bounded_pqueue.hpp	/^   inline bool is_leaf(void) const { return right == NULL; }$/;"	f	class:queue::queue_tree_node
is_leaf	vm/state.hpp	/^	bool is_leaf[NUM_REGS];$/;"	m	class:vm::state
is_linear	vm/predicate.hpp	/^   bool is_linear;$/;"	m	class:vm::predicate
is_linear	vm/state.hpp	/^   bool is_linear;$/;"	m	class:vm::state
is_linear	vm/tuple.hpp	/^   inline bool is_linear(void) const { return pred->is_linear_pred(); }$/;"	f	class:vm::tuple
is_linear_pred	vm/predicate.hpp	/^   inline bool is_linear_pred(void) const { return is_linear; }$/;"	f	class:vm::predicate
is_locked	utils/spinlock.hpp	/^   inline bool is_locked(void) const { return data != 0; }$/;"	f	class:utils::spinlock
is_not_alnum	ui/manager.cpp	/^static inline bool is_not_alnum(char c)$/;"	f	namespace:ui
is_null	runtime/list.hpp	/^   static inline bool is_null(const list_ptr ls) { return ls == null_list(); }$/;"	f	class:runtime::cons
is_number	scripts/plots/active_inactive.py	/^def is_number(s):$/;"	f
is_obj	ui/manager.cpp	/^is_obj(Value& v)$/;"	f	namespace:ui
is_persistent	vm/rule.hpp	/^      bool is_persistent;$/;"	m	class:vm::rule
is_persistent	vm/tuple.hpp	/^	inline bool is_persistent(void) const { return pred->is_persistent_pred(); }$/;"	f	class:vm::tuple
is_persistent_pred	vm/predicate.hpp	/^	inline bool is_persistent_pred(void) const { return !is_linear_pred(); }$/;"	f	class:vm::predicate
is_priority_asc	vm/program.hpp	/^	inline bool is_priority_asc(void) const { return priority_order == PRIORITY_ASC; }$/;"	f	class:vm::program
is_priority_desc	vm/program.hpp	/^	inline bool is_priority_desc(void) const { return priority_order == PRIORITY_DESC; }$/;"	f	class:vm::program
is_reused	vm/predicate.hpp	/^   bool is_reused;$/;"	m	class:vm::predicate
is_reused	vm/tuple.hpp	/^   inline bool is_reused(void) const { return pred->is_reused_pred(); }$/;"	f	class:vm::tuple
is_reused_pred	vm/predicate.hpp	/^   inline bool is_reused_pred(void) const { return is_reused; }$/;"	f	class:vm::predicate
is_reverse_route	vm/predicate.hpp	/^   bool is_reverse_route;$/;"	m	class:vm::predicate
is_reverse_route_pred	vm/predicate.hpp	/^	inline bool is_reverse_route_pred(void) const { return is_reverse_route; }$/;"	f	class:vm::predicate
is_route	vm/predicate.hpp	/^   bool is_route;$/;"	m	class:vm::predicate
is_route_pred	vm/predicate.hpp	/^   inline bool is_route_pred(void) const { return is_route || is_reverse_route; }$/;"	f	class:vm::predicate
is_safe	vm/program.hpp	/^   inline bool is_safe(void) const { return safe; }$/;"	f	class:vm::program
is_serial_sched	sched/types.hpp	/^inline bool is_serial_sched(const scheduler_type type)$/;"	f	namespace:sched
is_string	ui/manager.cpp	/^is_string(Value& v)$/;"	f	namespace:ui
is_unsafe_agg	vm/predicate.hpp	/^   inline bool is_unsafe_agg(void) const { return get_agg_safeness() == AGG_UNSAFE || get_agg_safeness() == AGG_IMMEDIATE; }$/;"	f	class:vm::predicate
item	queue/safe_general_pqueue.hpp	/^      T item;$/;"	m	struct:queue::general_pqueue::queue_item
item	scripts/generate_random_shortest_path.py	/^	item = links[idx]$/;"	v
iter	stat/slice_set.hpp	/^   typedef list_slices::const_iterator iter;$/;"	t	class:statistics::slice_set
iter_jump	vm/instr.hpp	/^inline code_offset_t iter_jump(pcounter pc) { return jump_get(pc, 4); }$/;"	f	namespace:vm::instr
iter_match	vm/instr.hpp	/^typedef pcounter iter_match;$/;"	t	namespace:vm::instr
iter_match_end	vm/instr.hpp	/^inline bool iter_match_end(iter_match m) { return (*(m + 1) & 0xc0) == 0x40; }$/;"	f	namespace:vm::instr
iter_match_field	vm/instr.hpp	/^inline field_num iter_match_field(iter_match m) { return (field_num)*m; }$/;"	f	namespace:vm::instr
iter_match_none	vm/instr.hpp	/^inline bool iter_match_none(iter_match m) { return (*(m + 1) & 0xc0) == 0xc0; }$/;"	f	namespace:vm::instr
iter_match_size	vm/instr.hpp	/^const size_t iter_match_size = 2;$/;"	m	namespace:vm::instr
iter_match_val	vm/instr.hpp	/^inline instr_val iter_match_val(iter_match m) { return val_get((pcounter)m, 1); }$/;"	f	namespace:vm::instr
iter_matches_size	vm/instr.hpp	/^iter_matches_size(pcounter pc)$/;"	f	namespace:vm::instr
iter_object	vm/exec.cpp	/^typedef pair<iter_type_t, void*> iter_object;$/;"	t	namespace:vm	file:
iter_options	vm/instr.hpp	/^inline utils::byte iter_options(pcounter pc) { return byte_get(pc, 2); }$/;"	f	namespace:vm::instr
iter_options_argument	vm/instr.hpp	/^inline utils::byte iter_options_argument(pcounter pc) { return byte_get(pc, 3); }$/;"	f	namespace:vm::instr
iter_options_min	vm/instr.hpp	/^inline bool iter_options_min(const utils::byte b) { return b & 0x04; }$/;"	f	namespace:vm::instr
iter_options_min_arg	vm/instr.hpp	/^inline field_num iter_options_min_arg(const utils::byte b) { return (field_num)b; }$/;"	f	namespace:vm::instr
iter_options_random	vm/instr.hpp	/^inline bool iter_options_random(const utils::byte b) { return b & 0x01; }$/;"	f	namespace:vm::instr
iter_options_to_delete	vm/instr.hpp	/^inline bool iter_options_to_delete(const utils::byte b) { return b & 0x02; }$/;"	f	namespace:vm::instr
iter_predicate	vm/instr.hpp	/^inline predicate_id iter_predicate(pcounter pc) { return predicate_get(pc, 1); }$/;"	f	namespace:vm::instr
iter_type_t	vm/exec.cpp	/^} iter_type_t;$/;"	t	namespace:vm	typeref:enum:vm::__anon8	file:
iterate_static_nodes	sched/common.hpp	/^#define iterate_static_nodes(/;"	d
iteration	sched/base.hpp	/^   size_t iteration;$/;"	m	class:sched::base
iterator	db/agg_configuration.hpp	/^   typedef tuple_trie::iterator iterator;$/;"	t	class:db::agg_configuration
iterator	db/trie.hpp	/^   typedef agg_trie_iterator iterator;$/;"	t	class:db::agg_trie
iterator	db/trie.hpp	/^   typedef tuple_trie_iterator iterator;$/;"	t	class:db::tuple_trie
jQuery.fn.message	client/springyui.js	/^jQuery.fn.message = function (from, to, content) {$/;"	f
jQuery.fn.springy	client/springyui.js	/^jQuery.fn.springy = function(params, node_selected, node_dblclicked) {$/;"	f
jQuery.fn.springy.intersect_line_box	client/springyui.js	/^	function intersect_line_box(p1, p2, p3, w, h) {$/;"	f
jQuery.fn.springy.intersect_line_box.tl.x	client/springyui.js	/^		var tl = {x: p3.x, y: p3.y};$/;"	p
jQuery.fn.springy.intersect_line_line	client/springyui.js	/^	function intersect_line_line(p1, p2, p3, p4) {$/;"	f
jQuery.fn.springy.targetBB.bottomleft	client/springyui.js	/^	var targetBB = {bottomleft: new Vector(-2, -2), topright: new Vector(2, 2)};$/;"	p
jQuery.fn.springyUpdate	client/springyui.js	/^jQuery.fn.springyUpdate = function () {$/;"	f
join	sched/base.hpp	/^	inline void join(void) { thread->join(); }$/;"	f	class:sched::base
jump_get	vm/instr.hpp	/^inline code_offset_t jump_get(pcounter x, size_t off) { return pcounter_code_size(x + off); }$/;"	f	namespace:vm::instr
jump_size	vm/instr.hpp	/^const size_t jump_size = 4;$/;"	m	namespace:vm::instr
last	scripts/generate_random_shortest_path.py	/^	last = last + 1$/;"	v
last	scripts/generate_random_shortest_path.py	/^last = 3$/;"	v
last_leaf	db/trie.hpp	/^   trie_leaf *last_leaf;$/;"	m	class:db::trie
leader_thread	sched/base.hpp	/^   inline bool leader_thread(void) const { return get_id() == 0; }$/;"	f	class:sched::base
leaves	queue/bounded_pqueue.hpp	/^		const leaves_vector *leaves;$/;"	m	class:queue::bounded_pqueue::const_iterator
leaves	queue/bounded_pqueue.hpp	/^   leaves_vector leaves;$/;"	m	class:queue::bounded_pqueue
leaves_for_deletion	vm/state.hpp	/^	std::list< std::pair<vm::predicate*, db::tuple_trie_leaf*> > leaves_for_deletion;$/;"	m	class:vm::state
leaves_vector	queue/bounded_pqueue.hpp	/^	typedef std::vector<tree_node*> leaves_vector;$/;"	t	class:queue::bounded_pqueue
left	queue/bounded_pqueue.hpp	/^   tree_node *parent, *left, *right;$/;"	m	class:queue::queue_tree_node
length	runtime/list.hpp	/^	size_t length(const list_ptr ls)$/;"	f	class:runtime::cons
lenvec	scripts/generate_grid.py	/^lenvec = arg.split('@', 2)$/;"	v
letter	scripts/transform_letter_data.py	/^	letter = row[0]$/;"	v
level	vm/predicate.hpp	/^   strat_level level;$/;"	m	class:vm::predicate
levels	scripts/generate_binary_tree.py	/^levels = int(sys.argv[1])$/;"	v
line	scripts/plots/active_inactive.py	/^	line = line.rstrip('\\n')$/;"	v
linear_tuple_can_be_used	vm/state.cpp	/^state::linear_tuple_can_be_used(db::tuple_trie_leaf *leaf) const$/;"	f	class:vm::state
lines	scripts/plots/active_inactive.py	/^lines = fp.readlines()[1:]$/;"	v
link	scripts/generate_shortest_path.py	/^			link = (link + 1) % (total - 1)$/;"	v
link	scripts/generate_shortest_path.py	/^		link = random.randint(1, total - 1)$/;"	v
links	scripts/generate_random_shortest_path.py	/^links = []$/;"	v
links	scripts/generate_shortest_path.py	/^	links = random.randint(1, int(total*0.75))$/;"	v
list_has	scripts/generate_random_graph.py	/^def list_has(list, x):$/;"	f
list_has	scripts/generate_shortest_path.py	/^def list_has(list, x):$/;"	f
list_linear	vm/state.hpp	/^   typedef std::list<pair_linear> list_linear;$/;"	t	class:vm::state
list_ptr	runtime/list.hpp	/^   typedef cons* list_ptr;$/;"	t	class:runtime::cons
list_slices	stat/slice_set.hpp	/^   typedef std::list<slice> list_slices;$/;"	t	class:statistics::slice_set
listenfd	mock-simulator/simulator.cpp	/^static int listenfd, connfd;$/;"	v	file:
load	vm/tuple.cpp	/^tuple::load(byte *buf, const size_t buf_size, int *pos)$/;"	f	class:vm::tuple
load_file_error	vm/program.hpp	/^    explicit load_file_error(const std::string& filename, const std::string& reason) :$/;"	f	class:vm::load_file_error
load_file_error	vm/program.hpp	/^class load_file_error : public std::runtime_error {$/;"	c	namespace:vm
local_level	vm/predicate.hpp	/^      strat_level local_level;$/;"	m	struct:vm::predicate::__anon11
local_tuples	vm/state.hpp	/^   db::simple_tuple_list local_tuples; \/\/ current available tuples not yet in the database$/;"	m	class:vm::state
locally_generated	process/work.hpp	/^   inline bool locally_generated(void) const { return mod & mods::LOCAL_TUPLE; }$/;"	f	class:process::node_work
lock	sched/thread/threaded.hpp	/^	utils::spinlock lock;$/;"	m	class:sched::threaded
lock	utils/spinlock.hpp	/^   inline void lock(void)$/;"	f	class:utils::spinlock
lookup_external_function	vm/external.cpp	/^lookup_external_function(const external_function_id id)$/;"	f	namespace:vm
lookup_serial_result	scripts/csv_benchmarks.py	/^def lookup_serial_result(name):$/;"	f
lookup_serial_result	scripts/lib_csv.py	/^def lookup_serial_result(name):$/;"	f
loop	sched/base.cpp	/^base::loop(void)$/;"	f	class:sched::base
loop_sched	tests/test.sh	/^loop_sched ()$/;"	f
lowestxinner	scripts/heat_color.py	/^			lowestxinner = x$/;"	v
lowestxinner	scripts/heat_color.py	/^lowestxinner = None$/;"	v
lowestxinner	scripts/heat_count_color.py	/^			lowestxinner = x$/;"	v
lowestxinner	scripts/heat_count_color.py	/^lowestxinner = None$/;"	v
lowestyinner	scripts/heat_color.py	/^			lowestyinner = y$/;"	v
lowestyinner	scripts/heat_color.py	/^lowestyinner = None$/;"	v
lowestyinner	scripts/heat_count_color.py	/^			lowestyinner = y$/;"	v
lowestyinner	scripts/heat_count_color.py	/^lowestyinner = None$/;"	v
machine	process/machine.cpp	/^machine::machine(const string& file, const size_t th,$/;"	f	class:process::machine
machine	process/machine.hpp	/^class machine$/;"	c	namespace:process
machine_arguments	vm/all.hpp	/^typedef std::vector<std::string> machine_arguments;$/;"	t	namespace:vm
machine_error	process/machine.hpp	/^    explicit machine_error(const std::string& msg) :$/;"	f	class:process::machine_error
machine_error	process/machine.hpp	/^class machine_error : public std::runtime_error {$/;"	c	namespace:process
main	meld.cpp	/^main(int argc, char **argv)$/;"	f
main	mock-simulator/simulator.cpp	/^main(int argc, char **argv)$/;"	f
main	mpi/test.cpp	/^int main(int argc, char* argv[])$/;"	f
main	mpi/tutorial.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	predicates.cpp	/^main(int argc, char **argv)$/;"	f
main	print.cpp	/^main(int argc, char **argv)$/;"	f
main	sched/mpi.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	server.cpp	/^main(int argc, char **argv)$/;"	f
make_default_string	runtime/string.hpp	/^	static rstring_ptr make_default_string(const std::string& str)$/;"	f	class:runtime::rstring
make_efficiency	scripts/csv_benchmarks.py	/^def make_efficiency(time, serial, cpu):$/;"	f
make_predicate_from_buf	vm/predicate.cpp	/^predicate::make_predicate_from_buf(byte *buf, code_size_t *code_size, const predicate_id id)$/;"	f	class:vm::predicate
make_speedup	scripts/csv_benchmarks.py	/^def make_speedup(time, serial):$/;"	f
make_string	runtime/string.hpp	/^	static rstring_ptr make_string(const std::string& str)$/;"	f	class:runtime::rstring
malformed_instr_error	vm/instr.hpp	/^    explicit malformed_instr_error(const std::string& msg) :$/;"	f	class:vm::instr::malformed_instr_error
malformed_instr_error	vm/instr.hpp	/^class malformed_instr_error : public std::runtime_error {$/;"	c	namespace:vm::instr
man	ui/manager.cpp	/^manager *man;$/;"	m	namespace:ui	file:
manager	ui/manager.cpp	/^manager::manager(void):$/;"	f	class:ui::manager
manager	ui/manager.hpp	/^class manager: public websocketpp::server::handler$/;"	c	namespace:ui
many	db/trie.hpp	/^      vm::ref_count many;$/;"	m	class:db::trie::delete_info
map_nodes	db/database.hpp	/^           mem::allocator< std::pair<const node::node_id, node*> > > map_nodes;$/;"	t	class:db::database
map_translate	db/database.hpp	/^           mem::allocator< std::pair<const node::node_id, node::node_id> > > map_translate;$/;"	t	class:db::database
mark_active_rules	vm/state.cpp	/^state::mark_active_rules(void)$/;"	f	class:vm::state
mark_predicate_rules	vm/state.cpp	/^state::mark_predicate_rules(const predicate *pred)$/;"	f	class:vm::state
mark_predicate_to_run	vm/state.cpp	/^state::mark_predicate_to_run(const predicate *pred)$/;"	f	class:vm::state
mark_rules_using_local_tuples	vm/state.cpp	/^state::mark_rules_using_local_tuples(db::simple_tuple_list& ls)$/;"	f	class:vm::state
master_get_work	sched/sim.cpp	/^sim_sched::master_get_work(void)$/;"	f	class:sched::sim_sched
master_get_work	sched/sim_tcp.cpp	/^sim_sched::master_get_work(void)$/;"	f	class:sched::sim_sched
match	db/trie.cpp	/^trie_node::match(const tuple_field& field, const field_type& typ,$/;"	f	class:db::trie_node
match	vm/match.hpp	/^   explicit match(const predicate *pred):$/;"	f	class:vm::match
match	vm/match.hpp	/^class match: public mem::base$/;"	c	namespace:vm
match_field	vm/match.hpp	/^struct match_field {$/;"	s	namespace:vm
match_float	vm/match.hpp	/^   inline void match_float(const field_num& num, const float_val val) {$/;"	f	class:vm::match
match_int	vm/match.hpp	/^   inline void match_int(const field_num& num, const int_val val) {$/;"	f	class:vm::match
match_node	vm/match.hpp	/^   inline void match_node(const field_num& num, const node_val val) {$/;"	f	class:vm::match
match_predicate	db/node.cpp	/^node::match_predicate(const predicate_id id, const match& m, tuple_vector& vec) const$/;"	f	class:db::node
match_predicate	db/node.cpp	/^node::match_predicate(const predicate_id id, tuple_vector& vec) const$/;"	f	class:db::node
match_predicate	db/trie.cpp	/^tuple_trie::match_predicate(const match& m, tuple_vector& vec) const$/;"	f	class:db::tuple_trie
match_predicate	db/trie.cpp	/^tuple_trie::match_predicate(tuple_vector& vec) const$/;"	f	class:db::tuple_trie
match_serial	interface.cpp	/^match_serial(const char *name, char *arg, const scheduler_type type)$/;"	f	file:
match_type_stack	vm/match.hpp	/^typedef utils::stack<match_field> match_type_stack;$/;"	t	namespace:vm
match_val_stack	vm/match.hpp	/^typedef val_stack match_val_stack;$/;"	t	namespace:vm
matcher	db/node.hpp	/^	vm::rule_matcher matcher;$/;"	m	class:db::node
matches_first_int_arg	db/agg_configuration.cpp	/^agg_configuration::matches_first_int_arg(const int_val val) const$/;"	f	class:db::agg_configuration
math	scripts/heat_color.py	/^import math$/;"	i
math	scripts/heat_count_color.py	/^import math$/;"	i
math	scripts/plots/active_inactive.py	/^import math$/;"	i
max_id	db/database.hpp	/^   node::node_id max_id(void) const { return max_node_id; }$/;"	f	class:db::database
max_length	mock-simulator/simulator.cpp	/^const int max_length = 512 \/ sizeof(message_type);$/;"	v
max_node_id	db/database.hpp	/^   node::node_id max_node_id;$/;"	m	class:db::database
max_size	mem/allocator.hpp	/^   inline size_type max_size() const {$/;"	f	class:mem::allocator
max_translated_id	db/database.hpp	/^   node::node_id max_translated_id;$/;"	m	class:db::database
max_val	utils/interval.hpp	/^   T max_val;$/;"	m	class:utils::interval
maxcount	scripts/heat_count_color.py	/^		maxcount = total$/;"	v
maxcount	scripts/heat_count_color.py	/^maxcount = 0$/;"	v
maxheat	scripts/heat_color.py	/^		maxheat = heat$/;"	v
maxheat	scripts/heat_color.py	/^maxheat = 0$/;"	v
maxqueue	scripts/plots/active_inactive.py	/^maxqueue = 0$/;"	v
maxx	scripts/heat_color.py	/^		maxx = x$/;"	v
maxx	scripts/heat_color.py	/^maxx = 0$/;"	v
maxx	scripts/heat_count_color.py	/^		maxx = x$/;"	v
maxx	scripts/heat_count_color.py	/^maxx = 0$/;"	v
maxy	scripts/heat_color.py	/^		maxy = y$/;"	v
maxy	scripts/heat_color.py	/^maxy = 0$/;"	v
maxy	scripts/heat_count_color.py	/^		maxy = y$/;"	v
maxy	scripts/heat_count_color.py	/^maxy = 0$/;"	v
mem	docs/vm.tex	/^\\subsection{mem}$/;"	b
mem	mem/allocator.hpp	/^namespace mem$/;"	n
mem	mem/base.hpp	/^namespace mem$/;"	n
mem	mem/center.cpp	/^namespace mem$/;"	n	file:
mem	mem/center.hpp	/^namespace mem$/;"	n
mem	mem/chunk.hpp	/^namespace mem$/;"	n
mem	mem/chunkgroup.hpp	/^namespace mem$/;"	n
mem	mem/pool.hpp	/^namespace mem$/;"	n
mem	mem/stat.cpp	/^namespace mem$/;"	n	file:
mem	mem/stat.hpp	/^namespace mem$/;"	n
mem	mem/thread.cpp	/^namespace mem$/;"	n	file:
mem	mem/thread.hpp	/^namespace mem$/;"	n
mem_node	mem/chunkgroup.hpp	/^   struct mem_node {$/;"	s	class:mem::chunkgroup
mem_set	mem/thread.cpp	/^unordered_set<void*> mem_set;$/;"	v
mem_size	queue/node.hpp	/^   virtual size_t mem_size(void) const { return 8; }$/;"	f	class:queue::unsafe_queue_node
memory_statistics	interface.cpp	/^bool memory_statistics = false;$/;"	v
message_ptr	ui/manager.hpp	/^      typedef websocketpp::message::data_ptr message_ptr;$/;"	t	class:ui::manager
message_type	mock-simulator/simulator.cpp	/^typedef uint64_t message_type;$/;"	t	file:
message_type	sched/mpi.hpp	/^	typedef uint64_t message_type;$/;"	t	class:sched::mpi_sched
message_type	sched/sim.hpp	/^	typedef uint64_t message_type;$/;"	t	class:sched::sim_sched
milliseconds	utils/time.hpp	/^   inline size_t milliseconds(void) const { return dur.total_milliseconds(); }$/;"	f	class:utils::execution_time
min_val	utils/interval.hpp	/^   T min_val;$/;"	m	class:utils::interval
min_value	queue/safe_complex_pqueue.hpp	/^	heap_priority min_value(void) const$/;"	f	class:queue::intrusive_safe_complex_pqueue
mkdir_p	scripts/lib_csv.py	/^def mkdir_p(path):$/;"	f
mod	process/work.hpp	/^   work_modifier mod;$/;"	m	class:process::node_work
mods	process/work.hpp	/^namespace mods$/;"	n	namespace:process
move_from	vm/instr.hpp	/^inline instr_val move_from(pcounter pc) { return val_get(pc, 1); }$/;"	f	namespace:vm::instr
move_nil_dest	vm/instr.hpp	/^inline instr_val move_nil_dest(pcounter pc) { return val_get(pc, 1); }$/;"	f	namespace:vm::instr
move_node	queue/safe_complex_pqueue.hpp	/^	void move_node(heap_object node, const heap_priority new_prio)$/;"	f	class:queue::intrusive_safe_complex_pqueue
move_to	vm/instr.hpp	/^inline instr_val move_to(pcounter pc) { return val_get(pc, 2); }$/;"	f	namespace:vm::instr
move_to_const	vm/exec.cpp	/^move_to_const(pcounter m, state& state, const instr_val& from)$/;"	f	namespace:vm
move_to_field	vm/exec.cpp	/^move_to_field(pcounter m, state& state, const instr_val& from)$/;"	f	namespace:vm
move_to_reg	vm/exec.cpp	/^move_to_reg(const pcounter& m, state& state,$/;"	f	namespace:vm
move_up	queue/safe_double_queue.hpp	/^   inline void move_up(node_type node)$/;"	f	class:queue::intrusive_safe_double_queue
move_up	queue/unsafe_double_queue.hpp	/^   inline void move_up(node_type node)$/;"	f	class:queue::intrusive_unsafe_double_queue
moving_around	sched/nodes/thread_intrusive.hpp	/^   bool moving_around;$/;"	m	class:sched::thread_intrusive_node
mpi	sched/mpi.cpp	/^    class mpi {$/;"	c	namespace:sched	file:
mpi_sched	sched/mpi.hpp	/^class mpi_sched: public sched::base$/;"	c	namespace:sched
mtx	db/database.hpp	/^	utils::spinlock mtx;$/;"	m	class:db::database
mtx	queue/safe_double_queue.hpp	/^	utils::spinlock mtx;$/;"	m	class:queue::intrusive_safe_double_queue
mtx	queue/safe_linear_queue.hpp	/^	utils::spinlock mtx;$/;"	m	class:queue::safe_linear_queue
mtx	sched/thread/assert.cpp	/^static mutex mtx;$/;"	m	namespace:sched	file:
must_be_deleted	db/tuple.hpp	/^   inline bool must_be_deleted(void) const$/;"	f	class:db::simple_tuple
my_round	scripts/csv_benchmarks.py	/^def my_round(time):$/;"	f
name	scripts/check_coloring.py	/^		name = d['name']$/;"	v
name	scripts/count_db_total.py	/^		name = d['name']$/;"	v
name	vm/predicate.hpp	/^   std::string name;$/;"	m	class:vm::predicate
natural_dict_sort	scripts/lib_csv.py	/^def natural_dict_sort(dic):$/;"	f
neighbor_agg_configuration	db/neighbor_agg_configuration.hpp	/^   explicit neighbor_agg_configuration(const vm::predicate *_pred, const edge_set& _target):$/;"	f	class:db::neighbor_agg_configuration
neighbor_agg_configuration	db/neighbor_agg_configuration.hpp	/^class neighbor_agg_configuration: public agg_configuration$/;"	c	namespace:db
neighbor_count	sched/nodes/sim.hpp	/^   size_t neighbor_count;$/;"	m	class:sched::sim_node
neighbor_count_pred	sched/mpi.hpp	/^	static vm::predicate *neighbor_count_pred;$/;"	m	class:sched::mpi_sched
neighbor_count_pred	sched/sim.hpp	/^	static vm::predicate *neighbor_count_pred;$/;"	m	class:sched::sim_sched
neighbor_pred	sched/mpi.hpp	/^	static vm::predicate *neighbor_pred;$/;"	m	class:sched::mpi_sched
neighbor_pred	sched/sim.hpp	/^	static vm::predicate *neighbor_pred;$/;"	m	class:sched::sim_sched
neighbor_tuple_aggregate	db/neighbor_tuple_aggregate.hpp	/^   explicit neighbor_tuple_aggregate(const vm::predicate *_pred, const edge_set& _neis):$/;"	f	class:db::neighbor_tuple_aggregate
neighbor_tuple_aggregate	db/neighbor_tuple_aggregate.hpp	/^class neighbor_tuple_aggregate: public tuple_aggregate$/;"	c	namespace:db
neighbors	db/neighbor_tuple_aggregate.hpp	/^   edge_set neighbors;$/;"	m	class:db::neighbor_tuple_aggregate
neighbors	scripts/check_coloring.py	/^neighbors = {}$/;"	v
new	scripts/generate_chain.py	/^	new = i$/;"	v
new	scripts/generate_cycle.py	/^	new = i$/;"	v
new	scripts/generate_heat_chain.py	/^		new = i $/;"	v
new	scripts/generate_heat_chain.py	/^		new = i$/;"	v
new_agg	sched/serial.cpp	/^serial_local::new_agg(work& w)$/;"	f	class:sched::serial_local
new_agg	sched/sim.cpp	/^sim_sched::new_agg(work& w)$/;"	f	class:sched::sim_sched
new_agg	sched/sim_tcp.cpp	/^sim_sched::new_agg(work& w)$/;"	f	class:sched::sim_sched
new_axioms_jump	vm/instr.hpp	/^inline code_offset_t new_axioms_jump(const pcounter pc) { return jump_get(pc, 1); }$/;"	f	namespace:vm::instr
new_chunk	mem/chunkgroup.hpp	/^   chunk *new_chunk; \/\/ chunk with readily usable objects$/;"	m	class:mem::chunkgroup
new_node_reg	vm/instr.hpp	/^inline reg_num new_node_reg(const pcounter pc) { return reg_get(pc, 1); }$/;"	f	namespace:vm::instr
new_tuple	vm/program.cpp	/^program::new_tuple(const predicate_id& id) const$/;"	f	class:vm::program
new_work	sched/serial.cpp	/^serial_local::new_work(const node *, work& new_work)$/;"	f	class:sched::serial_local
new_work	sched/sim.cpp	/^sim_sched::new_work(const node *_src, work& new_work)$/;"	f	class:sched::sim_sched
new_work	sched/sim_tcp.cpp	/^sim_sched::new_work(const node *_src, work& new_work)$/;"	f	class:sched::sim_sched
new_work_agg	sched/base.hpp	/^   inline void new_work_agg(db::node *node, db::simple_tuple *stpl)$/;"	f	class:sched::base
new_work_delay	sched/base.hpp	/^   virtual void new_work_delay(sched::base *, const db::node *, process::work&, const vm::uint_val)$/;"	f	class:sched::base
new_work_delay	sched/sim.cpp	/^sim_sched::new_work_delay(sched::base *target, const db::node *_src, work& new_work, const uint_val delay)$/;"	f	class:sched::sim_sched
new_work_delay	sched/sim_tcp.cpp	/^sim_sched::new_work_delay(sched::base *target, const db::node *_src, work& new_work, const uint_val delay)$/;"	f	class:sched::sim_sched
new_work_other	sched/mpi.hpp	/^   virtual void new_work_other(base *, process::work&)$/;"	f	class:sched::mpi_sched
new_work_other	sched/serial.hpp	/^   virtual void new_work_other(sched::base *, process::work&)$/;"	f	class:sched::serial_local
new_work_other	sched/sim.hpp	/^   virtual void new_work_other(base *, process::work&)$/;"	f	class:sched::sim_sched
new_work_remote	sched/mpi.hpp	/^   virtual void new_work_remote(process::remote *, const db::node::node_id, message *)$/;"	f	class:sched::mpi_sched
new_work_remote	sched/sim.hpp	/^   virtual void new_work_remote(process::remote *, const db::node::node_id, message *)$/;"	f	class:sched::sim_sched
new_work_self	sched/base.hpp	/^   inline void new_work_self(db::node *node, db::simple_tuple *stpl, const process::work_modifier mod = process::mods::NOTHING)$/;"	f	class:sched::base
next	db/trie.hpp	/^   trie_leaf *next;$/;"	m	class:db::trie_leaf
next	db/trie.hpp	/^   trie_node *next;$/;"	m	class:db::trie_node
next	mem/chunkgroup.hpp	/^      struct mem_node *next;$/;"	m	struct:mem::chunkgroup::mem_node	typeref:struct:mem::chunkgroup::mem_node::mem_node
next	queue/node.hpp	/^   unsafe_queue_node *next;$/;"	m	class:queue::unsafe_queue_node
next	queue/node.hpp	/^   volatile queue_node *next;$/;"	m	class:queue::queue_node
next	queue/safe_linear_queue.hpp	/^   utils::atomic_ref<special_queue_node*> next;$/;"	m	class:queue::special_queue_node
next_chunk	mem/chunk.hpp	/^   chunk *next_chunk;$/;"	m	class:mem::chunk
next_node	db/trie.cpp	/^   trie_node *next_node;$/;"	m	struct:db::continuation_frame	file:
next_power2	utils/utils.hpp	/^T next_power2(const T val)$/;"	f	namespace:utils
nexttimestamps	mock-simulator/simulator.cpp	/^static vector<int> nexttimestamps; \/\/ what the next timestamp should be$/;"	v	file:
nil_size	vm/instr.hpp	/^const size_t nil_size = 0;$/;"	m	namespace:vm::instr
no_changes	db/tuple_aggregate.cpp	/^tuple_aggregate::no_changes(void) const$/;"	f	class:db::tuple_aggregate
no_clients	ui/manager.hpp	/^		bool no_clients(void) const { return num_clients() == 0; }$/;"	f	class:ui::manager
no_longer_using_linear_tuple	vm/state.cpp	/^state::no_longer_using_linear_tuple(db::tuple_trie_leaf *leaf)$/;"	f	class:vm::state
node	db/node.cpp	/^node::node(const node_id _id, const node_id _trans, vm::all *_all):$/;"	f	class:db::node
node	db/node.hpp	/^class node: public mem::base$/;"	c	namespace:db
node	db/trie.hpp	/^   trie_node *node;$/;"	m	class:db::trie_leaf
node	db/trie.hpp	/^   typedef trie_node node;$/;"	t	class:db::trie
node	process/work.hpp	/^   db::node *node;$/;"	m	class:process::work
node	queue/safe_linear_queue.hpp	/^   typedef queue_node<T> node;$/;"	t	class:queue::push_safe_linear_queue
node	queue/safe_linear_queue.hpp	/^   typedef queue_node<T> node;$/;"	t	class:queue::safe_linear_queue
node	scripts/generate_random_shortest_path.py	/^	node = random.randint(1, last)$/;"	v
node	utils/tree_barrier.hpp	/^   inner_node **node;$/;"	m	class:utils::tree_barrier
node	vm/state.hpp	/^   db::node *node;$/;"	m	class:vm::state
node1	scripts/generate_random_shortest_path.py	/^	node1 = random.randint(1, last)$/;"	v
node2	scripts/generate_random_shortest_path.py	/^	node2 = random.randint(1, last)$/;"	v
node_field	vm/defs.hpp	/^	node_val node_field;$/;"	m	union:vm::__anon7
node_id	db/node.hpp	/^   typedef vm::node_val node_id;$/;"	t	class:db::node
node_iteration	sched/base.hpp	/^   inline void node_iteration(db::node *node)$/;"	f	class:sched::base
node_list	runtime/list.hpp	/^typedef cons<vm::node_val> node_list;$/;"	t	namespace:runtime
node_size	db/database.hpp	/^   static const size_t node_size = sizeof(node::node_id) * 2;$/;"	m	class:db::database
node_size	vm/instr.hpp	/^const size_t node_size = sizeof(node_val);$/;"	m	namespace:vm::instr
node_val	vm/defs.hpp	/^typedef uint32_t node_val;$/;"	t	namespace:vm
node_work	process/work.hpp	/^   explicit node_work(db::simple_tuple *_tuple):$/;"	f	class:process::node_work
node_work	process/work.hpp	/^   explicit node_work(db::simple_tuple *_tuple, const work_modifier _mod):$/;"	f	class:process::node_work
node_work	process/work.hpp	/^   explicit node_work(void):$/;"	f	class:process::node_work
node_work	process/work.hpp	/^class node_work \/* XXX: make it forbidden to do new\/delete *\/$/;"	c	namespace:process
nodes	db/database.hpp	/^   map_nodes nodes;$/;"	m	class:db::database
nodes	scripts/generate_heat_chain.py	/^nodes = int(sys.argv[1])$/;"	v
nodes	scripts/generate_random_shortest_path.py	/^nodes = [1, 2, 3, 4]$/;"	v
nodes_begin	db/database.hpp	/^   map_nodes::const_iterator nodes_begin(void) const { return nodes.begin(); }$/;"	f	class:db::database
nodes_end	db/database.hpp	/^   map_nodes::const_iterator nodes_end(void) const { return nodes.end(); }$/;"	f	class:db::database
nodes_total	db/database.hpp	/^   size_t nodes_total;$/;"	m	class:db::database
north	sched/nodes/sim.hpp	/^   vm::node_val north;$/;"	m	class:sched::sim_node
north_neighbors	mock-simulator/simulator.cpp	/^static vector<int> north_neighbors, south_neighbors;$/;"	v	file:
not_dest	vm/instr.hpp	/^inline instr_val not_dest(pcounter pc) { return val_get(pc, 2); }$/;"	f	namespace:vm::instr
not_op	vm/instr.hpp	/^inline instr_val not_op(pcounter pc) { return val_get(pc, 1); }$/;"	f	namespace:vm::instr
null_list	runtime/list.hpp	/^   static inline list_ptr null_list(void) { return (list_ptr)0; }$/;"	f	class:runtime::cons
null_ptr_val	vm/defs.hpp	/^static const ptr_val null_ptr_val = 0;$/;"	m	namespace:vm
num_active	sched/thread/termination_barrier.hpp	/^   inline size_t num_active(void) const { return active_threads; }$/;"	f	class:sched::termination_barrier
num_active	sched/thread/threaded.hpp	/^   static inline size_t num_active(void) { return term_barrier->num_active(); }$/;"	f	class:sched::threaded
num_args	vm/external.hpp	/^   const size_t num_args;$/;"	m	class:vm::external_function
num_args	vm/program.hpp	/^	size_t num_args;$/;"	m	class:vm::program
num_args_needed	vm/program.hpp	/^	inline size_t num_args_needed(void) const { return num_args; }$/;"	f	class:vm::program
num_buckets	db/trie.hpp	/^   size_t num_buckets;$/;"	m	class:db::trie_hash
num_clients	ui/manager.hpp	/^      size_t num_clients(void) const { return clients.size(); }$/;"	f	class:ui::manager
num_cpus_available	interface.cpp	/^num_cpus_available(void)$/;"	f	file:
num_elems_per_chunk	mem/chunkgroup.hpp	/^   size_t num_elems_per_chunk;$/;"	m	class:mem::chunkgroup
num_fields	vm/predicate.hpp	/^   inline size_t num_fields(void) const { return types.size(); }$/;"	f	class:vm::predicate
num_fields	vm/tuple.hpp	/^   size_t num_fields(void) const { return pred->num_fields(); }$/;"	f	class:vm::tuple
num_hidden	scripts/generate_neural_network.py	/^num_hidden = int(sys.argv[2])$/;"	v
num_input	scripts/generate_neural_network.py	/^num_input = int(sys.argv[1])$/;"	v
num_iterations	sched/base.hpp	/^   inline size_t num_iterations(void) const { return iteration; }$/;"	f	class:sched::base
num_nodes	db/database.hpp	/^   size_t num_nodes(void) const { return nodes.size(); }$/;"	f	class:db::database
num_nodes	utils/tree_barrier.hpp	/^   size_t num_nodes;$/;"	m	class:utils::tree_barrier
num_output	scripts/generate_neural_network.py	/^num_output = int(sys.argv[3])$/;"	v
num_predicates	vm/program.hpp	/^   size_t num_predicates(void) const { return predicates.size(); }$/;"	f	class:vm::program
num_predicates	vm/rule.hpp	/^		inline size_t num_predicates(void) const { return predicates.size(); }$/;"	f	class:vm::rule
num_route_predicates	vm/program.hpp	/^   size_t num_route_predicates(void) const { return route_predicates.size(); }$/;"	f	class:vm::program
num_rules	vm/program.hpp	/^   inline size_t num_rules(void) const { return number_rules; }$/;"	f	class:vm::program
num_slices	stat/slice_set.hpp	/^   size_t num_slices;$/;"	m	class:statistics::slice_set
num_threads	interface.cpp	/^size_t num_threads = 0;$/;"	v
num_threads	sched/thread/termination_barrier.hpp	/^   const size_t num_threads;$/;"	m	class:sched::termination_barrier
num_threads	scripts/plots/state_totals.py	/^      num_threads = len(vec)-2$/;"	v
num_threads	scripts/plots/state_totals.py	/^num_threads = 0$/;"	v
number_cpus	utils/utils.cpp	/^number_cpus(void)$/;"	f	namespace:utils
number_of_references	db/trie.hpp	/^   int number_of_references;$/;"	m	class:db::trie
number_rules	vm/program.hpp	/^   size_t number_rules;$/;"	m	class:vm::program
numcolumns	scripts/plots/active_inactive.py	/^numcolumns = 0$/;"	v
numsinks	scripts/generate_powergrid.py	/^numsinks = int(sys.argv[1])$/;"	v
numsources	scripts/generate_powergrid.py	/^numsources = int(sys.argv[2])$/;"	v
numthreads	scripts/generate_heat_grid.py	/^	numthreads = 1$/;"	v
numthreads	scripts/generate_heat_grid.py	/^	numthreads = int(sys.argv[8])$/;"	v
older	scripts/check_coloring.py	/^				older = colors[node]$/;"	v
on_close	ui/manager.cpp	/^manager::on_close(connection_ptr conn)$/;"	f	class:ui::manager
on_message	ui/manager.cpp	/^manager::on_message(connection_ptr conn, message_ptr msg)$/;"	f	class:ui::manager
on_open	ui/manager.cpp	/^manager::on_open(connection_ptr conn)$/;"	f	class:ui::manager
op_arg1	vm/instr.hpp	/^inline instr_val op_arg1(pcounter pc) { return val_get(pc, 1); }$/;"	f	namespace:vm::instr
op_arg2	vm/instr.hpp	/^inline instr_val op_arg2(pcounter pc) { return val_get(pc, 2); }$/;"	f	namespace:vm::instr
op_dest	vm/instr.hpp	/^inline instr_val op_dest(pcounter pc) { return val_get(pc, 3); }$/;"	f	namespace:vm::instr
op_op	vm/instr.hpp	/^inline instr_op op_op(pcounter pc) { return (instr_op)(*(pc + 4) & 0x1f); }$/;"	f	namespace:vm::instr
op_string	vm/instr.cpp	/^op_string(const instr_op op)$/;"	f	namespace:vm::instr
operator !=	db/trie.hpp	/^   inline bool operator!=(const agg_trie_iterator& it) const { return !operator==(it); }$/;"	f	class:db::agg_trie_iterator
operator !=	db/trie.hpp	/^   inline bool operator!=(const tuple_trie_iterator& it) const { return !operator==(it); }$/;"	f	class:db::tuple_trie_iterator
operator !=	mem/allocator.hpp	/^   inline bool operator!=(allocator const& a) { return !operator==(a); }$/;"	f	class:mem::allocator
operator !=	queue/bounded_pqueue.hpp	/^		inline bool operator!=(const const_iterator& it) const$/;"	f	class:queue::bounded_pqueue::const_iterator
operator !=	queue/safe_simple_pqueue.hpp	/^		operator!=(const const_iterator& it) const$/;"	f	class:queue::heap_queue::const_iterator
operator ()	db/trie.hpp	/^      void operator()(void)$/;"	f	class:db::trie::delete_info
operator ()	queue/safe_general_pqueue.hpp	/^      bool operator() (const queue_item& a, const queue_item& b) {$/;"	f	struct:queue::general_pqueue::queue_item_comparator
operator ()	utils/random.hpp	/^   unsigned operator()(unsigned i) {$/;"	f	class:utils::randgen
operator ()	vm/exec.cpp	/^	inline bool operator()(const iter_object& l1, const iter_object& l2)$/;"	f	class:vm::tuple_sorter
operator *	db/trie.hpp	/^   inline agg_configuration* operator*(void) const$/;"	f	class:db::agg_trie_iterator
operator *	db/trie.hpp	/^   inline simple_tuple* operator*(void) const$/;"	f	class:db::tuple_trie_iterator
operator *	queue/bounded_pqueue.hpp	/^		inline T operator*(void) { return *sub; }$/;"	f	class:queue::bounded_pqueue::const_iterator
operator *	queue/safe_simple_pqueue.hpp	/^		inline T operator*(void)$/;"	f	class:queue::heap_queue::const_iterator
operator ++	db/trie.hpp	/^   inline agg_trie_iterator operator++(int)$/;"	f	class:db::agg_trie_iterator
operator ++	db/trie.hpp	/^   inline agg_trie_iterator& operator++(void)$/;"	f	class:db::agg_trie_iterator
operator ++	db/trie.hpp	/^   inline tuple_trie_iterator operator++(int)$/;"	f	class:db::tuple_trie_iterator
operator ++	db/trie.hpp	/^   inline tuple_trie_iterator& operator++(void)$/;"	f	class:db::tuple_trie_iterator
operator ++	queue/bounded_pqueue.hpp	/^		inline void operator++(void)$/;"	f	class:queue::bounded_pqueue::const_iterator
operator ++	queue/safe_simple_pqueue.hpp	/^		inline void operator++(void)$/;"	f	class:queue::heap_queue::const_iterator
operator ++	sched/nodes/sim.hpp	/^inline face_t operator++(face_t& f, int) {$/;"	f	namespace:sched
operator ++	sched/nodes/sim.hpp	/^inline face_t& operator++(face_t &f)$/;"	f	namespace:sched
operator ++	utils/atomic.hpp	/^   inline T operator++ () {$/;"	f	class:utils::atomic
operator ++	utils/atomic.hpp	/^   inline T operator++ (int) {$/;"	f	class:utils::atomic
operator +=	utils/atomic.hpp	/^   atomic & operator+=(const T val) {$/;"	f	class:utils::atomic
operator --	utils/atomic.hpp	/^   inline T operator-- () {$/;"	f	class:utils::atomic
operator --	utils/atomic.hpp	/^   inline T operator-- (int) {$/;"	f	class:utils::atomic
operator -=	utils/atomic.hpp	/^   atomic& operator-=(const T val) {$/;"	f	class:utils::atomic
operator <<	db/agg_configuration.cpp	/^operator<<(ostream& cout, const agg_configuration& conf)$/;"	f	namespace:db
operator <<	db/database.cpp	/^ostream& operator<<(ostream& cout, const database& db)$/;"	f
operator <<	db/node.cpp	/^operator<<(ostream& cout, const node& node)$/;"	f	namespace:db
operator <<	db/tuple.cpp	/^ostream& operator<<(ostream& cout, const simple_tuple& tuple)$/;"	f	namespace:db
operator <<	db/tuple_aggregate.cpp	/^operator<<(ostream& cout, const tuple_aggregate& agg)$/;"	f	namespace:db
operator <<	utils/csv_line.hpp	/^   operator<<(const std::string& str)$/;"	f	class:utils::csv_line
operator <<	utils/interval.hpp	/^std::ostream& operator<<(std::ostream& cout, const interval<T>& inter)$/;"	f	namespace:utils
operator <<	utils/time.hpp	/^operator<<(std::ostream& cout, const execution_time& t)$/;"	f	namespace:utils
operator <<	vm/predicate.cpp	/^ostream& operator<<(ostream& cout, const predicate& pred)$/;"	f	namespace:vm
operator <<	vm/tuple.cpp	/^ostream& operator<<(ostream& cout, const tuple& tuple)$/;"	f	namespace:vm
operator =	queue/safe_simple_pqueue.hpp	/^		operator=(const const_iterator& it)$/;"	f	class:queue::heap_queue::const_iterator
operator =	utils/atomic.hpp	/^   inline void operator=(const T val)$/;"	f	class:utils::atomic
operator =	utils/atomic.hpp	/^   inline void operator=(volatile T val)$/;"	f	class:utils::atomic_ref
operator ==	db/trie.hpp	/^   inline bool operator==(const agg_trie_iterator& it) const$/;"	f	class:db::agg_trie_iterator
operator ==	db/trie.hpp	/^   inline bool operator==(const tuple_trie_iterator& it) const$/;"	f	class:db::tuple_trie_iterator
operator ==	mem/allocator.hpp	/^   inline bool operator==(allocator const&) { return true; }$/;"	f	class:mem::allocator
operator ==	queue/bounded_pqueue.hpp	/^		inline bool operator==(const const_iterator& it) const$/;"	f	class:queue::bounded_pqueue::const_iterator
operator ==	queue/safe_simple_pqueue.hpp	/^		operator==(const const_iterator& it) const$/;"	f	class:queue::heap_queue::const_iterator
operator ==	vm/tuple.cpp	/^tuple::operator==(const tuple& other) const$/;"	f	class:vm::tuple
operator T	utils/atomic.hpp	/^   inline operator T() const { return get(); }$/;"	f	class:utils::atomic_ref
operator T	utils/atomic.hpp	/^   operator T() const { return elem; }$/;"	f	class:utils::atomic
operator delete	mem/base.hpp	/^   static inline void operator delete(void *ptr, size_t sz)$/;"	f	class:mem::base
operator new	mem/base.hpp	/^   static inline void* operator new(size_t sz)$/;"	f	class:mem::base
original_max_node_id	db/database.hpp	/^   node::node_id original_max_node_id;$/;"	m	class:db::database
os	scripts/csv_benchmarks.py	/^import os$/;"	i
os	scripts/generate_powergrid.py	/^import os$/;"	i
os	scripts/lib_csv.py	/^import os$/;"	i
other	mem/allocator.hpp	/^      typedef allocator<U> other;$/;"	t	struct:mem::allocator::rebind
other	scripts/check_coloring.py	/^							other = colors[edge]$/;"	v
out_file	scripts/csv_step.py	/^out_file = str(sys.argv[2])$/;"	v
outer	utils/tree_barrier.hpp	/^      tree_barrier *outer;$/;"	m	class:utils::tree_barrier::inner_node
outerside	scripts/generate_heat_grid.py	/^outerside = int(sys.argv[2])$/;"	v
outerweight	scripts/generate_heat_grid.py	/^outerweight = float(sys.argv[3])$/;"	v
output	scripts/duplicate_neural_network.py	/^output = sys.argv[2]$/;"	v
output_bench_data	scripts/csv_step.py	/^def output_bench_data(size, serial, w, bench_data):$/;"	f
output_file	scripts/csv_step.py	/^def output_file(outfile):$/;"	f
outputfile	scripts/plots/state_totals.py	/^outputfile = file + ".total"$/;"	v
outsideheat	scripts/generate_heat_grid.py	/^outsideheat = float(sys.argv[7])$/;"	v
owner	db/node.hpp	/^   sched::base *owner;$/;"	m	class:db::node
pack	db/tuple.cpp	/^simple_tuple::pack(byte *buf, const size_t buf_size, int *pos) const$/;"	f	class:db::simple_tuple
pack	runtime/list.hpp	/^	void pack(const list_ptr ptr, utils::byte *buf, const size_t buf_size, int *pos)$/;"	f	class:runtime::cons
pack	utils/serialization.hpp	/^void pack(void *data, const size_t size, byte *buf, const size_t buf_size, int* pos)$/;"	f	namespace:utils
pack	vm/tuple.cpp	/^tuple::pack(byte *buf, const size_t buf_size, int *pos) const$/;"	f	class:vm::tuple
pair_linear	vm/state.hpp	/^   typedef std::pair<db::tuple_trie_leaf *, vm::ref_count> pair_linear;$/;"	t	class:vm::state
parent	db/trie.hpp	/^   trie_node *parent;$/;"	m	class:db::trie_hash
parent	db/trie.hpp	/^   trie_node *parent;$/;"	m	class:db::trie_node
parent	queue/bounded_pqueue.hpp	/^   tree_node *parent, *left, *right;$/;"	m	class:queue::queue_tree_node
parent	utils/tree_barrier.hpp	/^      inner_node *parent;$/;"	m	class:utils::tree_barrier::inner_node
parse_bench_size	scripts/csv_step.py	/^def parse_bench_size(bench):$/;"	f
parse_command	server.cpp	/^parse_command(string cmd)$/;"	f	file:
parse_sched	interface.cpp	/^parse_sched(char *sched)$/;"	f
parse_tuple	scripts/lib_db.py	/^def parse_tuple(data):$/;"	f
pcounter	vm/defs.hpp	/^typedef byte_code pcounter;$/;"	t	namespace:vm
pcounter_argument_id	vm/instr.hpp	/^inline argument_id pcounter_argument_id(const pcounter pc) { return (argument_id)*pc; }$/;"	f	namespace:vm::instr
pcounter_code_size	vm/instr.hpp	/^inline code_size_t pcounter_code_size(const pcounter pc) { return *(code_size_t *)pc; }$/;"	f	namespace:vm::instr
pcounter_const_id	vm/instr.hpp	/^inline const_id pcounter_const_id(const pcounter pc) { return pcounter_uint(pc); }$/;"	f	namespace:vm::instr
pcounter_float	vm/instr.hpp	/^inline float_val pcounter_float(const pcounter pc) { return *(float_val *)pc; }$/;"	f	namespace:vm::instr
pcounter_int	vm/instr.hpp	/^inline int_val pcounter_int(const pcounter pc) { return *(int_val *)pc; }$/;"	f	namespace:vm::instr
pcounter_move_argument_id	vm/instr.hpp	/^inline void pcounter_move_argument_id(pcounter *pc) { *pc = *pc + argument_size; }$/;"	f	namespace:vm::instr
pcounter_move_const_id	vm/instr.hpp	/^inline void pcounter_move_const_id(pcounter *pc) { pcounter_move_uint(pc); }$/;"	f	namespace:vm::instr
pcounter_move_field	vm/instr.hpp	/^inline void pcounter_move_field(pcounter *pc) { *pc = *pc + field_size; }$/;"	f	namespace:vm::instr
pcounter_move_float	vm/instr.hpp	/^inline void pcounter_move_float(pcounter *pc) { *pc = *pc + float_size; }$/;"	f	namespace:vm::instr
pcounter_move_int	vm/instr.hpp	/^inline void pcounter_move_int(pcounter *pc) { *pc = *pc + int_size; }$/;"	f	namespace:vm::instr
pcounter_move_match	vm/instr.hpp	/^inline void pcounter_move_match(pcounter *pc) { *pc = *pc + iter_match_size; }$/;"	f	namespace:vm::instr
pcounter_move_node	vm/instr.hpp	/^inline void pcounter_move_node(pcounter *pc) { *pc = *pc + node_size; }$/;"	f	namespace:vm::instr
pcounter_move_uint	vm/instr.hpp	/^inline void pcounter_move_uint(pcounter *pc) { *pc = *pc + uint_size; }$/;"	f	namespace:vm::instr
pcounter_node	vm/instr.hpp	/^inline node_val pcounter_node(const pcounter pc) { return *(node_val *)pc; }$/;"	f	namespace:vm::instr
pcounter_uint	vm/instr.hpp	/^inline uint_val pcounter_uint(const pcounter pc) { return *(uint_val *)pc; }$/;"	f	namespace:vm::instr
pending	sched/nodes/sim.hpp	/^	queue::push_safe_linear_queue<db::simple_tuple*> pending; \/\/ for threaded computation$/;"	m	class:sched::sim_node
persistent_only	vm/state.hpp	/^   bool persistent_only; \/\/ we are running one persistent tuple (not a rule)$/;"	m	class:vm::state
plot_part	scripts/plots/plot_dir.sh	/^plot_part ()$/;"	f
pointer	mem/allocator.hpp	/^   typedef value_type* pointer;$/;"	t	class:mem::allocator
pool	mem/pool.hpp	/^   explicit pool(void)$/;"	f	class:mem::pool
pool	mem/pool.hpp	/^class pool$/;"	c	namespace:mem
pool_key	mem/thread.cpp	/^static pthread_key_t pool_key;$/;"	m	namespace:mem	file:
pop	queue/bounded_pqueue.hpp	/^   T pop(void)$/;"	f	class:queue::bounded_pqueue
pop	queue/safe_complex_pqueue.hpp	/^	heap_object pop(void)$/;"	f	class:queue::intrusive_safe_complex_pqueue
pop	queue/safe_double_queue.hpp	/^   inline bool pop(node_type& data)$/;"	f	class:queue::intrusive_safe_double_queue
pop	queue/safe_general_pqueue.hpp	/^   inline T pop(void)$/;"	f	class:queue::general_pqueue
pop	queue/safe_linear_queue.hpp	/^   inline T pop(void)$/;"	f	class:queue::push_safe_linear_queue
pop	queue/safe_linear_queue.hpp	/^   inline bool pop(T& data)$/;"	f	class:queue::safe_linear_queue
pop	queue/safe_simple_pqueue.hpp	/^	T pop(void)$/;"	f	class:queue::heap_queue
pop	queue/unsafe_double_queue.hpp	/^   inline bool pop(node_type& data)$/;"	f	class:queue::intrusive_unsafe_double_queue
pop	queue/unsafe_linear_queue.hpp	/^   inline T pop(void)$/;"	f	class:queue::unsafe_linear_queue
pop	queue/unsafe_linear_queue.hpp	/^   inline T pop(void)$/;"	f	class:queue::unsafe_linear_queue_count
pop	sched/thread/steal_set.hpp	/^   inline sched::base *pop(void)$/;"	f	class:sched::steal_set
pop_if_not_empty	queue/safe_double_queue.hpp	/^   inline bool pop_if_not_empty(node_type& data)$/;"	f	class:queue::intrusive_safe_double_queue
pop_if_not_empty	queue/safe_linear_queue.hpp	/^   inline bool pop_if_not_empty(T& data)$/;"	f	class:queue::safe_linear_queue
pop_if_not_empty	queue/unsafe_double_queue.hpp	/^   inline bool pop_if_not_empty(node_type& data)$/;"	f	class:queue::intrusive_unsafe_double_queue
pop_list	queue/safe_linear_queue.hpp	/^	inline void pop_list(std::list<T, Alloc>& vec)$/;"	f	class:queue::push_safe_linear_queue
pop_list	queue/unsafe_linear_queue.hpp	/^	inline void pop_list(std::list<T, Alloc>& vec)$/;"	f	class:queue::unsafe_linear_queue
pop_list	queue/unsafe_linear_queue.hpp	/^	inline void pop_list(std::list<T, Alloc>& vec)$/;"	f	class:queue::unsafe_linear_queue_count
port	server.cpp	/^static int port = 0;$/;"	v	file:
pos	queue/safe_simple_pqueue.hpp	/^		int pos;$/;"	m	class:queue::heap_queue::heap_object
position	scripts/count_db_total.py	/^position = int(sys.argv[2])$/;"	v
power	utils/utils.hpp	/^T power(const T base, const T exp)$/;"	f	namespace:utils
pqueue	mock-simulator/simulator.cpp	/^static vector<int> pqueue; \/\/ nodes scheduled for computation$/;"	v	file:
pred	db/trie.hpp	/^   const vm::predicate *pred;$/;"	m	class:db::tuple_trie
pred	db/tuple_aggregate.hpp	/^   const vm::predicate *pred;$/;"	m	class:db::tuple_aggregate
pred	vm/exec.cpp	/^	const predicate *pred;$/;"	m	class:vm::tuple_sorter	file:
pred	vm/tuple.hpp	/^	predicate* pred;$/;"	m	class:vm::tuple
pred_name	vm/tuple.hpp	/^   std::string pred_name(void) const { return pred->get_name(); }$/;"	f	class:vm::tuple
predicate	scripts/count_db_total.py	/^predicate = sys.argv[1]$/;"	v
predicate	vm/predicate.cpp	/^predicate::predicate(void)$/;"	f	class:vm::predicate
predicate	vm/predicate.hpp	/^class predicate {$/;"	c	namespace:vm
predicate_count	vm/rule_matcher.hpp	/^   std::vector<ref_count> predicate_count; \/* number of tuples per predicate *\/$/;"	m	class:vm::rule_matcher
predicate_get	vm/instr.hpp	/^inline predicate_id predicate_get(pcounter x, size_t off) { return (predicate_id)(*(x + off) & 0x7f); }$/;"	f	namespace:vm::instr
predicate_id	vm/defs.hpp	/^typedef unsigned char predicate_id;$/;"	t	namespace:vm
predicate_iterator	vm/rule.hpp	/^		typedef predicate_vector::const_iterator predicate_iterator;$/;"	t	class:vm::rule
predicate_vector	vm/rule.hpp	/^		typedef std::vector<predicate*> predicate_vector;$/;"	t	class:vm::rule
predicates	vm/program.hpp	/^   std::vector<predicate*> predicates;$/;"	m	class:vm::program
predicates	vm/rule.hpp	/^      predicate_vector predicates;$/;"	m	class:vm::rule
predicates	vm/state.hpp	/^	bool *predicates;$/;"	m	class:vm::state
predicates_to_check	vm/state.hpp	/^	std::vector<vm::predicate*> predicates_to_check;$/;"	m	class:vm::state
prev	db/trie.hpp	/^   trie_leaf *prev;$/;"	m	class:db::trie_leaf
prev	db/trie.hpp	/^   trie_node *prev;$/;"	m	class:db::trie_node
previous	scripts/generate_chain.py	/^	previous = new$/;"	v
previous	scripts/generate_chain.py	/^previous = 0$/;"	v
previous	scripts/generate_cycle.py	/^	previous = new$/;"	v
previous	scripts/generate_cycle.py	/^previous = 0$/;"	v
previous	scripts/generate_heat_chain.py	/^		previous = new$/;"	v
previous	scripts/generate_heat_chain.py	/^		previous = new/;"	v
previous	scripts/generate_heat_chain.py	/^previous = 0$/;"	v
print	db/agg_configuration.cpp	/^agg_configuration::print(ostream& cout) const$/;"	f	class:db::agg_configuration
print	db/database.cpp	/^database::print(ostream& cout) const$/;"	f	class:database
print	db/node.cpp	/^node::print(ostream& cout) const$/;"	f	class:db::node
print	db/trie.cpp	/^tuple_trie::print(ostream& cout) const$/;"	f	class:db::tuple_trie
print	db/tuple.cpp	/^simple_tuple::print(ostream& cout) const$/;"	f	class:db::simple_tuple
print	db/tuple_aggregate.cpp	/^tuple_aggregate::print(ostream& cout) const$/;"	f	class:db::tuple_aggregate
print	queue/safe_complex_pqueue.hpp	/^	void print(std::ostream& out)$/;"	f	class:queue::intrusive_safe_complex_pqueue
print	runtime/list.hpp	/^	void print(std::ostream& cout, list_ptr ls, print_function print)$/;"	f	class:runtime::cons
print	runtime/list.hpp	/^   void print(std::ostream& cout, const bool first, print_function print) const$/;"	f	class:runtime::cons
print	utils/csv_line.hpp	/^   void print(std::ostream& out) const$/;"	f	class:utils::csv_line
print	utils/interval.hpp	/^   void print(std::ostream& cout) const$/;"	f	class:utils::interval
print	utils/time.hpp	/^   void print(std::ostream& cout) const { cout << milliseconds() << "ms"; }$/;"	f	class:utils::execution_time
print	vm/match.hpp	/^   inline void print(std::ostream& cout) const {$/;"	f	class:vm::match
print	vm/predicate.cpp	/^predicate::print(ostream& cout) const$/;"	f	class:vm::predicate
print	vm/rule.cpp	/^rule::print(ostream& out, const vm::program *const prog) const$/;"	f	class:vm::rule
print	vm/tuple.cpp	/^tuple::print(ostream& cout) const$/;"	f	class:vm::tuple
print_byte	utils/types.cpp	/^void print_byte(byte b)$/;"	f	namespace:utils
print_bytecode	vm/program.cpp	/^program::print_bytecode(ostream& out) const$/;"	f	class:vm::program
print_bytecode_by_predicate	vm/program.cpp	/^program::print_bytecode_by_predicate(ostream& out, const string& name) const$/;"	f	class:vm::program
print_clients	ui/manager.cpp	/^manager::print_clients(void) const$/;"	f	class:ui::manager
print_db	db/database.cpp	/^database::print_db(ostream& cout) const$/;"	f	class:database
print_float	vm/tuple.cpp	/^print_float(ostream& out, const float_val val)$/;"	f	namespace:vm
print_function	runtime/list.hpp	/^   typedef void (*print_function)(std::ostream&, const T);$/;"	t	class:runtime::cons
print_instrs	vm/state.hpp	/^	bool print_instrs;$/;"	m	class:vm::state
print_int	vm/tuple.cpp	/^print_int(ostream& out, const int_val val)$/;"	f	namespace:vm
print_neighbors	scripts/check_coloring.py	/^def print_neighbors():$/;"	f
print_node	vm/tuple.cpp	/^print_node(ostream& out, const node_val node)$/;"	f	namespace:vm
print_predicate_code	vm/program.cpp	/^program::print_predicate_code(ostream& out, predicate* p) const$/;"	f	class:vm::program
print_predicates	vm/program.cpp	/^program::print_predicates(ostream& cout) const$/;"	f	class:vm::program
print_priority_queue	stat/slice.cpp	/^slice::print_priority_queue(csv_line& csv) const$/;"	f	class:statistics::slice
print_processed_facts	stat/slice.cpp	/^slice::print_processed_facts(csv_line& csv) const$/;"	f	class:statistics::slice
print_results	scripts/csv_benchmarks.py	/^def print_results():$/;"	f
print_sent_facts	stat/slice.cpp	/^slice::print_sent_facts(csv_line& csv) const$/;"	f	class:statistics::slice
print_simple	vm/predicate.cpp	/^predicate::print_simple(ostream& cout) const$/;"	f	class:vm::predicate
print_state	stat/slice.cpp	/^slice::print_state(csv_line& csv) const$/;"	f	class:statistics::slice
print_steal_requests	stat/slice.cpp	/^slice::print_steal_requests(csv_line& csv) const$/;"	f	class:statistics::slice
print_stolen_nodes	stat/slice.cpp	/^slice::print_stolen_nodes(csv_line& csv) const$/;"	f	class:statistics::slice
print_tab	vm/instr.cpp	/^print_tab(const int tabcount)$/;"	f	namespace:vm
print_uint64_t	utils/types.cpp	/^void print_uint64_t(uint64_t u)$/;"	f	namespace:utils
print_work_queue	stat/slice.cpp	/^slice::print_work_queue(csv_line& csv) const$/;"	f	class:statistics::slice
prio_tuples_queue	sched/nodes/thread_intrusive.hpp	/^	typedef queue::heap_queue<db::simple_tuple*> prio_tuples_queue;$/;"	t	class:sched::thread_intrusive_node
prioritized_tuples	sched/nodes/thread_intrusive.hpp	/^	prio_tuples_queue prioritized_tuples;$/;"	m	class:sched::thread_intrusive_node
priority	queue/safe_general_pqueue.hpp	/^      P priority;$/;"	m	struct:queue::general_pqueue::queue_item
priority_argument	vm/predicate.hpp	/^   field_num priority_argument;$/;"	m	class:vm::predicate
priority_level	sched/nodes/thread_intrusive.hpp	/^   heap_priority priority_level;$/;"	m	class:sched::thread_intrusive_node
priority_order	vm/program.hpp	/^   vm::priority_type priority_order;$/;"	m	class:vm::program
priority_pred	vm/program.hpp	/^	predicate *priority_pred;$/;"	m	class:vm::program
priority_queue	stat/slice.hpp	/^   size_t priority_queue;$/;"	m	class:statistics::slice
priority_strat_level	vm/program.hpp	/^   strat_level priority_strat_level;$/;"	m	class:vm::program
priority_type	vm/predicate.hpp	/^} priority_type;$/;"	t	namespace:vm	typeref:enum:vm::__anon10
priority_type	vm/program.hpp	/^   field_type priority_type;$/;"	m	class:vm::program
process	db/node.hpp	/^namespace process { class process; class machine; }$/;"	n
process	process/machine.cpp	/^namespace process$/;"	n	file:
process	process/machine.hpp	/^namespace process$/;"	n
process	process/work.hpp	/^namespace process$/;"	n
process	sched/base.hpp	/^namespace process {$/;"	n
process	vm/all.hpp	/^namespace process {$/;"	n
process_consumed_local_tuples	vm/state.cpp	/^state::process_consumed_local_tuples(void)$/;"	f	class:vm::state
process_id	vm/defs.hpp	/^typedef unsigned short process_id;$/;"	t	namespace:vm
process_others	vm/state.cpp	/^state::process_others(void)$/;"	f	class:vm::state
process_persistent_tuple	vm/state.cpp	/^state::process_persistent_tuple(db::simple_tuple *stpl, vm::tuple *tpl)$/;"	f	class:vm::state
processed_facts	sched/base.hpp	/^   mutable utils::atomic<size_t> processed_facts;$/;"	m	class:sched::base
processed_facts	stat/slice.hpp	/^   size_t processed_facts;$/;"	m	class:statistics::slice
progname	meld.cpp	/^static char *progname = NULL;$/;"	v	file:
progname	server.cpp	/^static char *progname = NULL;$/;"	v	file:
program	meld.cpp	/^static char *program = NULL;$/;"	v	file:
program	vm/program.cpp	/^program::program(const string& _filename):$/;"	f	class:vm::program
program	vm/program.hpp	/^class program$/;"	c	namespace:vm
ptr	runtime/list.hpp	/^   typedef list_ptr ptr;$/;"	t	class:runtime::cons
ptr	runtime/string.hpp	/^   typedef rstring_ptr ptr;$/;"	t	class:runtime::rstring
ptr	vm/external.hpp	/^   external_function_ptr ptr;$/;"	m	class:vm::external_function
ptr_field	vm/defs.hpp	/^	ptr_val ptr_field;$/;"	m	union:vm::__anon7
ptr_val	vm/defs.hpp	/^typedef unsigned long int ptr_val;$/;"	t	namespace:vm
purge_runtime_objects	vm/state.cpp	/^state::purge_runtime_objects(void)$/;"	f	class:vm::state
push	queue/bounded_pqueue.hpp	/^   void push(const T item, const size_t prio)$/;"	f	class:queue::bounded_pqueue
push	queue/safe_general_pqueue.hpp	/^   inline void push(T item, P priority)$/;"	f	class:queue::general_pqueue
push	queue/safe_linear_queue.hpp	/^   inline void push(T data)$/;"	f	class:queue::safe_linear_queue
push	queue/safe_linear_queue.hpp	/^   inline void push(T el)$/;"	f	class:queue::push_safe_linear_queue
push	queue/simple_linear_pqueue.hpp	/^   void push(const T item, const size_t prio)$/;"	f	class:queue::simple_linear_pqueue
push	queue/unsafe_double_queue.hpp	/^   inline void push(node_type data)$/;"	f	class:queue::intrusive_unsafe_double_queue
push	queue/unsafe_linear_queue.hpp	/^   inline void push(T el)$/;"	f	class:queue::unsafe_linear_queue
push	queue/unsafe_linear_queue.hpp	/^   inline void push(T el)$/;"	f	class:queue::unsafe_linear_queue_count
push	sched/thread/steal_set.hpp	/^   inline void push(sched::base *sc)$/;"	f	class:sched::steal_set
push_head	queue/safe_double_queue.hpp	/^	inline void push_head(node_type data)$/;"	f	class:queue::intrusive_safe_double_queue
push_head	queue/unsafe_double_queue.hpp	/^	inline void push_head(node_type data)$/;"	f	class:queue::intrusive_unsafe_double_queue
push_node	queue/safe_linear_queue.hpp	/^   inline void push_node(node *new_node)$/;"	f	class:queue::safe_linear_queue
push_node	queue/safe_linear_queue.hpp	/^   inline void push_node(special_node *new_node)$/;"	f	class:queue::push_safe_linear_queue
push_queue	queue/bounded_pqueue.hpp	/^   void push_queue(unsafe_linear_queue_count<T>& q, const size_t prio)$/;"	f	class:queue::bounded_pqueue
push_safe_linear_queue	queue/safe_linear_queue.hpp	/^   explicit push_safe_linear_queue(void):$/;"	f	class:queue::push_safe_linear_queue
push_safe_linear_queue	queue/safe_linear_queue.hpp	/^class push_safe_linear_queue$/;"	c	namespace:queue
push_tail	queue/safe_double_queue.hpp	/^   inline void push_tail(node_type data)$/;"	f	class:queue::intrusive_safe_double_queue
quarter	scripts/generate_heat_grid.py	/^		quarter = side \/ 4$/;"	v
queue	queue/bounded_pqueue.hpp	/^namespace queue$/;"	n
queue	queue/node.hpp	/^namespace queue$/;"	n
queue	queue/safe_complex_pqueue.hpp	/^namespace queue$/;"	n
queue	queue/safe_double_queue.hpp	/^namespace queue$/;"	n
queue	queue/safe_general_pqueue.hpp	/^namespace queue$/;"	n
queue	queue/safe_linear_queue.hpp	/^namespace queue$/;"	n
queue	queue/safe_simple_pqueue.hpp	/^namespace queue$/;"	n
queue	queue/simple_linear_pqueue.hpp	/^   typedef unsafe_linear_queue_count<T> queue;$/;"	t	class:queue::simple_linear_pqueue
queue	queue/simple_linear_pqueue.hpp	/^namespace queue$/;"	n
queue	queue/unsafe_double_queue.hpp	/^namespace queue$/;"	n
queue	queue/unsafe_linear_queue.hpp	/^namespace queue$/;"	n
queue	sched/nodes/serial.hpp	/^   queue_type queue;$/;"	m	class:sched::serial_node
queue	sched/nodes/thread.hpp	/^	queue_type queue;$/;"	m	class:sched::thread_node
queue	sched/nodes/unsafe_static.hpp	/^	queue::unsafe_bounded_pqueue<process::node_work>::type queue;$/;"	m	class:sched::unsafe_static_node
queue_item	queue/safe_general_pqueue.hpp	/^      queue_item(const T _item, const P _prio): item(_item), priority(_prio) {}$/;"	f	struct:queue::general_pqueue::queue_item
queue_item	queue/safe_general_pqueue.hpp	/^   struct queue_item {$/;"	s	class:queue::general_pqueue
queue_item_comparator	queue/safe_general_pqueue.hpp	/^   struct queue_item_comparator {$/;"	s	class:queue::general_pqueue
queue_iterator	sched/nodes/serial.hpp	/^	typedef queue_type::const_iterator queue_iterator;$/;"	t	class:sched::serial_node
queue_node	queue/node.hpp	/^class queue_node: public mem::base$/;"	c	namespace:queue
queue_nodes	sched/serial.hpp	/^	queue::intrusive_unsafe_double_queue<serial_node> queue_nodes;$/;"	m	class:sched::serial_local
queue_tree_node	queue/bounded_pqueue.hpp	/^   explicit queue_tree_node(void):$/;"	f	class:queue::queue_tree_node
queue_tree_node	queue/bounded_pqueue.hpp	/^class queue_tree_node: public mem::base$/;"	c	namespace:queue
queue_type	sched/nodes/serial.hpp	/^	typedef queue::unsafe_bounded_pqueue<db::simple_tuple*>::type queue_type;	$/;"	t	class:sched::serial_node
queue_type	sched/nodes/thread.hpp	/^	typedef queue::safe_bounded_pqueue<db::simple_tuple*>::type queue_type;$/;"	t	class:sched::thread_node
queues	queue/simple_linear_pqueue.hpp	/^   std::vector<queue> queues;$/;"	m	class:queue::simple_linear_pqueue
radix	utils/tree_barrier.hpp	/^   const size_t radix;$/;"	m	class:utils::tree_barrier
randgen	utils/random.hpp	/^   explicit randgen(void) {}$/;"	f	class:utils::randgen
randgen	utils/random.hpp	/^class randgen$/;"	c	namespace:utils
randgen	vm/state.hpp	/^	utils::randgen randgen;$/;"	m	class:vm::state
random	scripts/generate_powergrid.py	/^import random$/;"	i
random	scripts/generate_random_graph.py	/^import random$/;"	i
random	scripts/generate_random_shortest_path.py	/^import random$/;"	i
random	scripts/generate_shortest_path.py	/^import random$/;"	i
random	scripts/plots/active_inactive.py	/^import random$/;"	i
random_unsigned	utils/utils.cpp	/^random_unsigned(const size_t lim)$/;"	f	namespace:utils
range	queue/bounded_pqueue.hpp	/^   size_t range;$/;"	m	class:queue::bounded_pqueue
ratio	scripts/heat_color.py	/^	ratio = heat \/ maxheat$/;"	v
ratio	scripts/heat_count_color.py	/^	ratio = float(count) \/ float(maxcount)$/;"	v
ratio	scripts/plots/active_inactive.py	/^				ratio = float(thr) \/float(maxqueue)$/;"	v
re	scripts/csv_step.py	/^import re$/;"	i
re	scripts/lib_csv.py	/^import re$/;"	i
reached_zero	db/tuple.hpp	/^   inline bool reached_zero(void) const { return get_count() == 0; }$/;"	f	class:db::simple_tuple
read_arguments	meld.cpp	/^read_arguments(int argc, char **argv)$/;"	f	file:
read_arguments	server.cpp	/^read_arguments(int argc, char **argv)$/;"	f	file:
read_call_arg	vm/exec.cpp	/^read_call_arg(argument& arg, const field_type type, pcounter& m, state& state)$/;"	f	namespace:vm
read_coord	scripts/heat_color.py	/^def read_coord(data):$/;"	f
read_coord	scripts/heat_count_color.py	/^def read_coord(data):$/;"	f
read_count_node	scripts/heat_count_color.py	/^def read_count_node(data):$/;"	f
read_csv_file	scripts/lib_csv.py	/^def read_csv_file(file):$/;"	f
read_db	scripts/check_coloring.py	/^from lib_db import read_db$/;"	i
read_db	scripts/count_db_total.py	/^from lib_db import read_db$/;"	i
read_db	scripts/heat_color.py	/^from lib_db import read_db$/;"	i
read_db	scripts/heat_count_color.py	/^from lib_db import read_db$/;"	i
read_db	scripts/lib_db.py	/^def read_db(lines, only = None):$/;"	f
read_heat_node	scripts/heat_color.py	/^def read_heat_node(data):$/;"	f
read_inner	scripts/heat_color.py	/^def read_inner(data):$/;"	f
read_inner	scripts/heat_count_color.py	/^def read_inner(data):$/;"	f
reader	scripts/duplicate_neural_network.py	/^reader = csv.reader(open(input, 'rb'), delimiter=',')$/;"	v
reader	scripts/generate_neural_network.py	/^reader = csv.reader(open(file, 'rb'), delimiter=',')$/;"	v
reader	scripts/transform_letter_data.py	/^reader = csv.reader(open(input, 'rb'), delimiter=',')$/;"	v
rebind	mem/allocator.hpp	/^   struct rebind {$/;"	s	class:mem::allocator
ref	utils/atomic.hpp	/^   volatile T ref;$/;"	m	class:utils::atomic_ref
ref_count	vm/defs.hpp	/^typedef short ref_count;$/;"	t	namespace:vm
reference	mem/allocator.hpp	/^   typedef value_type& reference;$/;"	t	class:mem::allocator
refs	runtime/list.hpp	/^   utils::atomic<size_t> refs;$/;"	m	class:runtime::cons
refs	runtime/string.hpp	/^	utils::atomic<size_t> refs;$/;"	m	class:runtime::rstring
reg	vm/state.hpp	/^   typedef tuple_field reg;$/;"	t	class:vm::state
reg_get	vm/instr.hpp	/^inline reg_num reg_get(pcounter x, size_t off) { return (reg_num)(*(x + off) & 0x1f); }$/;"	f	namespace:vm::instr
reg_num	vm/instr.hpp	/^typedef unsigned char reg_num;$/;"	t	namespace:vm
reg_size	vm/instr.hpp	/^const size_t reg_size = 0;$/;"	m	namespace:vm::instr
reg_string	vm/instr.cpp	/^reg_string(const reg_num num)$/;"	f	namespace:vm::instr
register_allocation	mem/stat.cpp	/^register_allocation(const size_t cnt, const size_t size)$/;"	f	namespace:mem
register_deallocation	mem/stat.cpp	/^register_deallocation(const size_t cnt, const size_t size)$/;"	f	namespace:mem
register_external_function	vm/external.cpp	/^register_external_function(external_function *ex)$/;"	f	namespace:vm
register_malloc	mem/stat.cpp	/^register_malloc(void)$/;"	f	namespace:mem
register_predicate_availability	vm/rule_matcher.cpp	/^rule_matcher::register_predicate_availability(const predicate *pred)$/;"	f	class:vm::rule_matcher
register_predicate_unavailability	vm/rule_matcher.cpp	/^rule_matcher::register_predicate_unavailability(const predicate *pred)$/;"	f	class:vm::rule_matcher
register_tuple	vm/rule_matcher.cpp	/^rule_matcher::register_tuple(tuple *tpl, const ref_count count, const bool is_new)$/;"	f	class:vm::rule_matcher
regs	vm/state.hpp	/^   reg regs[NUM_REGS];$/;"	m	class:vm::state
remote_pred	vm/predicate.hpp	/^      predicate *remote_pred;$/;"	m	struct:vm::predicate::__anon11
remote_pred_id	vm/predicate.hpp	/^      predicate_id remote_pred_id;$/;"	m	struct:vm::predicate::__anon11
remove	queue/safe_complex_pqueue.hpp	/^	void remove(heap_object obj)$/;"	f	class:queue::intrusive_safe_complex_pqueue
remove	queue/safe_double_queue.hpp	/^	inline void remove(node_type node)$/;"	f	class:queue::intrusive_safe_double_queue
remove	queue/safe_simple_pqueue.hpp	/^	void remove(T val, const heap_priority prio)$/;"	f	class:queue::heap_queue
remove	queue/unsafe_double_queue.hpp	/^	inline void remove(node_type node)$/;"	f	class:queue::intrusive_unsafe_double_queue
remove_agg_tuple	db/node.cpp	/^node::remove_agg_tuple(vm::tuple *tuple, const ref_count many)$/;"	f	class:db::node
remove_by_index	queue/safe_simple_pqueue.hpp	/^	void remove_by_index(const size_t index)$/;"	f	class:queue::heap_queue
remove_new	db/tuple.hpp	/^   static simple_tuple* remove_new(vm::tuple *tuple) { return new simple_tuple(tuple, -1); }$/;"	f	class:db::simple_tuple
remove_source	vm/instr.hpp	/^inline reg_num remove_source(const pcounter pc) { return reg_get(pc, 1); }$/;"	f	namespace:vm::instr
requests	sched/thread/steal_set.hpp	/^	queue::push_safe_linear_queue<sched::base*> requests;$/;"	m	class:sched::steal_set
reserve	utils/stack.hpp	/^   inline void reserve(const size_t defsize)$/;"	f	class:utils::stack
reset	sched/thread/termination_barrier.hpp	/^   inline void reset(void) { done = false; }$/;"	f	class:sched::termination_barrier
reset	utils/csv_line.hpp	/^   void reset(void)$/;"	f	class:utils::csv_line
reset	utils/simple_barrier.hpp	/^   inline void reset(void)$/;"	f	class:utils::simple_barrier
reset_barrier	sched/thread/threaded.hpp	/^   static inline void reset_barrier(void) { term_barrier->reset(); }$/;"	f	class:sched::threaded
reset_linear_jump	vm/instr.hpp	/^inline code_offset_t reset_linear_jump(const pcounter pc) { return jump_get(pc, 1); }$/;"	f	namespace:vm::instr
ret	vm/external.hpp	/^   field_type ret;$/;"	m	class:vm::external_function
return_select_jump	vm/instr.hpp	/^inline code_size_t return_select_jump(pcounter pc) { return pcounter_code_size(pc + 1); }$/;"	f	namespace:vm::instr
return_type	vm/exec.cpp	/^enum return_type {$/;"	g	namespace:vm	file:
right	queue/bounded_pqueue.hpp	/^   tree_node *parent, *left, *right;$/;"	m	class:queue::queue_tree_node
root	db/trie.hpp	/^   node *root;$/;"	m	class:db::trie
root	queue/bounded_pqueue.hpp	/^   tree_node *root;$/;"	m	class:queue::bounded_pqueue
round	scripts/plots/state_totals.py	/^round = {}$/;"	v
round_state	sched/thread/threaded.hpp	/^   static volatile size_t round_state;$/;"	m	class:sched::threaded
route	process/machine.cpp	/^machine::route(const node* from, sched::base *sched_caller, const node::node_id id, simple_tuple* stpl, const uint_val delay)$/;"	f	class:process::machine
route_predicates	vm/program.hpp	/^   std::vector<predicate*> route_predicates;$/;"	m	class:vm::program
route_self	process/machine.cpp	/^machine::route_self(sched::base *sched, node *node, simple_tuple *stpl, const uint_val delay)$/;"	f	class:process::machine
rstring	runtime/string.hpp	/^	explicit rstring(const std::string& _content, const size_t _refs):$/;"	f	class:runtime::rstring
rstring	runtime/string.hpp	/^class rstring: public mem::base$/;"	c	namespace:runtime
rstring_ptr	runtime/string.hpp	/^	typedef rstring* rstring_ptr;$/;"	t	class:runtime::rstring
rtuple_pqueue	sched/nodes/sim.hpp	/^	queue::heap_queue<db::simple_tuple*> rtuple_pqueue; \/\/ same as before but with retraction facts$/;"	m	class:sched::sim_node
rule	vm/rule.hpp	/^      explicit rule(const rule_id _id, const std::string& _str):$/;"	f	class:vm::rule
rule	vm/rule.hpp	/^class rule$/;"	c	namespace:vm
rule_get_id	vm/instr.hpp	/^inline size_t rule_get_id(const pcounter pc) { return pcounter_uint(pc + 1); }$/;"	f	namespace:vm::instr
rule_id	vm/defs.hpp	/^typedef uint32_t rule_id;$/;"	t	namespace:vm
rule_iterator	vm/predicate.hpp	/^   typedef std::vector<rule_id>::const_iterator rule_iterator;$/;"	t	class:vm::predicate
rule_iterator	vm/rule_matcher.hpp	/^	typedef set_rules::const_iterator rule_iterator;$/;"	t	class:vm::rule_matcher
rule_matcher	vm/rule_matcher.cpp	/^rule_matcher::rule_matcher(vm::program *prog)$/;"	f	class:vm::rule_matcher
rule_matcher	vm/rule_matcher.hpp	/^class rule_matcher$/;"	c	namespace:vm
rule_matcher_obj	vm/rule_matcher.hpp	/^   class rule_matcher_obj$/;"	c	class:vm::rule_matcher
rule_queue	vm/state.hpp	/^	queue::heap_queue<vm::rule_id> rule_queue;$/;"	m	class:vm::state
rule_vector	vm/rule_matcher.hpp	/^	typedef std::vector<rule_matcher_obj> rule_vector;$/;"	t	class:vm::rule_matcher
rules	vm/program.hpp	/^   std::vector<rule *> rules;$/;"	m	class:vm::program
rules	vm/rule_matcher.hpp	/^   rule_vector rules; \/* availability statistics per rule *\/$/;"	m	class:vm::rule_matcher
rules	vm/state.hpp	/^	bool *rules;$/;"	m	class:vm::state
run_action	process/machine.cpp	/^machine::run_action(sched::base *sched, node* node, vm::tuple *tpl, const bool from_other)$/;"	f	class:process::machine
run_diff	tests/test.sh	/^run_diff ()$/;"	f
run_node	vm/state.cpp	/^state::run_node(db::node *no)$/;"	f	class:vm::state
run_program	interface.cpp	/^run_program(int argc, char **argv, const char *program, const vm::machine_arguments& margs)$/;"	f
run_serial_n	tests/test.sh	/^run_serial_n ()$/;"	f
run_test	tests/test_linear.sh	/^run_test ()$/;"	f
run_test_n	tests/test.sh	/^run_test_n ()$/;"	f
runtime	runtime/list.hpp	/^namespace runtime$/;"	n
runtime	runtime/string.hpp	/^namespace runtime$/;"	n
safe	vm/program.hpp	/^   bool safe;$/;"	m	class:vm::program
safe_bounded_pqueue	queue/bounded_pqueue.hpp	/^struct safe_bounded_pqueue$/;"	s	namespace:queue
safe_linear_queue	queue/safe_linear_queue.hpp	/^   explicit safe_linear_queue(void):$/;"	f	class:queue::safe_linear_queue
safe_linear_queue	queue/safe_linear_queue.hpp	/^class safe_linear_queue$/;"	c	namespace:queue
safeness	vm/predicate.hpp	/^      aggregate_safeness safeness;$/;"	m	struct:vm::predicate::__anon11
same_place	process/machine.cpp	/^machine::same_place(const node::node_id id1, const node::node_id id2) const$/;"	f	class:process::machine
sanity_check	db/trie.cpp	/^trie::sanity_check(void) const$/;"	f	class:db::trie
save	utils/simple_barrier.hpp	/^   const size_t save;$/;"	m	class:utils::simple_barrier
saved_leafs	vm/state.hpp	/^   db::tuple_trie_leaf *saved_leafs[NUM_REGS];$/;"	m	class:vm::state
saved_stuples	vm/state.hpp	/^	db::simple_tuple *saved_stuples[NUM_REGS];$/;"	m	class:vm::state
sched	db/node.hpp	/^namespace sched { class base; class mpi_handler; }$/;"	n
sched	sched/base.cpp	/^namespace sched$/;"	n	file:
sched	sched/base.hpp	/^namespace sched$/;"	n
sched	sched/common.cpp	/^namespace sched$/;"	n	file:
sched	sched/common.hpp	/^namespace sched$/;"	n
sched	sched/mpi.cpp	/^namespace sched {$/;"	n	file:
sched	sched/mpi.hpp	/^namespace sched$/;"	n
sched	sched/nodes/in_queue.hpp	/^namespace sched$/;"	n
sched	sched/nodes/serial.hpp	/^namespace sched$/;"	n
sched	sched/nodes/sim.hpp	/^namespace sched$/;"	n
sched	sched/nodes/thread.hpp	/^namespace sched$/;"	n
sched	sched/nodes/thread_intrusive.hpp	/^namespace sched$/;"	n
sched	sched/nodes/unsafe_static.hpp	/^namespace sched$/;"	n
sched	sched/serial.cpp	/^namespace sched$/;"	n	file:
sched	sched/serial.hpp	/^namespace sched$/;"	n
sched	sched/sim.cpp	/^namespace sched$/;"	n	file:
sched	sched/sim.hpp	/^namespace sched$/;"	n
sched	sched/sim_tcp.cpp	/^namespace sched$/;"	n	file:
sched	sched/thread/assert.cpp	/^namespace sched$/;"	n	file:
sched	sched/thread/assert.hpp	/^namespace sched$/;"	n
sched	sched/thread/state.hpp	/^namespace sched$/;"	n
sched	sched/thread/steal_set.hpp	/^namespace sched$/;"	n
sched	sched/thread/termination_barrier.hpp	/^namespace sched$/;"	n
sched	sched/thread/threaded.cpp	/^namespace sched$/;"	n	file:
sched	sched/thread/threaded.hpp	/^namespace sched$/;"	n
sched	sched/thread/tri_barrier.hpp	/^namespace sched$/;"	n
sched	sched/types.hpp	/^namespace sched$/;"	n
sched	scripts/plots/state_totals.py	/^sched = {}$/;"	v
sched	vm/all.hpp	/^namespace sched {$/;"	n
sched	vm/state.hpp	/^   sched::base *sched;$/;"	m	class:vm::state
sched	vm/state.hpp	/^namespace sched {$/;"	n
sched_key	sched/base.cpp	/^pthread_key_t sched_key;$/;"	m	namespace:sched	file:
sched_state	stat/stat.hpp	/^enum sched_state$/;"	g	namespace:statistics
sched_type	process/machine.hpp	/^   const sched::scheduler_type sched_type;$/;"	m	class:process::machine
schedule_new_message	sched/sim.cpp	/^sim_sched::schedule_new_message(message_type *data)$/;"	f	class:sched::sim_sched
schedule_new_message	sched/sim_tcp.cpp	/^sim_sched::schedule_new_message(message_type *data)$/;"	f	class:sched::sim_sched
schedule_next	sched/base.hpp	/^   virtual void schedule_next(db::node *) { }$/;"	f	class:sched::base
scheduler_type	sched/types.hpp	/^enum scheduler_type {$/;"	g	namespace:sched
scope	utils/time.hpp	/^      explicit scope(execution_time& _t): t(_t) { t.start(); }$/;"	f	class:utils::execution_time::scope
scope	utils/time.hpp	/^   class scope$/;"	c	class:utils::execution_time
scoped_lock	utils/spinlock.hpp	/^   typedef boost::lock_guard<spinlock> scoped_lock;$/;"	t	class:utils::spinlock
search_for_negative_tuple_full_agg	vm/state.cpp	/^state::search_for_negative_tuple_full_agg(db::simple_tuple *stpl)$/;"	f	class:vm::state
search_for_negative_tuple_normal	vm/state.cpp	/^state::search_for_negative_tuple_normal(db::simple_tuple *stpl)$/;"	f	class:vm::state
search_for_negative_tuple_partial_agg	vm/state.cpp	/^state::search_for_negative_tuple_partial_agg(db::simple_tuple *stpl)$/;"	f	class:vm::state
select_hash	vm/instr.hpp	/^inline code_offset_t select_hash(pcounter hash_start, const node_val val) { return pcounter_code_size(hash_start + sizeof(code_size_t)*val); }$/;"	f	namespace:vm::instr
select_hash_code	vm/instr.hpp	/^inline pcounter select_hash_code(pcounter hash_start, const size_t hash_size, const code_offset_t hashed) {$/;"	f	namespace:vm::instr
select_hash_size	vm/instr.hpp	/^inline size_t select_hash_size(pcounter pc) { return (size_t)pcounter_code_size(pc + 1 + sizeof(code_size_t)); }$/;"	f	namespace:vm::instr
select_hash_start	vm/instr.hpp	/^inline pcounter select_hash_start(pcounter pc) { return pc + SELECT_BASE; }$/;"	f	namespace:vm::instr
select_size	vm/instr.hpp	/^inline code_size_t select_size(pcounter pc) { return pcounter_code_size(pc + 1); }$/;"	f	namespace:vm::instr
send_delay_dest	vm/instr.hpp	/^inline reg_num send_delay_dest(pcounter pc) { return reg_get(pc, 2); }$/;"	f	namespace:vm::instr
send_delay_msg	vm/instr.hpp	/^inline reg_num send_delay_msg(pcounter pc) { return reg_get(pc, 1); }$/;"	f	namespace:vm::instr
send_delay_time	vm/instr.hpp	/^inline uint_val send_delay_time(pcounter pc) { return pcounter_uint(pc + 3); }$/;"	f	namespace:vm::instr
send_dest	vm/instr.hpp	/^inline reg_num send_dest(pcounter pc) { return reg_get(pc, 2); }$/;"	f	namespace:vm::instr
send_msg	vm/instr.hpp	/^inline reg_num send_msg(pcounter pc) { return reg_get(pc, 1); }$/;"	f	namespace:vm::instr
send_pending_messages	sched/sim.cpp	/^sim_sched::send_pending_messages(void)$/;"	f	class:sched::sim_sched
send_pending_messages	sched/sim_tcp.cpp	/^sim_sched::send_pending_messages(void)$/;"	f	class:sched::sim_sched
send_send_message	sched/sim.cpp	/^sim_sched::send_send_message(const work_info& info, const deterministic_timestamp ts)$/;"	f	class:sched::sim_sched
send_send_message	sched/sim_tcp.cpp	/^sim_sched::send_send_message(const work_info& info, const deterministic_timestamp ts)$/;"	f	class:sched::sim_sched
sense	utils/tree_barrier.hpp	/^   volatile bool sense;   $/;"	m	class:utils::tree_barrier
sent	db/neighbor_agg_configuration.hpp	/^   edge_set sent;$/;"	m	class:db::neighbor_agg_configuration
sent_facts	sched/base.hpp	/^   mutable utils::atomic<size_t> sent_facts;$/;"	m	class:sched::base
sent_facts	stat/slice.hpp	/^   size_t sent_facts;$/;"	m	class:statistics::slice
serial_local	sched/serial.hpp	/^   explicit serial_local(vm::all *all):$/;"	f	class:sched::serial_local
serial_local	sched/serial.hpp	/^class serial_local: public sched::base$/;"	c	namespace:sched
serial_node	sched/nodes/serial.hpp	/^   explicit serial_node(const db::node::node_id _id, const db::node::node_id _trans, vm::all *all):$/;"	f	class:sched::serial_node
serial_node	sched/nodes/serial.hpp	/^class serial_node: public in_queue_node$/;"	c	namespace:sched
servaddr	mock-simulator/simulator.cpp	/^static struct sockaddr_in servaddr, cliaddr;$/;"	v	typeref:struct:sockaddr_in	file:
set_active	sched/thread/threaded.hpp	/^   inline void set_active(void)$/;"	f	class:sched::threaded
set_active_if_inactive	sched/thread/threaded.hpp	/^   inline void set_active_if_inactive(void)$/;"	f	class:sched::threaded
set_all	ui/manager.hpp	/^      void set_all(vm::all *_all) { all = _all; }$/;"	f	class:ui::manager
set_any_all	vm/match.hpp	/^   inline void set_any_all(const predicate *pred) {$/;"	f	class:vm::match
set_arg_type	vm/external.cpp	/^external_function::set_arg_type(const size_t arg, const field_type typ)$/;"	f	class:vm::external_function
set_as_aggregate	db/tuple.hpp	/^   inline void set_as_aggregate(void)$/;"	f	class:db::simple_tuple
set_as_persistent	vm/rule.hpp	/^      inline void set_as_persistent(void) { is_persistent = true; }$/;"	f	class:vm::rule
set_bytecode	vm/rule.hpp	/^      inline void set_bytecode(code_size_t _size, byte_code _code) {$/;"	f	class:vm::rule
set_color	sched/sim.cpp	/^sim_sched::set_color(db::node *n, const int r, const int g, const int b)$/;"	f	class:sched::sim_sched
set_color	sched/sim_tcp.cpp	/^sim_sched::set_color(db::node *n, const int r, const int g, const int b)$/;"	f	class:sched::sim_sched
set_conf	db/trie.hpp	/^   inline void set_conf(agg_configuration* _conf) { conf = _conf; }$/;"	f	class:db::agg_trie_leaf
set_const	vm/all.hpp	/^   inline void set_const(const const_id& id, const tuple_field d) { consts[id] = d; }$/;"	f	class:vm::all
set_count	utils/tree_barrier.hpp	/^      void set_count(const size_t n)$/;"	f	class:utils::tree_barrier::inner_node
set_done	sched/thread/termination_barrier.hpp	/^   inline void set_done(void) { done = true; }$/;"	f	class:sched::termination_barrier
set_field	vm/tuple.hpp	/^   inline void set_field(const field_num& field, tuple_field& f) { fields[field] = f; }$/;"	f	class:vm::tuple
set_float_priority_level	sched/nodes/thread_intrusive.hpp	/^   inline void set_float_priority_level(const vm::float_val level) { priority_level.float_priority = level; }$/;"	f	class:sched::thread_intrusive_node
set_generated_run	db/tuple.hpp	/^   inline void set_generated_run(const bool v)$/;"	f	class:db::simple_tuple
set_global_priority	vm/predicate.hpp	/^	void set_global_priority(priority_type _type, const field_num field) { global_prio = _type; priority_argument = field;}$/;"	f	class:vm::predicate
set_header	utils/csv_line.hpp	/^   void set_header(void)$/;"	f	class:utils::csv_line
set_in_queue	sched/nodes/in_queue.hpp	/^   inline void set_in_queue(const bool val)$/;"	f	class:sched::in_queue_node
set_inactive	sched/thread/threaded.hpp	/^   inline void set_inactive(void)$/;"	f	class:sched::threaded
set_instantiated	sched/nodes/sim.hpp	/^   inline void set_instantiated(const bool flag)$/;"	f	class:sched::sim_node
set_int_priority_level	sched/nodes/thread_intrusive.hpp	/^   inline void set_int_priority_level(const vm::int_val level) { priority_level.int_priority = level; }$/;"	f	class:sched::thread_intrusive_node
set_leaf	db/trie.hpp	/^   inline void set_leaf(trie_leaf *leaf)$/;"	f	class:db::trie_node
set_leaf	vm/state.hpp	/^   inline void set_leaf(const reg_num& num, db::tuple_trie_leaf* leaf) { is_leaf[num] = true; saved_leafs[num] = leaf; }$/;"	f	class:vm::state
set_neighbor	mock-simulator/simulator.cpp	/^set_neighbor(const int in, const face_t side, const int out)$/;"	f	file:
set_next	mem/chunk.hpp	/^   inline void set_next(chunk *ptr)$/;"	f	class:mem::chunk
set_nil	vm/state.hpp	/^   inline void set_nil(const reg_num& num) { set_ptr(num, null_ptr_val); }$/;"	f	class:vm::state
set_nil	vm/tuple.hpp	/^   inline void set_nil(const field_num& field) { set_ptr(field, null_ptr_val); }$/;"	f	class:vm::tuple
set_node_priority	sched/base.hpp	/^   virtual void set_node_priority(db::node *, const double) { }$/;"	f	class:sched::base
set_node_priority_other	sched/base.hpp	/^   virtual void set_node_priority_other(db::node *, const double) { }$/;"	f	class:sched::base
set_op_function	vm/exec.cpp	/^void set_op_function<bool_val>(const pcounter& m, const instr_val& dest,$/;"	f	namespace:vm
set_op_function	vm/exec.cpp	/^void set_op_function<float_list*>(const pcounter& m, const instr_val& dest,$/;"	f	namespace:vm
set_op_function	vm/exec.cpp	/^void set_op_function<float_val>(const pcounter& m, const instr_val& dest,$/;"	f	namespace:vm
set_op_function	vm/exec.cpp	/^void set_op_function<int_list*>(const pcounter& m, const instr_val& dest,$/;"	f	namespace:vm
set_op_function	vm/exec.cpp	/^void set_op_function<int_val>(const pcounter& m, const instr_val& dest,$/;"	f	namespace:vm
set_op_function	vm/exec.cpp	/^void set_op_function<node_list*>(const pcounter& m, const instr_val& dest,$/;"	f	namespace:vm
set_op_function	vm/exec.cpp	/^void set_op_function<node_val>(const pcounter& m, const instr_val& dest,$/;"	f	namespace:vm
set_owner	db/node.hpp	/^   inline void set_owner(sched::base *_owner) { owner = _owner; }$/;"	f	class:db::node
set_priority_level	sched/nodes/thread_intrusive.hpp	/^	inline void set_priority_level(const heap_priority level) { priority_level = level; }$/;"	f	class:sched::thread_intrusive_node
set_rules	vm/rule_matcher.hpp	/^	typedef std::set<rule_id, std::less<rule_id>, mem::allocator<rule_id> > set_rules;$/;"	t	class:vm::rule_matcher
set_stat_file	stat/stat.cpp	/^set_stat_file(const string& file)$/;"	f	namespace:statistics
set_tail	runtime/list.hpp	/^   inline void set_tail(list_ptr t)$/;"	f	class:runtime::cons
set_timer	process/machine.cpp	/^machine::set_timer(void)$/;"	f	class:process::machine
set_tuple_queue	vm/state.hpp	/^	inline void set_tuple_queue(const reg_num& num, db::simple_tuple *stpl) { is_leaf[num] = false; saved_stuples[num] = stpl; }$/;"	f	class:vm::state
set_type	queue/safe_complex_pqueue.hpp	/^	void set_type(const heap_type _typ)$/;"	f	class:queue::intrusive_safe_complex_pqueue
set_type	queue/safe_simple_pqueue.hpp	/^	void set_type(const heap_type _typ)$/;"	f	class:queue::heap_queue
set_weight	scripts/generate_binary_tree.py	/^from lib import set_weight$/;"	i
set_weight	scripts/generate_chain.py	/^from lib import set_weight$/;"	i
set_weight	scripts/generate_cycle.py	/^from lib import set_weight$/;"	i
set_weight	scripts/generate_grid.py	/^from lib import set_weight$/;"	i
set_weight	scripts/generate_pyramid.py	/^from lib import set_weight$/;"	i
set_weight	scripts/lib.py	/^def set_weight(new):$/;"	f
set_work_with_rules	process/work.hpp	/^   void set_work_with_rules(db::node *_node)$/;"	f	class:process::work
setup	vm/state.cpp	/^state::setup(vm::tuple *tpl, db::node *n, const ref_count count)$/;"	f	class:vm::state
setup_data	scripts/plots/state_totals.py	/^def setup_data(num_threads):$/;"	f
shake_pred	sched/mpi.hpp	/^	static vm::predicate *shake_pred;$/;"	m	class:sched::mpi_sched
shake_pred	sched/sim.hpp	/^	static vm::predicate *shake_pred;$/;"	m	class:sched::sim_sched
show_database	interface.cpp	/^bool show_database = false;$/;"	v
show_inter_help	server.cpp	/^show_inter_help(void)$/;"	f	file:
show_version	server.cpp	/^show_version(void)$/;"	f	file:
shuffle_vector	utils/random.hpp	/^shuffle_vector(T& vec, randgen& gen)$/;"	f	namespace:utils
side	scripts/generate_heat_grid.py	/^side = int(sys.argv[1])$/;"	v
sim_node	sched/nodes/sim.hpp	/^   explicit sim_node(const db::node::node_id _id, const db::node::node_id _trans, vm::all *all):$/;"	f	class:sched::sim_node
sim_node	sched/nodes/sim.hpp	/^class sim_node: public db::node$/;"	c	namespace:sched
sim_sched	sched/mpi.hpp	/^	explicit sim_sched(vm::all *all, const vm::process_id id, sim_node *_node):$/;"	f	class:sched::mpi_sched
sim_sched	sched/mpi.hpp	/^   explicit sim_sched(vm::all *all):$/;"	f	class:sched::mpi_sched
sim_sched	sched/sim.hpp	/^	explicit sim_sched(vm::all *all, const vm::process_id id, sim_node *_node):$/;"	f	class:sched::sim_sched
sim_sched	sched/sim.hpp	/^   explicit sim_sched(vm::all *all):$/;"	f	class:sched::sim_sched
sim_sched	sched/sim.hpp	/^class sim_sched: public sched::base$/;"	c	namespace:sched
simple_barrier	utils/simple_barrier.hpp	/^class simple_barrier$/;"	c	namespace:utils
simple_linear_pqueue	queue/simple_linear_pqueue.hpp	/^   explicit simple_linear_pqueue(const size_t range):$/;"	f	class:queue::simple_linear_pqueue
simple_linear_pqueue	queue/simple_linear_pqueue.hpp	/^class simple_linear_pqueue$/;"	c	namespace:queue
simple_tuple	db/tuple.hpp	/^   explicit simple_tuple(vm::tuple *_tuple, const vm::ref_count _count):$/;"	f	class:db::simple_tuple
simple_tuple	db/tuple.hpp	/^   explicit simple_tuple(void): \/\/ for serialization purposes$/;"	f	class:db::simple_tuple
simple_tuple	db/tuple.hpp	/^class simple_tuple: public mem::base$/;"	c	namespace:db
simple_tuple_list	db/trie.hpp	/^typedef std::list<simple_tuple*, mem::allocator<simple_tuple*> > simple_tuple_list;$/;"	t	namespace:db
simple_tuple_list	db/tuple.hpp	/^typedef std::list<simple_tuple*, mem::allocator<simple_tuple*> > simple_tuple_list;$/;"	t	namespace:db
simple_tuple_map	db/node.hpp	/^                                 tuple_trie*> > > simple_tuple_map;$/;"	t	class:db::node
simple_tuple_vector	db/tuple.hpp	/^typedef std::vector<simple_tuple*, mem::allocator<simple_tuple*> > simple_tuple_vector;$/;"	t	namespace:db
simple_write_edge	scripts/lib.py	/^def simple_write_edge(a, b):$/;"	f
simple_write_edge	scripts/transform_pagerank.py	/^from lib import simple_write_edge$/;"	i
size	db/agg_configuration.hpp	/^   inline size_t size(void) const { return vals.size(); }$/;"	f	class:db::agg_configuration
size	db/trie.hpp	/^   inline size_t size(void) const { return number_of_references; }$/;"	f	class:db::trie
size	mem/chunkgroup.hpp	/^   const size_t size;$/;"	m	class:mem::chunkgroup
size	queue/bounded_pqueue.hpp	/^   inline size_t size(void) const { return total; }$/;"	f	class:queue::bounded_pqueue
size	queue/safe_general_pqueue.hpp	/^   inline size_t size(void) const$/;"	f	class:queue::general_pqueue
size	queue/simple_linear_pqueue.hpp	/^   inline size_t size(void) const { return total; }$/;"	f	class:queue::simple_linear_pqueue
size	queue/unsafe_linear_queue.hpp	/^   inline size_t size(void) const$/;"	f	class:queue::unsafe_linear_queue_count
size	scripts/duplicate_neural_network.py	/^size = int(sys.argv[3])$/;"	v
size	utils/tree_barrier.hpp	/^   const size_t size;$/;"	m	class:utils::tree_barrier
size	vm/match.hpp	/^   inline size_t size(void) const { return types.size(); }$/;"	f	class:vm::match
size_list	runtime/list.hpp	/^	size_t size_list(const list_ptr ptr, const size_t elem_size)$/;"	f	class:runtime::cons
size_type	mem/allocator.hpp	/^   typedef std::size_t size_type;$/;"	t	class:mem::allocator
sizeof	queue/safe_linear_queue.hpp	/^   BOOST_STATIC_ASSERT(sizeof(special_node) == sizeof(node));$/;"	m	class:queue::push_safe_linear_queue
slave	sched/mpi.hpp	/^	bool slave;$/;"	m	class:sched::mpi_sched
slave	sched/sim.hpp	/^	bool slave;$/;"	m	class:sched::sim_sched
slice	stat/slice.hpp	/^   explicit slice(void):$/;"	f	class:statistics::slice
slice	stat/slice.hpp	/^class slice$/;"	c	namespace:statistics
slice_function	process/machine.cpp	/^machine::slice_function(void)$/;"	f	class:process::machine
slice_set	stat/slice_set.cpp	/^slice_set::slice_set(const size_t num_threads):$/;"	f	class:statistics::slice_set
slice_set	stat/slice_set.hpp	/^class slice_set$/;"	c	namespace:statistics
slices	process/machine.hpp	/^   statistics::slice_set slices;$/;"	m	class:process::machine
slices	stat/slice_set.hpp	/^   vector_slices slices;$/;"	m	class:statistics::slice_set
socket	sched/mpi.hpp	/^	boost::asio::ip::tcp::socket *socket;$/;"	m	class:sched::mpi_sched
socket	sched/sim.hpp	/^	boost::asio::ip::tcp::socket *socket;$/;"	m	class:sched::sim_sched
socket_messages	sched/mpi.hpp	/^	static queue::push_safe_linear_queue<message_type*> socket_messages;$/;"	m	class:sched::mpi_sched
socket_messages	sched/sim.cpp	/^queue::push_safe_linear_queue<sim_sched::message_type*> sim_sched::socket_messages;$/;"	m	class:sched::sim_sched	file:
socket_messages	sched/sim.hpp	/^	static queue::push_safe_linear_queue<message_type*> socket_messages;$/;"	m	class:sched::sim_sched
socket_messages	sched/sim_tcp.cpp	/^queue::push_safe_linear_queue<sim_sched::message_type*> sim_sched::socket_messages;$/;"	m	class:sched::sim_sched	file:
source	scripts/generate_powergrid.py	/^		source = numsinks + sourcea$/;"	v
source	scripts/generate_powergrid.py	/^	source = numsinks + sourcea$/;"	v
source	scripts/generate_shortest_path.py	/^	source = random.randint(0, total-1)$/;"	v
south	sched/nodes/sim.hpp	/^   vm::node_val south;$/;"	m	class:sched::sim_node
south_neighbors	mock-simulator/simulator.cpp	/^static vector<int> north_neighbors, south_neighbors;$/;"	v	file:
spec	vm/external.hpp	/^   field_type *spec;$/;"	m	class:vm::external_function
special_node	queue/safe_linear_queue.hpp	/^   typedef special_queue_node<T> special_node;$/;"	t	class:queue::push_safe_linear_queue
special_queue_node	queue/safe_linear_queue.hpp	/^class special_queue_node: public mem::base$/;"	c	namespace:queue
spin	sched/nodes/thread.hpp	/^	utils::spinlock spin;$/;"	m	class:sched::thread_node
spinlock	utils/spinlock.hpp	/^   explicit spinlock(void):$/;"	f	class:utils::spinlock
spinlock	utils/spinlock.hpp	/^class spinlock$/;"	c	namespace:utils
splice	queue/bounded_pqueue.hpp	/^   void splice(simple_linear_pqueue<T>& other)$/;"	f	class:queue::bounded_pqueue
splice	queue/safe_linear_queue.hpp	/^   inline void splice(unsafe_linear_queue<T>& q)$/;"	f	class:queue::push_safe_linear_queue
splice	queue/safe_linear_queue.hpp	/^   inline void splice(unsafe_linear_queue_count<T>& q)$/;"	f	class:queue::push_safe_linear_queue
splice_headtail	queue/safe_linear_queue.hpp	/^   inline void splice_headtail(special_node* qhead, special_node* qtail)$/;"	f	class:queue::push_safe_linear_queue
src	sched/mpi.hpp	/^      sim_node *src;$/;"	m	struct:sched::mpi_sched::__anon3
src	sched/sim.hpp	/^      sim_node *src;$/;"	m	struct:sched::sim_sched::__anon4
stack	utils/stack.hpp	/^   explicit stack(const size_t defsize, container_type vec = container_type()):$/;"	f	class:utils::stack
stack	utils/stack.hpp	/^   explicit stack(void)$/;"	f	class:utils::stack
stack	utils/stack.hpp	/^class stack: public std::stack<T, std::vector<T, mem::allocator<T> > >$/;"	c	namespace:utils
stack_float_list	runtime/list.hpp	/^typedef std::stack<vm::float_val, std::deque<vm::float_val, mem::allocator<vm::float_val> > > stack_float_list;$/;"	t	namespace:runtime
stack_int_list	runtime/list.hpp	/^typedef std::stack<vm::int_val, std::deque<vm::int_val, mem::allocator<vm::int_val> > > stack_int_list;$/;"	t	namespace:runtime
stack_node_list	runtime/list.hpp	/^typedef std::stack<vm::node_val, std::deque<vm::node_val, mem::allocator<vm::node_val> > > stack_node_list;$/;"	t	namespace:runtime
start	process/machine.cpp	/^machine::start(void)$/;"	f	class:process::machine
start	sched/base.cpp	/^base::start(void)$/;"	f	class:sched::base
start	utils/time.hpp	/^   void start(void) { before = boost::posix_time::microsec_clock::local_time(); }$/;"	f	class:utils::execution_time
start_file	ui/manager.cpp	/^manager::start_file(const string& file, client *cl, bool temp)$/;"	f	class:ui::manager
start_matching	vm/state.cpp	/^state::start_matching(void)$/;"	f	class:vm::state
start_time	sched/mpi.hpp	/^   static utils::unix_timestamp start_time;$/;"	m	class:sched::mpi_sched
start_time	sched/sim.hpp	/^   static utils::unix_timestamp start_time;$/;"	m	class:sched::sim_sched
started_cur	queue/bounded_pqueue.hpp	/^		bool started_cur;$/;"	m	class:queue::bounded_pqueue::const_iterator
startwidth	scripts/plots/active_inactive.py	/^	startwidth = currentwidth$/;"	v
startwidth	scripts/plots/active_inactive.py	/^	startwidth = int(widthgap\/2.0 + widthdivision * time)$/;"	v
stat_db_hits	vm/state.hpp	/^   size_t stat_db_hits;$/;"	m	class:vm::state
stat_enabled	stat/stat.cpp	/^stat_enabled(void)$/;"	f	namespace:statistics
stat_if_failed	vm/state.hpp	/^	size_t stat_if_failed;$/;"	m	class:vm::state
stat_if_tests	vm/state.hpp	/^   size_t stat_if_tests;$/;"	m	class:vm::state
stat_inside_rule	vm/state.hpp	/^	bool stat_inside_rule;$/;"	m	class:vm::state
stat_instructions_executed	vm/state.hpp	/^	size_t stat_instructions_executed;$/;"	m	class:vm::state
stat_moves_executed	vm/state.hpp	/^	size_t stat_moves_executed;$/;"	m	class:vm::state
stat_ops_executed	vm/state.hpp	/^	size_t stat_ops_executed;$/;"	m	class:vm::state
stat_predicate_applications	vm/state.hpp	/^   size_t *stat_predicate_applications;$/;"	m	class:vm::state
stat_predicate_proven	vm/state.hpp	/^   size_t *stat_predicate_proven;$/;"	m	class:vm::state
stat_predicate_success	vm/state.hpp	/^   size_t *stat_predicate_success;$/;"	m	class:vm::state
stat_rules_activated	vm/state.hpp	/^	size_t stat_rules_activated;$/;"	m	class:vm::state
stat_rules_failed	vm/state.hpp	/^   size_t stat_rules_failed;$/;"	m	class:vm::state
stat_rules_ok	vm/state.hpp	/^   size_t stat_rules_ok;$/;"	m	class:vm::state
stat_tuples_used	vm/state.hpp	/^   size_t stat_tuples_used;$/;"	m	class:vm::state
state	sched/base.hpp	/^   vm::state state;$/;"	m	class:sched::base
state	scripts/plots/state_totals.py	/^      state = vec[i]$/;"	v
state	stat/slice.hpp	/^   sched_state state;$/;"	m	class:statistics::slice
state	utils/random.hpp	/^   boost::mt19937 state;$/;"	m	class:utils::randgen
state	vm/state.cpp	/^state::state(sched::base *_sched, vm::all *_all):$/;"	f	class:vm::state
state	vm/state.cpp	/^state::state(vm::all *_all):$/;"	f	class:vm::state
state	vm/state.hpp	/^class state$/;"	c	namespace:vm
static_max_id	db/database.hpp	/^   node::node_id static_max_id(void) const { return original_max_node_id; }$/;"	f	class:db::database
statistics	stat/slice.cpp	/^namespace statistics$/;"	n	file:
statistics	stat/slice.hpp	/^namespace statistics$/;"	n
statistics	stat/slice_set.cpp	/^namespace statistics$/;"	n	file:
statistics	stat/slice_set.hpp	/^namespace statistics$/;"	n
statistics	stat/stat.cpp	/^namespace statistics$/;"	n	file:
statistics	stat/stat.hpp	/^namespace statistics$/;"	n
steal_requests	stat/slice.hpp	/^   size_t steal_requests;$/;"	m	class:statistics::slice
steal_set	sched/thread/steal_set.hpp	/^   explicit steal_set(void)$/;"	f	class:sched::steal_set
steal_set	sched/thread/steal_set.hpp	/^class steal_set: public mem::base$/;"	c	namespace:sched
stl_list	runtime/list.hpp	/^	inline void stl_list(std::list<T>& ls)$/;"	f	class:runtime::cons
stl_list	runtime/list.hpp	/^	std::list<T> stl_list(const list_ptr ls)$/;"	f	class:runtime::cons
stolen_nodes	stat/slice.hpp	/^   size_t stolen_nodes;$/;"	m	class:statistics::slice
stop	utils/time.hpp	/^   void stop(void)$/;"	f	class:utils::execution_time
stop_all	sched/mpi.hpp	/^	static bool stop_all;$/;"	m	class:sched::mpi_sched
stop_all	sched/sim.hpp	/^	static bool stop_all;$/;"	m	class:sched::sim_sched
storage_size	db/tuple.hpp	/^   inline size_t storage_size(void) const$/;"	f	class:db::simple_tuple
str	vm/rule.hpp	/^      const std::string str;$/;"	m	class:vm::rule
str_trie	db/node.cpp	/^typedef pair<string, tuple_trie*> str_trie;$/;"	t	namespace:db	file:
strat_level	vm/defs.hpp	/^typedef size_t strat_level;$/;"	t	namespace:vm
string_size	vm/instr.hpp	/^const size_t string_size = sizeof(int_val);$/;"	m	namespace:vm::instr
string_store	vm/program.hpp	/^	typedef std::vector<runtime::rstring::ptr> string_store;$/;"	t	class:vm::program
sub	queue/bounded_pqueue.hpp	/^		typename C::const_iterator sub;$/;"	m	class:queue::bounded_pqueue::const_iterator
sub_and_fetch	utils/atomic.hpp	/^   inline T sub_and_fetch(const T sub) { return __sync_sub_and_fetch(&elem, sub); }$/;"	f	class:utils::atomic
surface	scripts/heat_color.py	/^surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, WIDTH, HEIGHT)$/;"	v
surface	scripts/heat_count_color.py	/^surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, WIDTH, HEIGHT)$/;"	v
surface	scripts/plots/active_inactive.py	/^surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, WIDTH, HEIGHT)$/;"	v
sys	scripts/check_coloring.py	/^import sys$/;"	i
sys	scripts/count_db_total.py	/^import sys$/;"	i
sys	scripts/csv_benchmarks.py	/^import sys$/;"	i
sys	scripts/csv_step.py	/^import sys$/;"	i
sys	scripts/duplicate_neural_network.py	/^import sys$/;"	i
sys	scripts/generate_binary_tree.py	/^import sys$/;"	i
sys	scripts/generate_chain.py	/^import sys$/;"	i
sys	scripts/generate_cycle.py	/^import sys$/;"	i
sys	scripts/generate_grid.py	/^import sys$/;"	i
sys	scripts/generate_heat_chain.py	/^import sys$/;"	i
sys	scripts/generate_heat_grid.py	/^import sys$/;"	i
sys	scripts/generate_neural_network.py	/^import sys$/;"	i
sys	scripts/generate_no_comm.py	/^import sys$/;"	i
sys	scripts/generate_powergrid.py	/^import sys$/;"	i
sys	scripts/generate_pyramid.py	/^import sys$/;"	i
sys	scripts/generate_random_graph.py	/^import sys$/;"	i
sys	scripts/generate_random_shortest_path.py	/^import sys$/;"	i
sys	scripts/generate_shortest_path.py	/^import sys$/;"	i
sys	scripts/generate_two_shortest_path.py	/^import sys$/;"	i
sys	scripts/heat_color.py	/^import sys$/;"	i
sys	scripts/heat_count_color.py	/^import sys$/;"	i
sys	scripts/lib.py	/^import sys$/;"	i
sys	scripts/plots/active_inactive.py	/^import sys$/;"	i
sys	scripts/plots/state_totals.py	/^import sys$/;"	i
sys	scripts/transform_letter_data.py	/^import sys$/;"	i
sys	scripts/transform_pagerank.py	/^import sys$/;"	i
t	utils/time.hpp	/^      execution_time& t;$/;"	m	class:utils::execution_time::scope
tail	queue/safe_linear_queue.hpp	/^   utils::atomic_ref<special_node*> tail;$/;"	m	class:queue::push_safe_linear_queue
tail	queue/safe_linear_queue.hpp	/^   volatile node *tail;$/;"	m	class:queue::safe_linear_queue
tail	runtime/list.hpp	/^   list_ptr tail;$/;"	m	class:runtime::cons
tail_cons	vm/instr.hpp	/^inline instr_val tail_cons(pcounter pc) { return val_get(pc, 2); }$/;"	f	namespace:vm::instr
tail_dest	vm/instr.hpp	/^inline instr_val tail_dest(pcounter pc) { return val_get(pc, 3); }$/;"	f	namespace:vm::instr
tail_type	vm/instr.hpp	/^inline field_type tail_type(pcounter pc) { return get_list_type(pc, 1); }$/;"	f	namespace:vm::instr
tap_pred	sched/mpi.hpp	/^	static vm::predicate *tap_pred;$/;"	m	class:sched::mpi_sched
tap_pred	sched/sim.hpp	/^	static vm::predicate *tap_pred;$/;"	m	class:sched::sim_sched
target	db/neighbor_agg_configuration.hpp	/^   edge_set target;$/;"	m	class:db::neighbor_agg_configuration
term_barrier	sched/thread/threaded.hpp	/^   static termination_barrier *term_barrier;$/;"	m	class:sched::threaded
terminate_iteration	sched/serial.cpp	/^serial_local::terminate_iteration(void)$/;"	f	class:sched::serial_local
terminate_iteration	sched/sim.cpp	/^sim_sched::terminate_iteration(void)$/;"	f	class:sched::sim_sched
terminate_iteration	sched/sim_tcp.cpp	/^sim_sched::terminate_iteration(void)$/;"	f	class:sched::sim_sched
termination_barrier	sched/thread/termination_barrier.hpp	/^   explicit termination_barrier(const size_t _num_threads):$/;"	f	class:sched::termination_barrier
termination_barrier	sched/thread/termination_barrier.hpp	/^class termination_barrier$/;"	c	namespace:sched
test	db/agg_configuration.cpp	/^agg_configuration::test(vm::tuple *tpl, const field_num agg_field) const$/;"	f	class:db::agg_configuration
test_nil_dest	vm/instr.hpp	/^inline instr_val test_nil_dest(pcounter pc) { return val_get(pc, 2); }$/;"	f	namespace:vm::instr
test_nil_op	vm/instr.hpp	/^inline instr_val test_nil_op(pcounter pc) { return val_get(pc, 1); }$/;"	f	namespace:vm::instr
th	ui/client.hpp	/^      boost::thread *th;$/;"	m	class:ui::client
thread	sched/base.hpp	/^   boost::thread *thread;$/;"	m	class:sched::base
thread_barrier	sched/thread/threaded.hpp	/^   static utils::tree_barrier *thread_barrier;$/;"	m	class:sched::threaded
thread_intrusive_node	sched/nodes/thread_intrusive.hpp	/^   explicit thread_intrusive_node(const db::node::node_id _id, const db::node::node_id _trans, vm::all *all):$/;"	f	class:sched::thread_intrusive_node
thread_intrusive_node	sched/nodes/thread_intrusive.hpp	/^class thread_intrusive_node: public thread_node$/;"	c	namespace:sched
thread_mode	sched/mpi.hpp	/^	static bool thread_mode;$/;"	m	class:sched::mpi_sched
thread_mode	sched/sim.hpp	/^	static bool thread_mode;$/;"	m	class:sched::sim_sched
thread_node	sched/nodes/thread.hpp	/^   explicit thread_node(const db::node::node_id _id, const db::node::node_id _trans, vm::all *all):$/;"	f	class:sched::thread_node
thread_node	sched/nodes/thread.hpp	/^class thread_node: public in_queue_node$/;"	c	namespace:sched
thread_round_state	sched/thread/threaded.hpp	/^   size_t thread_round_state;$/;"	m	class:sched::threaded
thread_round_state	sched/thread/tri_barrier.hpp	/^   THREAD_LOCAL thread_round_state;$/;"	m	class:sched::tri_barrier
thread_sense	utils/tree_barrier.hpp	/^      bool thread_sense;$/;"	m	class:utils::tree_barrier::inner_node
thread_state	sched/thread/state.hpp	/^enum thread_state {$/;"	g	namespace:sched
threaded	sched/thread/threaded.hpp	/^   explicit threaded(void): tstate(THREAD_ACTIVE),$/;"	f	class:sched::threaded
threaded	sched/thread/threaded.hpp	/^class threaded$/;"	c	namespace:sched
threads_synchronize	sched/thread/threaded.hpp	/^#define threads_synchronize(/;"	d
thrnum	scripts/plots/active_inactive.py	/^		thrnum = thrnum + 1$/;"	v
thrnum	scripts/plots/active_inactive.py	/^	thrnum = 0$/;"	v
time	scripts/plots/active_inactive.py	/^	time = time + 1$/;"	v
time	scripts/plots/active_inactive.py	/^time = 0$/;"	v
time_execution	interface.cpp	/^bool time_execution = false;$/;"	v
time_run	benchs/lib/common.sh	/^time_run ()$/;"	f
time_run_n	benchs/lib/common.sh	/^time_run_n ()$/;"	f
timestamp	sched/mpi.hpp	/^      size_t timestamp;$/;"	m	struct:sched::mpi_sched::__anon3
timestamp	sched/nodes/sim.hpp	/^   vm::deterministic_timestamp timestamp;$/;"	m	class:sched::sim_node
timestamp	sched/sim.hpp	/^      size_t timestamp;$/;"	m	struct:sched::sim_sched::__anon4
timestamps	mock-simulator/simulator.cpp	/^static vector<int> timestamps; \/\/ timestamp of each node$/;"	v	file:
timetotal	scripts/plots/active_inactive.py	/^timetotal = len(lines)$/;"	v
tmp_work	sched/mpi.hpp	/^	std::list<work_info> tmp_work;$/;"	m	class:sched::mpi_sched
tmp_work	sched/sim.hpp	/^	std::list<work_info> tmp_work;$/;"	m	class:sched::sim_sched
toScreen	client/springyui.js	/^	toScreen = function(p) {$/;"	f
to_del	db/trie.hpp	/^      bool to_del;$/;"	m	class:db::trie::delete_info
to_delete	db/trie.hpp	/^      inline bool to_delete(void) const { return to_del; }$/;"	f	class:db::trie::delete_info
to_delete	db/trie.hpp	/^   virtual inline bool to_delete(void) const { return false; }$/;"	f	class:db::agg_trie_leaf
to_delete	db/trie.hpp	/^   virtual inline bool to_delete(void) const { return tpl->reached_zero(); }$/;"	f	class:db::tuple_trie_leaf
to_delete	db/tuple.hpp	/^	bool to_delete;$/;"	m	class:db::simple_tuple
to_string	utils/utils.hpp	/^std::string to_string(const T& obj)$/;"	f	namespace:utils
todest	scripts/generate_random_shortest_path.py	/^		todest = todest - 1$/;"	v
todest	scripts/generate_random_shortest_path.py	/^todest = random.randint(3, max(3, total\/10))$/;"	v
top	mem/chunk.hpp	/^   unsigned char *top;$/;"	m	class:mem::chunk
top	queue/bounded_pqueue.hpp	/^	T top(void)$/;"	f	class:queue::bounded_pqueue
top	queue/safe_linear_queue.hpp	/^	inline T top(void)$/;"	f	class:queue::push_safe_linear_queue
top	queue/unsafe_linear_queue.hpp	/^	inline T top(void)$/;"	f	class:queue::unsafe_linear_queue
top	queue/unsafe_linear_queue.hpp	/^	inline T top(void)$/;"	f	class:queue::unsafe_linear_queue_count
top	sched/nodes/sim.hpp	/^   vm::node_val top;$/;"	m	class:sched::sim_node
top_list	queue/bounded_pqueue.hpp	/^	void top_list(std::list<T, Alloc>& vec)$/;"	f	class:queue::bounded_pqueue
top_neighbors	mock-simulator/simulator.cpp	/^static vector<int> top_neighbors, bottom_neighbors;$/;"	v	file:
top_priority	queue/safe_general_pqueue.hpp	/^   inline P top_priority(void) const$/;"	f	class:queue::general_pqueue
total	db/trie.hpp	/^   size_t total;$/;"	m	class:db::trie_hash
total	queue/bounded_pqueue.hpp	/^   A total;$/;"	m	class:queue::bounded_pqueue
total	queue/simple_linear_pqueue.hpp	/^   size_t total;$/;"	m	class:queue::simple_linear_pqueue
total	queue/unsafe_linear_queue.hpp	/^   size_t total;$/;"	m	class:queue::unsafe_linear_queue_count
total	sched/thread/assert.cpp	/^static vector<size_t> total;$/;"	m	namespace:sched	file:
total	sched/thread/tri_barrier.hpp	/^   utils::atomic<size_t> total;$/;"	m	class:sched::tri_barrier
total	scripts/count_db_total.py	/^			total = total + int(d['args'][position-1])$/;"	v
total	scripts/count_db_total.py	/^total = 0$/;"	v
total	scripts/generate_no_comm.py	/^total = int(sys.argv[1])$/;"	v
total	scripts/generate_random_graph.py	/^total = int(sys.argv[1])$/;"	v
total	scripts/generate_random_shortest_path.py	/^total = int(sys.argv[1])$/;"	v
total	scripts/generate_shortest_path.py	/^total = int(sys.argv[1])$/;"	v
total	scripts/generate_two_shortest_path.py	/^total = int(sys.argv[1])$/;"	v
total	scripts/heat_count_color.py	/^	total = read_count_node(data)$/;"	v
total_have	vm/rule_matcher.hpp	/^         size_t total_have;$/;"	m	class:vm::rule_matcher::rule_matcher_obj
total_in_agg	sched/thread/threaded.hpp	/^   static utils::atomic<size_t> total_in_agg;$/;"	m	class:sched::threaded
total_links	scripts/generate_random_shortest_path.py	/^total_links = int(total * random.uniform(1.5, 3.0))$/;"	v
total_needed	vm/rule_matcher.hpp	/^         size_t total_needed;$/;"	m	class:vm::rule_matcher::rule_matcher_obj
totalcount	scripts/heat_count_color.py	/^	totalcount = totalcount + total$/;"	v
totalcount	scripts/heat_count_color.py	/^totalcount = 0$/;"	v
tpl	db/trie.hpp	/^   simple_tuple* tpl;$/;"	m	class:db::tuple_trie_leaf
tr	db/trie.hpp	/^      trie *tr;$/;"	m	class:db::trie::delete_info
tr_node	db/trie.hpp	/^      trie_node *tr_node;$/;"	m	class:db::trie::delete_info
train	scripts/duplicate_neural_network.py	/^	train = row[1:size+1]$/;"	v
transitionweight	scripts/generate_heat_grid.py	/^transitionweight = float(sys.argv[5])$/;"	v
translation	db/database.hpp	/^   map_translate translation;$/;"	m	class:db::database
translation	db/node.hpp	/^   node_id translation;$/;"	m	class:db::node
tree_barrier	utils/tree_barrier.hpp	/^   explicit tree_barrier(size_t s, const size_t _radix = 2):$/;"	f	class:utils::tree_barrier
tree_barrier	utils/tree_barrier.hpp	/^class tree_barrier$/;"	c	namespace:utils
tree_node	queue/bounded_pqueue.hpp	/^   typedef queue_tree_node<C, A> tree_node;$/;"	t	class:queue::bounded_pqueue
tree_node	queue/bounded_pqueue.hpp	/^   typedef queue_tree_node<C, A> tree_node;$/;"	t	class:queue::queue_tree_node
tri_barrier	sched/thread/tri_barrier.hpp	/^   explicit tri_barrier(const size_t _total):$/;"	f	class:sched::tri_barrier
tri_barrier	sched/thread/tri_barrier.hpp	/^class tri_barrier$/;"	c	namespace:sched
trie	db/trie.cpp	/^trie::trie(void):$/;"	f	class:db::trie
trie	db/trie.hpp	/^class trie$/;"	c	namespace:db
trie_comparer	db/node.cpp	/^trie_comparer(const str_trie& p1, const str_trie& p2)$/;"	f	namespace:db
trie_hash	db/trie.cpp	/^trie_hash::trie_hash(const vm::field_type& _type, trie_node *_parent):$/;"	f	class:db::trie_hash
trie_hash	db/trie.hpp	/^class trie_hash: public mem::base$/;"	c	namespace:db
trie_leaf	db/trie.hpp	/^   explicit trie_leaf(void)$/;"	f	class:db::trie_leaf
trie_leaf	db/trie.hpp	/^class trie_leaf: public mem::base$/;"	c	namespace:db
trie_node	db/trie.hpp	/^   explicit trie_node(const vm::tuple_field& _data):$/;"	f	class:db::trie_node
trie_node	db/trie.hpp	/^   explicit trie_node(void): \/\/ no data$/;"	f	class:db::trie_node
trie_node	db/trie.hpp	/^class trie_node: public mem::base$/;"	c	namespace:db
try_lock	utils/spinlock.hpp	/^   inline bool try_lock(void)$/;"	f	class:utils::spinlock
try_plot_part	scripts/plots/plot_dir.sh	/^try_plot_part ()$/;"	f
tstate	sched/thread/threaded.hpp	/^   volatile thread_state tstate;$/;"	m	class:sched::threaded
tuple	process/work.hpp	/^   db::simple_tuple *tuple;$/;"	m	class:process::node_work
tuple	vm/state.hpp	/^   vm::tuple *tuple;$/;"	m	class:vm::state
tuple	vm/tuple.cpp	/^tuple::tuple(const predicate* _pred):$/;"	f	class:vm::tuple
tuple	vm/tuple.cpp	/^tuple::tuple(void):$/;"	f	class:vm::tuple
tuple	vm/tuple.hpp	/^class tuple: public mem::base$/;"	c	namespace:vm
tuple_aggregate	db/tuple_aggregate.hpp	/^   explicit tuple_aggregate(const vm::predicate *_pred): pred(_pred) {}$/;"	f	class:db::tuple_aggregate
tuple_aggregate	db/tuple_aggregate.hpp	/^class tuple_aggregate: public mem::base$/;"	c	namespace:db
tuple_field	vm/defs.hpp	/^} tuple_field;$/;"	t	namespace:vm	typeref:union:vm::__anon7
tuple_for_assertion	vm/state.cpp	/^tuple_for_assertion(db::simple_tuple *stpl)$/;"	f	namespace:vm
tuple_leaf	vm/state.hpp	/^   db::tuple_trie_leaf *tuple_leaf;$/;"	m	class:vm::state
tuple_list	vm/tuple.hpp	/^typedef std::list<tuple*, mem::allocator<vm::tuple*> > tuple_list;$/;"	t	namespace:vm
tuple_pqueue	sched/nodes/sim.hpp	/^	queue::heap_queue<db::simple_tuple*> tuple_pqueue; \/\/ for deterministic computation$/;"	m	class:sched::sim_node
tuple_queue	vm/state.hpp	/^	db::simple_tuple *tuple_queue;$/;"	m	class:vm::state
tuple_size	vm/instr.hpp	/^const size_t tuple_size = 0;$/;"	m	namespace:vm::instr
tuple_size	vm/predicate.hpp	/^   size_t tuple_size;$/;"	m	class:vm::predicate
tuple_sorter	vm/exec.cpp	/^	explicit tuple_sorter(const field_num _field, const predicate *_pred):$/;"	f	class:vm::tuple_sorter
tuple_sorter	vm/exec.cpp	/^class tuple_sorter$/;"	c	namespace:vm	file:
tuple_trie	db/trie.hpp	/^   explicit tuple_trie(const vm::predicate *_pred): trie(), pred(_pred) { basic_invariants(); }$/;"	f	class:db::tuple_trie
tuple_trie	db/trie.hpp	/^class tuple_trie: public trie, public mem::base$/;"	c	namespace:db
tuple_trie_iterator	db/trie.hpp	/^   explicit tuple_trie_iterator(tuple_trie_leaf *first_leaf):$/;"	f	class:db::tuple_trie_iterator
tuple_trie_iterator	db/trie.hpp	/^   explicit tuple_trie_iterator(void): \/\/ end iterator$/;"	f	class:db::tuple_trie_iterator
tuple_trie_iterator	db/trie.hpp	/^class tuple_trie_iterator: public mem::base$/;"	c	namespace:db
tuple_trie_leaf	db/trie.hpp	/^   explicit tuple_trie_leaf(simple_tuple *_tpl):$/;"	f	class:db::tuple_trie_leaf
tuple_trie_leaf	db/trie.hpp	/^class tuple_trie_leaf: public trie_leaf$/;"	c	namespace:db
tuple_vector	db/trie.hpp	/^typedef std::vector<tuple_trie_leaf*, mem::allocator<tuple_trie_leaf*> > tuple_vector;$/;"	t	namespace:db
tuples	db/node.hpp	/^   simple_tuple_map tuples;$/;"	m	class:db::node
typ	queue/safe_complex_pqueue.hpp	/^	heap_type typ;$/;"	m	class:queue::intrusive_safe_complex_pqueue
typ	queue/safe_simple_pqueue.hpp	/^	heap_type typ;$/;"	m	class:queue::heap_queue
type	db/trie.hpp	/^   const vm::field_type type;$/;"	m	class:db::trie_hash
type	queue/bounded_pqueue.hpp	/^	typedef bounded_pqueue<T, intrusive_unsafe_double_queue<T>, size_t> type;$/;"	t	struct:queue::intrusive_unsafe_double_bounded_pqueue
type	queue/bounded_pqueue.hpp	/^   typedef bounded_pqueue<T, push_safe_linear_queue<T>, utils::atomic<size_t> > type;$/;"	t	struct:queue::safe_bounded_pqueue
type	queue/bounded_pqueue.hpp	/^   typedef bounded_pqueue<T, unsafe_linear_queue<T>, size_t> type;$/;"	t	struct:queue::unsafe_bounded_pqueue
type	vm/match.hpp	/^   field_type type;$/;"	m	struct:vm::match_field
type	vm/predicate.hpp	/^      aggregate_type type;$/;"	m	struct:vm::predicate::__anon11
type_error	vm/types.hpp	/^    explicit type_error(const std::string& msg) :$/;"	f	class:vm::type_error
type_error	vm/types.hpp	/^class type_error : public std::runtime_error {$/;"	c	namespace:vm
type_stack	vm/match.hpp	/^typedef utils::stack<vm::field_type> type_stack;$/;"	t	namespace:vm
types	vm/match.hpp	/^   std::vector<match_field, mem::allocator<match_field> > types;$/;"	m	class:vm::match
types	vm/predicate.hpp	/^   std::vector<field_type> types;$/;"	m	class:vm::predicate
typs_stack	db/trie.cpp	/^   match_type_stack typs_stack;$/;"	m	struct:db::continuation_frame	file:
ui	ui/client.cpp	/^namespace ui$/;"	n	file:
ui	ui/client.hpp	/^namespace ui$/;"	n
ui	ui/manager.cpp	/^namespace ui$/;"	n	file:
ui	ui/manager.hpp	/^namespace ui$/;"	n
uint_size	vm/instr.hpp	/^const size_t uint_size = sizeof(int_val);$/;"	m	namespace:vm::instr
uint_val	vm/defs.hpp	/^typedef uint32_t uint_val;$/;"	t	namespace:vm
unix_timestamp	utils/time.hpp	/^typedef uint64_t unix_timestamp;$/;"	t	namespace:utils
unlock	utils/spinlock.hpp	/^   inline void unlock(void)$/;"	f	class:utils::spinlock
unmark_generated_tuples	vm/state.cpp	/^state::unmark_generated_tuples(void)$/;"	f	class:vm::state
unpack	db/tuple.cpp	/^simple_tuple::unpack(byte *buf, const size_t buf_size, int *pos, vm::program *prog)$/;"	f	class:db::simple_tuple
unpack	runtime/list.hpp	/^	list_ptr unpack(utils::byte *buf, const size_t buf_size, int *pos)$/;"	f	class:runtime::cons
unpack	utils/serialization.hpp	/^void unpack(byte *buf, const size_t buf_size, int *pos, void *data, const size_t size)$/;"	f	namespace:utils
unpack	vm/tuple.cpp	/^tuple::unpack(byte *buf, const size_t buf_size, int *pos, vm::program *prog)$/;"	f	class:vm::tuple
unsafe_bounded_pqueue	queue/bounded_pqueue.hpp	/^struct unsafe_bounded_pqueue$/;"	s	namespace:queue
unsafe_linear_queue	queue/unsafe_linear_queue.hpp	/^   explicit unsafe_linear_queue(void):$/;"	f	class:queue::unsafe_linear_queue
unsafe_linear_queue	queue/unsafe_linear_queue.hpp	/^class unsafe_linear_queue$/;"	c	namespace:queue
unsafe_linear_queue_count	queue/unsafe_linear_queue.hpp	/^   explicit unsafe_linear_queue_count(void):$/;"	f	class:queue::unsafe_linear_queue_count
unsafe_linear_queue_count	queue/unsafe_linear_queue.hpp	/^class unsafe_linear_queue_count$/;"	c	namespace:queue
unsafe_queue_node	queue/node.hpp	/^class unsafe_queue_node: public mem::base$/;"	c	namespace:queue
unsafe_static_node	sched/nodes/unsafe_static.hpp	/^   explicit unsafe_static_node(const db::node::node_id _id, const db::node::node_id _trans):$/;"	f	class:sched::unsafe_static_node
unsafe_static_node	sched/nodes/unsafe_static.hpp	/^class unsafe_static_node: public in_queue_node$/;"	c	namespace:sched
update	utils/interval.hpp	/^   void update(const T& val)$/;"	f	class:utils::interval
upper_log2	utils/utils.hpp	/^T upper_log2(const T n)$/;"	f	namespace:utils
use_local_tuples	vm/state.hpp	/^   bool use_local_tuples;$/;"	m	class:vm::state
use_rules	process/work.hpp	/^   bool use_rules;$/;"	m	class:process::work
used_linear_tuples	vm/state.hpp	/^   list_linear used_linear_tuples;$/;"	m	class:vm::state
using_new_linear_tuple	vm/state.cpp	/^state::using_new_linear_tuple(db::tuple_trie_leaf *leaf)$/;"	f	class:vm::state
using_rules	process/work.hpp	/^   inline bool using_rules(void) const { return use_rules; }$/;"	f	class:process::work
utils	utils/atomic.hpp	/^namespace utils$/;"	n
utils	utils/csv_line.hpp	/^namespace utils$/;"	n
utils	utils/fs.cpp	/^namespace utils$/;"	n	file:
utils	utils/fs.hpp	/^namespace utils$/;"	n
utils	utils/interval.hpp	/^namespace utils$/;"	n
utils	utils/random.hpp	/^namespace utils$/;"	n
utils	utils/serialization.hpp	/^namespace utils$/;"	n
utils	utils/simple_barrier.hpp	/^namespace utils$/;"	n
utils	utils/spinlock.hpp	/^namespace utils$/;"	n
utils	utils/stack.hpp	/^namespace utils$/;"	n
utils	utils/time.hpp	/^namespace utils$/;"	n
utils	utils/tree_barrier.hpp	/^namespace utils$/;"	n
utils	utils/types.cpp	/^namespace utils$/;"	n	file:
utils	utils/types.hpp	/^namespace utils$/;"	n
utils	utils/utils.cpp	/^namespace utils$/;"	n	file:
utils	utils/utils.hpp	/^namespace utils$/;"	n
v	scripts/plots/active_inactive.py	/^			v = int(thr)$/;"	v
vacant_pred	sched/mpi.hpp	/^	static vm::predicate *vacant_pred;$/;"	m	class:sched::mpi_sched
vacant_pred	sched/sim.hpp	/^	static vm::predicate *vacant_pred;$/;"	m	class:sched::sim_sched
val	queue/safe_simple_pqueue.hpp	/^		heap_priority val;$/;"	m	class:queue::heap_queue::heap_object
val	scripts/generate_neural_network.py	/^      val = row[i]$/;"	v
val	scripts/generate_neural_network.py	/^      val = row[num_input + o]$/;"	v
val_field_num	vm/instr.hpp	/^inline field_num val_field_num(const pcounter x) { return *x & 0xff; }$/;"	f	namespace:vm::instr
val_field_reg	vm/instr.hpp	/^inline reg_num val_field_reg(const pcounter x) { return *(x + 1) & 0x1f; }$/;"	f	namespace:vm::instr
val_get	vm/instr.hpp	/^inline instr_val val_get(pcounter x, size_t off) { return (instr_val)(*(x + off) & 0x3f); }$/;"	f	namespace:vm::instr
val_is_arg	vm/instr.hpp	/^inline bool val_is_arg(const instr_val x) { return x == 0x07; }$/;"	f	namespace:vm::instr
val_is_const	vm/instr.hpp	/^inline bool val_is_const(const instr_val x) { return x == 0x08; }$/;"	f	namespace:vm::instr
val_is_field	vm/instr.hpp	/^inline bool val_is_field(const instr_val x) { return x == 0x02; }$/;"	f	namespace:vm::instr
val_is_float	vm/instr.hpp	/^inline bool val_is_float(const instr_val x) { return x == 0x00; }$/;"	f	namespace:vm::instr
val_is_host	vm/instr.hpp	/^inline bool val_is_host(const instr_val x) { return x == 0x03; }$/;"	f	namespace:vm::instr
val_is_int	vm/instr.hpp	/^inline bool val_is_int(const instr_val x) { return x == 0x01; }$/;"	f	namespace:vm::instr
val_is_nil	vm/instr.hpp	/^inline bool val_is_nil(const instr_val x) { return x == 0x04; }$/;"	f	namespace:vm::instr
val_is_node	vm/instr.hpp	/^inline bool val_is_node(const instr_val x) { return x == 0x05; }$/;"	f	namespace:vm::instr
val_is_reg	vm/instr.hpp	/^inline bool val_is_reg(const instr_val x) { return x & 0x20; }$/;"	f	namespace:vm::instr
val_is_string	vm/instr.hpp	/^inline bool val_is_string(const instr_val x) { return x == 0x06; }$/;"	f	namespace:vm::instr
val_is_tuple	vm/instr.hpp	/^inline bool val_is_tuple(const instr_val x) { return x == 0x1f; }$/;"	f	namespace:vm::instr
val_reg	vm/instr.hpp	/^inline reg_num val_reg(const instr_val x) { return x & 0x1f; }$/;"	f	namespace:vm::instr
val_size	vm/instr.hpp	/^const size_t val_size = 1;$/;"	m	namespace:vm::instr
val_stack	vm/match.hpp	/^typedef utils::stack<vm::tuple_field> val_stack;$/;"	t	namespace:vm
val_string	vm/instr.cpp	/^val_string(const instr_val v, pcounter *pm, const program *prog)$/;"	f	namespace:vm::instr
valid_temp_file	ui/manager.cpp	/^valid_temp_file(string& file)$/;"	f	namespace:ui
vals	db/agg_configuration.hpp	/^   tuple_trie vals;$/;"	m	class:db::agg_configuration
vals	db/tuple_aggregate.hpp	/^   agg_trie vals;$/;"	m	class:db::tuple_aggregate
vals	vm/match.hpp	/^   std::vector<tuple_field, mem::allocator<tuple_field> > vals;$/;"	m	class:vm::match
vals_stack	db/trie.cpp	/^   match_val_stack vals_stack;$/;"	m	struct:db::continuation_frame	file:
value_type	mem/allocator.hpp	/^   typedef T value_type;$/;"	t	class:mem::allocator
vec	queue/safe_simple_pqueue.hpp	/^		const heap_vector *vec;$/;"	m	class:queue::heap_queue::const_iterator
vec	scripts/plots/active_inactive.py	/^	vec = line.split(' ')[1:]$/;"	v
vec	scripts/plots/state_totals.py	/^   vec = line.split(' ')$/;"	v
vec	scripts/plots/state_totals.py	/^   vec = vec[1:] # skip timestamp$/;"	v
vector_slices	stat/slice_set.hpp	/^   typedef std::vector<list_slices> vector_slices;$/;"	t	class:statistics::slice_set
vm	external/core.cpp	/^namespace vm$/;"	n	file:
vm	external/core.hpp	/^namespace vm$/;"	n
vm	external/lists.cpp	/^namespace vm$/;"	n	file:
vm	external/lists.hpp	/^namespace vm$/;"	n
vm	external/math.cpp	/^namespace vm$/;"	n	file:
vm	external/math.hpp	/^namespace vm$/;"	n
vm	external/others.cpp	/^namespace vm$/;"	n	file:
vm	external/others.hpp	/^namespace vm$/;"	n
vm	external/strings.cpp	/^namespace vm$/;"	n	file:
vm	external/strings.hpp	/^namespace vm$/;"	n
vm	external/utils.cpp	/^namespace vm$/;"	n	file:
vm	external/utils.hpp	/^namespace vm$/;"	n
vm	ui/manager.hpp	/^namespace vm$/;"	n
vm	vm/all.hpp	/^namespace vm$/;"	n
vm	vm/defs.hpp	/^namespace vm {$/;"	n
vm	vm/exec.cpp	/^namespace vm$/;"	n	file:
vm	vm/exec.hpp	/^namespace vm$/;"	n
vm	vm/external.cpp	/^namespace vm$/;"	n	file:
vm	vm/external.hpp	/^namespace vm$/;"	n
vm	vm/instr.cpp	/^namespace vm {$/;"	n	file:
vm	vm/instr.hpp	/^namespace vm {$/;"	n
vm	vm/match.hpp	/^namespace vm$/;"	n
vm	vm/predicate.cpp	/^namespace vm {$/;"	n	file:
vm	vm/predicate.hpp	/^namespace vm {$/;"	n
vm	vm/program.cpp	/^namespace vm {$/;"	n	file:
vm	vm/program.hpp	/^namespace vm {$/;"	n
vm	vm/rule.cpp	/^namespace vm$/;"	n	file:
vm	vm/rule.hpp	/^namespace vm$/;"	n
vm	vm/rule_matcher.cpp	/^namespace vm$/;"	n	file:
vm	vm/rule_matcher.hpp	/^namespace vm$/;"	n
vm	vm/state.cpp	/^namespace vm$/;"	n	file:
vm	vm/state.hpp	/^namespace vm {$/;"	n
vm	vm/tuple.cpp	/^namespace vm$/;"	n	file:
vm	vm/tuple.hpp	/^namespace vm$/;"	n
vm	vm/types.cpp	/^namespace vm {$/;"	n	file:
vm	vm/types.hpp	/^namespace vm {$/;"	n
vm_exec_error	vm/exec.hpp	/^    explicit vm_exec_error(const std::string& msg) :$/;"	f	class:vm::vm_exec_error
vm_exec_error	vm/exec.hpp	/^class vm_exec_error : public std::runtime_error {$/;"	c	namespace:vm
wait	utils/simple_barrier.hpp	/^   inline void wait(void)$/;"	f	class:utils::simple_barrier
wait	utils/tree_barrier.hpp	/^      inline void wait(void)$/;"	f	class:utils::tree_barrier::inner_node
wait	utils/tree_barrier.hpp	/^   inline void wait(const size_t id)$/;"	f	class:utils::tree_barrier
wait_for_done	ui/manager.cpp	/^manager::wait_for_done(void)$/;"	f	class:ui::manager
wait_for_next	ui/manager.cpp	/^manager::wait_for_next(void)$/;"	f	class:ui::manager
weight	scripts/generate_heat_chain.py	/^			weight = 0.0 # keep it above 0.0$/;"	v
weight	scripts/generate_heat_chain.py	/^		weight = float(inverse * inverse) \/ base$/;"	v
weight	scripts/generate_heat_chain.py	/^		weight = weight - drop_constant$/;"	v
weight	scripts/generate_heat_chain.py	/^	weight = 1.0$/;"	v
weight	scripts/generate_shortest_path.py	/^		weight = generate_weight()$/;"	v
weight	scripts/lib.py	/^weight = None$/;"	v
west	sched/nodes/sim.hpp	/^   vm::node_val west;$/;"	m	class:sched::sim_node
west_neighbors	mock-simulator/simulator.cpp	/^static vector<int> west_neighbors, east_neighbors;$/;"	v	file:
width	scripts/generate_grid.py	/^   width = int(lenvec[0])$/;"	v
widthavailable	scripts/plots/active_inactive.py	/^widthavailable = WIDTH - widthgap$/;"	v
widthdivision	scripts/plots/active_inactive.py	/^widthdivision = widthavailable\/float(timetotal)$/;"	v
widthgap	scripts/plots/active_inactive.py	/^widthgap = 10$/;"	v
widthlength	scripts/plots/active_inactive.py	/^	widthlength = endwidth - startwidth$/;"	v
will_delete	db/tuple.hpp	/^   inline void will_delete(void)$/;"	f	class:db::simple_tuple
will_not_delete	db/tuple.hpp	/^   inline void will_not_delete(void)$/;"	f	class:db::simple_tuple
wipeout	db/trie.cpp	/^trie::wipeout(void)$/;"	f	class:db::trie
wipeout	db/tuple.hpp	/^   static void wipeout(simple_tuple *stpl) { delete stpl->get_tuple(); delete stpl; }$/;"	f	class:db::simple_tuple
work	process/work.hpp	/^   explicit work(db::node *_node, db::simple_tuple *_tuple):$/;"	f	class:process::work
work	process/work.hpp	/^   explicit work(db::node *_node, db::simple_tuple *_tuple,$/;"	f	class:process::work
work	process/work.hpp	/^   explicit work(void):$/;"	f	class:process::work
work	process/work.hpp	/^class work: public node_work$/;"	c	namespace:process
work	sched/mpi.hpp	/^      process::work work;$/;"	m	struct:sched::mpi_sched::__anon3
work	sched/sim.hpp	/^      process::work work;$/;"	m	struct:sched::sim_sched::__anon4
work_info	sched/mpi.hpp	/^   } work_info;$/;"	t	class:sched::mpi_sched	typeref:struct:sched::mpi_sched::__anon3
work_info	sched/sim.hpp	/^   } work_info;$/;"	t	class:sched::sim_sched	typeref:struct:sched::sim_sched::__anon4
work_modifier	process/work.hpp	/^typedef utils::byte work_modifier;$/;"	t	namespace:process
work_queue	stat/slice.hpp	/^   size_t work_queue;$/;"	m	class:statistics::slice
worker_val	vm/defs.hpp	/^typedef uint32_t worker_val;$/;"	t	namespace:vm
world	sched/mpi.cpp	/^            boost::mpi::communicator world;$/;"	m	class:sched::mpi	file:
write	stat/slice_set.cpp	/^slice_set::write(const string& file, const scheduler_type type, vm::all *all) const$/;"	f	class:statistics::slice_set
write_accel	mock-simulator/simulator.cpp	/^write_accel(int sock, int node, int f)$/;"	f	file:
write_add_neighbor	mock-simulator/simulator.cpp	/^write_add_neighbor(int sock, int in, int out, face_t side)$/;"	f	file:
write_coord	scripts/generate_heat_grid.py	/^def write_coord(id, row, col):$/;"	f
write_create_n_nodes	mock-simulator/simulator.cpp	/^write_create_n_nodes(int sock, const int n)$/;"	f	file:
write_dedgew	scripts/generate_heat_chain.py	/^from lib import write_dedgew$/;"	i
write_dedgew	scripts/generate_heat_grid.py	/^from lib import write_dedgew, write_edgew$/;"	i
write_dedgew	scripts/lib.py	/^def write_dedgew(a, b, w):$/;"	f
write_edge	scripts/generate_binary_tree.py	/^from lib import write_edge$/;"	i
write_edge	scripts/generate_chain.py	/^from lib import write_edge$/;"	i
write_edge	scripts/generate_cycle.py	/^from lib import write_edge$/;"	i
write_edge	scripts/generate_grid.py	/^from lib import write_edge$/;"	i
write_edge	scripts/generate_pyramid.py	/^from lib import write_edge$/;"	i
write_edge	scripts/lib.py	/^def write_edge(a, b):$/;"	f
write_edgew	scripts/generate_heat_grid.py	/^from lib import write_dedgew, write_edgew$/;"	i
write_edgew	scripts/lib.py	/^def write_edgew(a, b, w):$/;"	f
write_efficiency_file	scripts/csv_benchmarks.py	/^def write_efficiency_file(file, bench, bench_data):$/;"	f
write_efficiency_files	scripts/csv_benchmarks.py	/^def write_efficiency_files():$/;"	f
write_general	stat/slice_set.cpp	/^slice_set::write_general(const string& file, const string& title,$/;"	f	class:statistics::slice_set
write_header	scripts/csv_benchmarks.py	/^def write_header(writer):$/;"	f
write_header	scripts/csv_step.py	/^def write_header(w):$/;"	f
write_header	stat/slice_set.cpp	/^write_header(ofstream& out, const string& header, vm::all *all)$/;"	f	namespace:statistics
write_heat	scripts/generate_heat_grid.py	/^def write_heat(id, heat):$/;"	f
write_inner	scripts/generate_heat_grid.py	/^def write_inner(id):$/;"	f
write_inout	scripts/transform_pagerank.py	/^def write_inout(i, o):$/;"	f
write_line	scripts/generate_grid.py	/^def write_line(line):$/;"	f
write_mix_speedup_file	scripts/csv_benchmarks.py	/^def write_mix_speedup_file(file, bench, bench_data):$/;"	f
write_mix_speedup_files	scripts/csv_benchmarks.py	/^def write_mix_speedup_files():$/;"	f
write_priority_queue	stat/slice_set.cpp	/^slice_set::write_priority_queue(const string& file, vm::all *all) const$/;"	f	class:statistics::slice_set
write_processed_facts	stat/slice_set.cpp	/^slice_set::write_processed_facts(const string& file, vm::all *all) const$/;"	f	class:statistics::slice_set
write_pyramid	scripts/generate_pyramid.py	/^def write_pyramid(depth, z):$/;"	f
write_remove_neighbor	mock-simulator/simulator.cpp	/^write_remove_neighbor(int sock, int in, face_t side)$/;"	f	file:
write_run_node	mock-simulator/simulator.cpp	/^write_run_node(int sock, int node)$/;"	f	file:
write_sent_facts	stat/slice_set.cpp	/^slice_set::write_sent_facts(const string& file, vm::all *all) const$/;"	f	class:statistics::slice_set
write_shake	mock-simulator/simulator.cpp	/^write_shake(int sock, int node, int x, int y, int z)$/;"	f	file:
write_slice	sched/base.hpp	/^   virtual void write_slice(statistics::slice& sl) const$/;"	f	class:sched::base
write_speedup_file	scripts/csv_benchmarks.py	/^def write_speedup_file(file, bench, bench_data):$/;"	f
write_speedup_files	scripts/csv_benchmarks.py	/^def write_speedup_files():$/;"	f
write_state	stat/slice_set.cpp	/^slice_set::write_state(const string& file, vm::all *all) const$/;"	f	class:statistics::slice_set
write_steal_requests	stat/slice_set.cpp	/^slice_set::write_steal_requests(const string& file, vm::all *all) const$/;"	f	class:statistics::slice_set
write_stolen_nodes	stat/slice_set.cpp	/^slice_set::write_stolen_nodes(const string& file, vm::all *all) const$/;"	f	class:statistics::slice_set
write_stop	mock-simulator/simulator.cpp	/^write_stop(int sock)$/;"	f	file:
write_tap	mock-simulator/simulator.cpp	/^write_tap(int sock, int node)$/;"	f	file:
write_time_file	scripts/csv_benchmarks.py	/^def write_time_file(file, bench, bench_data):$/;"	f
write_time_files	scripts/csv_benchmarks.py	/^def write_time_files():$/;"	f
write_to_socket	mock-simulator/simulator.cpp	/^write_to_socket(int sock, message_type *data)$/;"	f	file:
write_use_threads	mock-simulator/simulator.cpp	/^write_use_threads(int sock)$/;"	f	file:
write_weights	scripts/generate_heat_grid.py	/^def write_weights(id, otherid, isouter, isotherouter):$/;"	f
write_work_queue	stat/slice_set.cpp	/^slice_set::write_work_queue(const string& file, vm::all *all) const$/;"	f	class:statistics::slice_set
writer	scripts/duplicate_neural_network.py	/^writer = csv.writer(open(output, 'wb'), delimiter=',')$/;"	v
writer	scripts/plots/state_totals.py	/^writer = csv.writer(open(outputfile, 'wb'), delimiter=' ')$/;"	v
zero_active_threads	sched/thread/termination_barrier.hpp	/^   inline bool zero_active_threads(void) const { return active_threads == 0; }$/;"	f	class:sched::termination_barrier
zero_refs	runtime/list.hpp	/^   inline bool zero_refs(void) const { return refs == 0; }$/;"	f	class:runtime::cons
zero_refs	runtime/string.hpp	/^	inline bool zero_refs(void) const$/;"	f	class:runtime::rstring
~agg_configuration	db/agg_configuration.cpp	/^agg_configuration::~agg_configuration(void)$/;"	f	class:db::agg_configuration
~agg_trie	db/trie.hpp	/^   virtual ~agg_trie(void) {}$/;"	f	class:db::agg_trie
~agg_trie_leaf	db/trie.cpp	/^agg_trie_leaf::~agg_trie_leaf(void)$/;"	f	class:db::agg_trie_leaf
~allocator	mem/allocator.hpp	/^   inline ~allocator(void) {}$/;"	f	class:mem::allocator
~atomic	utils/atomic.hpp	/^   ~atomic(void) {}$/;"	f	class:utils::atomic
~atomic_ref	utils/atomic.hpp	/^   ~atomic_ref(void) {}$/;"	f	class:utils::atomic_ref
~base	mem/base.hpp	/^   virtual ~base(void) {}$/;"	f	class:mem::base
~base	sched/base.cpp	/^base::~base(void)$/;"	f	class:sched::base
~bounded_pqueue	queue/bounded_pqueue.hpp	/^   ~bounded_pqueue(void)$/;"	f	class:queue::bounded_pqueue
~chunk	mem/chunk.hpp	/^   ~chunk(void)$/;"	f	class:mem::chunk
~chunkgroup	mem/chunkgroup.hpp	/^   ~chunkgroup(void)$/;"	f	class:mem::chunkgroup
~csv_line	utils/csv_line.hpp	/^   virtual ~csv_line(void) {}$/;"	f	class:utils::csv_line
~database	db/database.cpp	/^database::~database(void)$/;"	f	class:database
~execution_time	utils/time.hpp	/^   ~execution_time(void) {}   $/;"	f	class:utils::execution_time
~external_function	vm/external.cpp	/^external_function::~external_function(void)$/;"	f	class:vm::external_function
~heap_queue	queue/safe_simple_pqueue.hpp	/^	~heap_queue(void) {}$/;"	f	class:queue::heap_queue
~in_queue_node	sched/nodes/in_queue.hpp	/^   virtual ~in_queue_node(void) { }$/;"	f	class:sched::in_queue_node
~intrusive_safe_complex_pqueue	queue/safe_complex_pqueue.hpp	/^	~intrusive_safe_complex_pqueue(void)$/;"	f	class:queue::intrusive_safe_complex_pqueue
~intrusive_safe_double_queue	queue/safe_double_queue.hpp	/^   ~intrusive_safe_double_queue(void)$/;"	f	class:queue::intrusive_safe_double_queue
~intrusive_unsafe_double_queue	queue/unsafe_double_queue.hpp	/^   ~intrusive_unsafe_double_queue(void)$/;"	f	class:queue::intrusive_unsafe_double_queue
~machine	process/machine.cpp	/^machine::~machine(void)$/;"	f	class:process::machine
~manager	ui/manager.cpp	/^manager::~manager(void)$/;"	f	class:ui::manager
~neighbor_agg_configuration	db/neighbor_agg_configuration.hpp	/^   virtual ~neighbor_agg_configuration(void) {}$/;"	f	class:db::neighbor_agg_configuration
~node	db/node.cpp	/^node::~node(void)$/;"	f	class:db::node
~node_work	process/work.hpp	/^   ~node_work(void) {}$/;"	f	class:process::node_work
~pool	mem/pool.hpp	/^   ~pool(void)$/;"	f	class:mem::pool
~predicate	vm/predicate.cpp	/^predicate::~predicate(void)$/;"	f	class:vm::predicate
~program	vm/program.cpp	/^program::~program(void)$/;"	f	class:vm::program
~push_safe_linear_queue	queue/safe_linear_queue.hpp	/^   virtual ~push_safe_linear_queue(void)$/;"	f	class:queue::push_safe_linear_queue
~queue_tree_node	queue/bounded_pqueue.hpp	/^   ~queue_tree_node(void)$/;"	f	class:queue::queue_tree_node
~rule	vm/rule.hpp	/^		~rule(void) { delete []code; }$/;"	f	class:vm::rule
~safe_linear_queue	queue/safe_linear_queue.hpp	/^   ~safe_linear_queue(void)$/;"	f	class:queue::safe_linear_queue
~scope	utils/time.hpp	/^      ~scope(void) { t.stop(); }$/;"	f	class:utils::execution_time::scope
~serial_local	sched/serial.hpp	/^   virtual ~serial_local(void) {}$/;"	f	class:sched::serial_local
~serial_node	sched/nodes/serial.hpp	/^   virtual ~serial_node(void) { }$/;"	f	class:sched::serial_node
~sim_node	sched/nodes/sim.hpp	/^   virtual ~sim_node(void) { }$/;"	f	class:sched::sim_node
~sim_sched	sched/sim.cpp	/^sim_sched::~sim_sched(void)$/;"	f	class:sched::sim_sched
~sim_sched	sched/sim_tcp.cpp	/^sim_sched::~sim_sched(void)$/;"	f	class:sched::sim_sched
~simple_linear_pqueue	queue/simple_linear_pqueue.hpp	/^   ~simple_linear_pqueue(void)$/;"	f	class:queue::simple_linear_pqueue
~simple_tuple	db/tuple.cpp	/^simple_tuple::~simple_tuple(void)$/;"	f	class:db::simple_tuple
~slice	stat/slice.hpp	/^   virtual ~slice(void) {}$/;"	f	class:statistics::slice
~slice_set	stat/slice_set.hpp	/^   virtual ~slice_set(void) {}$/;"	f	class:statistics::slice_set
~state	vm/state.cpp	/^state::~state(void)$/;"	f	class:vm::state
~steal_set	sched/thread/steal_set.hpp	/^   ~steal_set(void)$/;"	f	class:sched::steal_set
~termination_barrier	sched/thread/termination_barrier.hpp	/^   ~termination_barrier(void) {}$/;"	f	class:sched::termination_barrier
~thread_intrusive_node	sched/nodes/thread_intrusive.hpp	/^   virtual ~thread_intrusive_node(void) {}$/;"	f	class:sched::thread_intrusive_node
~thread_node	sched/nodes/thread.hpp	/^   virtual ~thread_node(void) { }$/;"	f	class:sched::thread_node
~threaded	sched/thread/threaded.hpp	/^   virtual ~threaded(void)$/;"	f	class:sched::threaded
~trie	db/trie.cpp	/^trie::~trie(void)$/;"	f	class:db::trie
~trie_hash	db/trie.cpp	/^trie_hash::~trie_hash(void)$/;"	f	class:db::trie_hash
~trie_leaf	db/trie.hpp	/^   virtual ~trie_leaf(void)$/;"	f	class:db::trie_leaf
~trie_node	db/trie.cpp	/^trie_node::~trie_node(void)$/;"	f	class:db::trie_node
~tuple	vm/tuple.cpp	/^tuple::~tuple(void)$/;"	f	class:vm::tuple
~tuple_aggregate	db/tuple_aggregate.cpp	/^tuple_aggregate::~tuple_aggregate(void)$/;"	f	class:db::tuple_aggregate
~tuple_trie	db/trie.hpp	/^   virtual ~tuple_trie(void) {}$/;"	f	class:db::tuple_trie
~tuple_trie_leaf	db/trie.hpp	/^   virtual ~tuple_trie_leaf(void)$/;"	f	class:db::tuple_trie_leaf
~unsafe_linear_queue	queue/unsafe_linear_queue.hpp	/^   virtual ~unsafe_linear_queue(void)$/;"	f	class:queue::unsafe_linear_queue
~unsafe_linear_queue_count	queue/unsafe_linear_queue.hpp	/^   ~unsafe_linear_queue_count(void)$/;"	f	class:queue::unsafe_linear_queue_count
~unsafe_static_node	sched/nodes/unsafe_static.hpp	/^   virtual ~unsafe_static_node(void) { }$/;"	f	class:sched::unsafe_static_node
~work	process/work.hpp	/^   ~work(void) {}$/;"	f	class:process::work
